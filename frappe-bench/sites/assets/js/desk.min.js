var Rollup = (function (exports) {
	'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	/*

	Inheritence "Class"
	-------------------
	see: http://ejohn.org/blog/simple-javascript-inheritance/
	To subclass, use:

		var MyClass = Class.extend({
			init: function
		})

	*/
	// https://stackoverflow.com/a/15052240/5353542

	/* Simple JavaScript Inheritance for ES 5.1
	 * based on http://ejohn.org/blog/simple-javascript-inheritance/
	 *  (inspired by base2 and Prototype)
	 * MIT Licensed.
	 */
	(function(global) {
		var fnTest = /xyz/.test(function(){}) ? /\b_super\b/ : /.*/;

		// The base Class implementation (does nothing)
		function Class(){}

		// Create a new Class that inherits from this class
		Class.extend = function(props) {
		  var _super = this.prototype;

		  // Set up the prototype to inherit from the base class
		  // (but without running the init constructor)
		  var proto = Object.create(_super);

		  // Copy the properties over onto the new prototype
		  for (var name in props) {
			// Check if we're overwriting an existing function
			proto[name] = typeof props[name] === "function" &&
			  typeof _super[name] == "function" && fnTest.test(props[name])
			  ? (function(name, fn){
				  return function() {
					var tmp = this._super;

					// Add a new ._super() method that is the same method
					// but on the super-class
					this._super = _super[name];

					// The method only need to be bound temporarily, so we
					// remove it when we're done executing
					var ret = fn.apply(this, arguments);
					this._super = tmp;

					return ret;
				  };
				})(name, props[name])
			  : props[name];
		  }

		  // The new constructor
		  var newClass = typeof proto.init === "function"
			? proto.hasOwnProperty("init")
			  ? proto.init // All construction is actually done in the init method
			  : function SubClass(){ _super.init.apply(this, arguments); }
			: function EmptyClass(){};

		  // Populate our constructed prototype object
		  newClass.prototype = proto;

		  // Enforce the constructor to be what we expect
		  proto.constructor = newClass;

		  // And make this class extendable
		  newClass.extend = Class.extend;

		  return newClass;
		};

		// export
		global.Class = Class;
	  })(commonjsGlobal);

	var _class = {

	};

	// String.prototype.includes polyfill
	// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes
	if (!String.prototype.includes) {
		String.prototype.includes = function(search, start) {
			if (typeof start !== 'number') {
				start = 0;
			}
			if (start + search.length > this.length) {
				return false;
			} else {
				return this.indexOf(search, start) !== -1;
			}
		};
	}
	// Array.prototype.includes polyfill
	// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/includes
	if (!Array.prototype.includes) {
		Object.defineProperty(Array.prototype, 'includes', {
			value: function(searchElement, fromIndex) {
				if (this == null) {
					throw new TypeError('"this" is null or not defined');
				}
				var o = Object(this);
				var len = o.length >>> 0;
				if (len === 0) {
					return false;
				}
				var n = fromIndex | 0;
				var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
				while (k < len) {
					if (o[k] === searchElement) {
						return true;
					}
					k++;
				}
				return false;
			}
		});
	}


	if (typeof String.prototype.trimLeft !== "function") {
		String.prototype.trimLeft = function() {
			return this.replace(/^\s+/, "");
		};
	}
	if (typeof String.prototype.trimRight !== "function") {
		String.prototype.trimRight = function() {
			return this.replace(/\s+$/, "");
		};
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	if (typeof Object.assign != 'function') {
		// Must be writable: true, enumerable: false, configurable: true
		Object.defineProperty(Object, "assign", {
			value: function assign(target) { // .length of function is 2
				var arguments$1 = arguments;

				if (target == null) { // TypeError if undefined or null
					throw new TypeError('Cannot convert undefined or null to object');
				}

				var to = Object(target);

				for (var index = 1; index < arguments.length; index++) {
					var nextSource = arguments$1[index];

					if (nextSource != null) { // Skip over if undefined or null
						for (var nextKey in nextSource) {
							// Avoid bugs when hasOwnProperty is shadowed
							if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
								to[nextKey] = nextSource[nextKey];
							}
						}
					}
				}
				return to;
			},
			writable: true,
			configurable: true
		});
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// provide a namespace
	if(!window.frappe)
		{ window.frappe = {}; }

	frappe.provide = function(namespace) {
		// docs: create a namespace //
		var nsl = namespace.split('.');
		var parent = window;
		for(var i=0; i<nsl.length; i++) {
			var n = nsl[i];
			if(!parent[n]) {
				parent[n] = {};
			}
			parent = parent[n];
		}
		return parent;
	};

	frappe.provide("locals");
	frappe.provide("frappe.flags");
	frappe.provide("frappe.settings");
	frappe.provide("frappe.utils");
	frappe.provide("frappe.ui.form");
	frappe.provide("frappe.modules");
	frappe.provide("frappe.templates");
	frappe.provide("frappe.test_data");
	frappe.provide('frappe.utils');
	frappe.provide('frappe.model');
	frappe.provide('frappe.user');
	frappe.provide('frappe.session');
	frappe.provide('locals.DocType');

	// for listviews
	frappe.provide("frappe.listview_settings");
	frappe.provide("frappe.tour");
	frappe.provide("frappe.listview_parent_route");

	// constants
	window.NEWLINE = '\n';
	window.TAB = 9;
	window.UP_ARROW = 38;
	window.DOWN_ARROW = 40;

	// proxy for user globals defined in desk.js

	// API globals
	window.cur_frm=null;

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// library to mange assets (js, css, models, html) etc in the app.
	// will try and get from localStorage if latest are available
	// depends on frappe.versions to manage versioning

	frappe.require = function(items, callback) {
		if(typeof items === "string") {
			items = [items];
		}
		frappe.assets.execute(items, callback);
	};

	frappe.assets = {
		check: function() {
			// if version is different then clear localstorage
			if(window._version_number != localStorage.getItem("_version_number")) {
				frappe.assets.clear_local_storage();
				console.log("Cleared App Cache.");
			}

			if(localStorage._last_load) {
				var not_updated_since = new Date() - new Date(localStorage._last_load);
				if(not_updated_since < 10000 || not_updated_since > 86400000) {
					frappe.assets.clear_local_storage();
				}
			} else {
				frappe.assets.clear_local_storage();
			}

			frappe.assets.init_local_storage();
		},

		init_local_storage: function() {
			localStorage._last_load = new Date();
			localStorage._version_number = window._version_number;
			if(frappe.boot) { localStorage.metadata_version = frappe.boot.metadata_version; }
		},

		clear_local_storage: function() {
			$.each(["_last_load", "_version_number", "metadata_version", "page_info",
				"last_visited"], function(i, key) {
				localStorage.removeItem(key);
			});

			// clear assets
			for(var key in localStorage) {
				if(key.indexOf("desk_assets:")===0 || key.indexOf("_page:")===0
					|| key.indexOf("_doctype:")===0 || key.indexOf("preferred_breadcrumbs:")===0) {
					localStorage.removeItem(key);
				}
			}
			console.log("localStorage cleared");
		},


		// keep track of executed assets
		executed_ : [],

		// pass on to the handler to set
		execute: function(items, callback) {
			var to_fetch = [];
			for(var i=0, l=items.length; i<l; i++) {
				if(!frappe.assets.exists(items[i])) {
					to_fetch.push(items[i]);
				}
			}
			if(to_fetch.length) {
				frappe.assets.fetch(to_fetch, function() {
					frappe.assets.eval_assets(items, callback);
				});
			} else {
				frappe.assets.eval_assets(items, callback);
			}
		},

		eval_assets: function(items, callback) {
			for(var i=0, l=items.length; i<l; i++) {
				// execute js/css if not already.
				var path = items[i];
				if(frappe.assets.executed_.indexOf(path)===-1) {
					// execute
					frappe.assets.handler[frappe.assets.extn(path)](frappe.assets.get(path), path);
					frappe.assets.executed_.push(path);
				}
			}
			callback && callback();
		},

		// check if the asset exists in
		// localstorage
		exists: function(src) {
			if(frappe.assets.executed_.indexOf(src)!== -1) {
				return true;
			}
			if(frappe.boot.developer_mode) {
				return false;
			}
			if(frappe.assets.get(src)) {
				return true;
			} else {
				return false;
			}
		},

		// load an asset via
		fetch: function(items, callback) {
			// this is virtual page load, only get the the source
			// *without* the template

			frappe.call({
				type: "GET",
				method:"frappe.client.get_js",
				args: {
					"items": items
				},
				callback: function(r) {
					$.each(items, function(i, src) {
						frappe.assets.add(src, r.message[i]);
					});
					callback();
				},
				freeze: true,
			});
		},

		add: function(src, txt) {
			if('localStorage' in window) {
				try {
					frappe.assets.set(src, txt);
				} catch(e) {
					// if quota is exceeded, clear local storage and set item
					frappe.assets.clear_local_storage();
					frappe.assets.set(src, txt);
				}
			}
		},

		get: function(src) {
			return localStorage.getItem("desk_assets:" + src);
		},

		set: function(src, txt) {
			localStorage.setItem("desk_assets:" + src, txt);
		},

		extn: function(src) {
			if(src.indexOf('?')!=-1) {
				src = src.split('?').slice(-1)[0];
			}
			return src.split('.').slice(-1)[0];
		},

		handler: {
			js: function(txt, src) {
				frappe.dom.eval(txt);
			},
			css: function(txt, src) {
				frappe.dom.set_style(txt);
			}
		},
	};

	function format (str, args) {
		if(str==undefined) { return str; }

		this.unkeyed_index = 0;
		return str.replace(/\{(\w*)\}/g, function(match, key) {

			if (key === '') {
				key = this.unkeyed_index;
				this.unkeyed_index++;
			}
			if (key == +key) {
				return args[key] !== undefined
					? args[key]
					: match;
			}
		}.bind(this));
	}

	if (jQuery) {
		jQuery.format = format;
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// for license information please see license.txt

	frappe.provide("frappe.form.formatters");

	frappe.form.link_formatters = {};

	frappe.form.formatters = {
		_right: function(value, options) {
			if(options && (options.inline || options.only_value)) {
				return value;
			} else {
				return "<div style='text-align: right'>" + value + "</div>";
			}
		},
		Data: function(value) {
			return value==null ? "" : value;
		},
		Select: function(value) {
			return __(frappe.form.formatters["Data"](value));
		},
		Float: function(value, docfield, options, doc) {
			// don't allow 0 precision for Floats, hence or'ing with null
			var precision = docfield.precision
				|| cint(frappe.boot.sysdefaults && frappe.boot.sysdefaults.float_precision)
				|| null;
			if (docfield.options && docfield.options.trim()) {
				// options points to a currency field, but expects precision of float!
				docfield.precision = precision;
				return frappe.form.formatters.Currency(value, docfield, options, doc);

			} else {
				// show 1.000000 as 1
				if (!(options || {}).always_show_decimals && !is_null(value)) {
					var temp = cstr(value).split(".");
					if (temp[1]==undefined || cint(temp[1])===0) {
						precision = 0;
					}
				}

				return frappe.form.formatters._right(
					((value==null || value==="")
						? ""
						: format_number(value, null, precision)), options);
			}
		},
		Int: function(value, docfield, options) {
			return frappe.form.formatters._right(value==null ? "" : cint(value), options)
		},
		Percent: function(value, docfield, options) {
			return frappe.form.formatters._right(flt(value, 2) + "%", options)
		},
		Rating: function(value) {
			return ("<span class=\"rating\">\n\t" + (Array.from(new Array(5)).map(function (_, i) { return ("<i class=\"fa fa-fw fa-star " + (i < (value || 0) ? "star-click": "") + " star-icon\" data-idx=\"" + ((i+1)) + "\"></i>"); }
		).join('')) + "\n\t\t</span>");
		},
		Currency: function (value, docfield, options, doc) {
			var currency  = frappe.meta.get_field_currency(docfield, doc);
			var precision = docfield.precision || cint(frappe.boot.sysdefaults.currency_precision) || 2;

			// If you change anything below, it's going to hurt a company in UAE, a bit.
			if (precision > 2) {
				var parts	 = cstr(value).split("."); // should be minimum 2, comes from the DB
				var decimals = parts.length > 1 ? parts[1] : ""; // parts.length == 2 ???

				if ( decimals.length < 3 || decimals.length < precision ) {
					var fraction = frappe.model.get_value(":Currency", currency, "fraction_units") || 100; // if not set, minimum 2.

					if (decimals.length < cstr(fraction).length) {
						precision = cstr(fraction).length - 1;
					}
				}
			}

			value = (value == null || value === "") ? "" : format_currency(value, currency, precision);

			if ( options && options.only_value ) {
				return value;
			} else {
				return frappe.form.formatters._right(value, options);
			}
		},
		Check: function(value) {
			if(value) {
				return '<i class="fa fa-check" style="margin-right: 3px;"></i>';
			} else {
				return '<i class="fa fa-square disabled-check"></i>';
			}
		},
		Link: function(value, docfield, options, doc) {
			var doctype = docfield._options || docfield.options;
			var original_value = value;
			if(value && value.match && value.match(/^['"].*['"]$/)) {
				value.replace(/^.(.*).$/, "$1");
			}

			if(options && (options.for_print || options.only_value)) {
				return value;
			}

			if(frappe.form.link_formatters[doctype]) {
				// don't apply formatters in case of composite (parent field of same type)
				if (doc && doctype !== doc.doctype) {
					value = frappe.form.link_formatters[doctype](value, doc);
				}
			}

			if(!value) {
				return "";
			}
			if(value[0] == "'" && value[value.length -1] == "'") {
				return value.substring(1, value.length - 1);
			}
			if(docfield && docfield.link_onclick) {
				return repl('<a onclick="%(onclick)s">%(value)s</a>',
					{onclick: docfield.link_onclick.replace(/"/g, '&quot;'), value:value});
			} else if(docfield && doctype) {
				return ("<a class=\"grey\"\n\t\t\t\thref=\"#Form/" + (encodeURIComponent(doctype)) + "/" + (encodeURIComponent(original_value)) + "\"\n\t\t\t\tdata-doctype=\"" + doctype + "\"\n\t\t\t\tdata-name=\"" + original_value + "\">\n\t\t\t\t" + (__(options && options.label || value)) + "</a>")
			} else {
				return value;
			}
		},
		Date: function(value) {
			if (!frappe.datetime.str_to_user) {
				return value;
			}
			if (value) {
				value = frappe.datetime.str_to_user(value);
				// handle invalid date
				if (value==="Invalid date") {
					value = null;
				}
			}

			return value || "";
		},
		DateRange: function(value) {
			if($.isArray(value)) {
				return __("{0} to {1}", [frappe.datetime.str_to_user(value[0]), frappe.datetime.str_to_user(value[1])]);
			} else {
				return value || "";
			}
		},
		Datetime: function(value) {
			if(value) {
				var m = moment(frappe.datetime.convert_to_user_tz(value));
				if(frappe.boot.sysdefaults.time_zone) {
					m = m.tz(frappe.boot.sysdefaults.time_zone);
				}
				return m.format(frappe.boot.sysdefaults.date_format.toUpperCase()
					+  ' ' + frappe.boot.sysdefaults.time_format);
			} else {
				return "";
			}
		},
		Text: function(value) {
			if(value) {
				var tags = ["<p", "<div", "<br", "<table"];
				var match = false;

				for(var i=0; i<tags.length; i++) {
					if(value.match(tags[i])) {
						match = true;
						break;
					}
				}

				if(!match) {
					value = frappe.utils.replace_newlines(value);
				}
			}

			return frappe.form.formatters.Data(value);
		},
		Time: function(value) {
			if (value) {
				value = frappe.datetime.str_to_user(value, true);
			}

			return value || "";
		},
		Duration: function(value, docfield) {
			if (value) {
				var duration_options = frappe.utils.get_duration_options(docfield);
				value = frappe.utils.get_formatted_duration(value, duration_options);
			}

			return value || "";
		},
		LikedBy: function(value) {
			var html = "";
			$.each(JSON.parse(value || "[]"), function(i, v) {
				if(v) { html+= frappe.avatar(v); }
			});
			return html;
		},
		Tag: function(value) {
			var html = "";
			$.each((value || "").split(","), function(i, v) {
				if(v) { html+= '<span class="label label-info" \
				style="margin-right: 7px; cursor: pointer;"\
				data-field="_user_tags" data-label="'+v+'">'+v +'</span>'; }
			});
			return html;
		},
		Comment: function(value) {
			return value;
		},
		Assign: function(value) {
			var html = "";
			$.each(JSON.parse(value || "[]"), function(i, v) {
				if(v) { html+= '<span class="label label-warning" \
				style="margin-right: 7px;"\
				data-field="_assign">'+v+'</span>'; }
			});
			return html;
		},
		SmallText: function(value) {
			return frappe.form.formatters.Text(value);
		},
		TextEditor: function(value) {
			var formatted_value = frappe.form.formatters.Text(value);
			// to use ql-editor styles
			try {
				if (!$(formatted_value).find('.ql-editor').length) {
					formatted_value = "<div class=\"ql-editor read-mode\">" + formatted_value + "</div>";
				}
			} catch(e) {
				formatted_value = "<div class=\"ql-editor read-mode\">" + formatted_value + "</div>";
			}

			return formatted_value;
		},
		Code: function(value) {
			return "<pre>" + (value==null ? "" : $("<div>").text(value).html()) + "</pre>"
		},
		WorkflowState: function(value) {
			var workflow_state = frappe.get_doc("Workflow State", value);
			if(workflow_state) {
				return repl("<span class='label label-%(style)s' \
				data-workflow-state='%(value)s'\
				style='padding-bottom: 4px; cursor: pointer;'>\
				<i class='fa fa-small fa-white fa-%(icon)s'></i> %(value)s</span>", {
						value: value,
						style: workflow_state.style.toLowerCase(),
						icon: workflow_state.icon
					});
			} else {
				return "<span class='label'>" + value + "</span>";
			}
		},
		Email: function(value) {
			return $("<div></div>").text(value).html();
		},
		FileSize: function(value) {
			if(value > 1048576) {
				value = flt(flt(value) / 1048576, 1) + "M";
			} else if (value > 1024) {
				value = flt(flt(value) / 1024, 1) + "K";
			}
			return value;
		},
		TableMultiSelect: function(rows, df, options) {
			rows = rows || [];
			var meta = frappe.get_meta(df.options);
			var link_field = meta.fields.find(function (df) { return df.fieldtype === 'Link'; });
			var formatted_values = rows.map(function (row) {
				var value = row[link_field.fieldname];
				return frappe.format(value, link_field, options, row);
			});
			return formatted_values.join(', ');
		}
	};

	frappe.form.get_formatter = function(fieldtype) {
		if(!fieldtype)
			{ fieldtype = "Data"; }
		return frappe.form.formatters[fieldtype.replace(/ /g, "")] || frappe.form.formatters.Data;
	};

	frappe.format = function(value, df, options, doc) {
		if(!df) { df = {"fieldtype":"Data"}; }
		var fieldtype = df.fieldtype || "Data";

		// format Dynamic Link as a Link
		if(fieldtype==="Dynamic Link") {
			fieldtype = "Link";
			df._options = doc ? doc[df.options] : null;
		}

		var formatter = df.formatter || frappe.form.get_formatter(fieldtype);

		var formatted = formatter(value, df, options, doc);

		if (typeof formatted == "string")
			{ formatted = frappe.dom.remove_script_and_style(formatted); }

		return formatted;
	};

	frappe.get_format_helper = function(doc) {
		var helper = {
			get_formatted: function(fieldname) {
				var df = frappe.meta.get_docfield(doc.doctype, fieldname);
				if(!df) { console.log("fieldname not found: " + fieldname); }
				return frappe.format(doc[fieldname], df, {inline:1}, doc);
			}
		};
		$.extend(helper, doc);
		return helper;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// add a new dom element
	frappe.provide('frappe.dom');

	frappe.dom = {
		id_count: 0,
		freeze_count: 0,
		by_id: function(id) {
			return document.getElementById(id);
		},
		get_unique_id: function() {
			var id = 'unique-' + frappe.dom.id_count;
			frappe.dom.id_count++;
			return id;
		},
		set_unique_id: function(ele) {
			var $ele = $(ele);
			if($ele.attr('id')) {
				return $ele.attr('id');
			}
			var id = 'unique-' + frappe.dom.id_count;
			$ele.attr('id', id);
			frappe.dom.id_count++;
			return id;
		},
		eval: function(txt) {
			if(!txt) { return; }
			var el = document.createElement('script');
			el.appendChild(document.createTextNode(txt));
			// execute the script globally
			document.getElementsByTagName('head')[0].appendChild(el);
		},
		remove_script_and_style: function(txt) {
			var evil_tags = ["script", "style", "noscript", "title", "meta", "base", "head"];
			var regex = new RegExp(evil_tags.map(function (tag) { return ("<" + tag + ">.*<\\/" + tag + ">"); }).join('|'), 's');
			if (!regex.test(txt)) {
				// no evil tags found, skip the DOM method entirely!
				return txt;
			}

			var div = document.createElement('div');
			div.innerHTML = txt;
			var found = false;
			evil_tags.forEach(function(e) {
				var elements = div.getElementsByTagName(e);
				i = elements.length;
				while (i--) {
					found = true;
					elements[i].parentNode.removeChild(elements[i]);
				}
			});

			// remove links with rel="stylesheet"
			var elements = div.getElementsByTagName('link');
			var i = elements.length;
			while (i--) {
				if (elements[i].getAttribute("rel")=="stylesheet"){
					found = true;
					elements[i].parentNode.removeChild(elements[i]);
				}
			}
			if(found) {
				return div.innerHTML;
			} else {
				// don't disturb
				return txt;
			}
		},
		is_element_in_viewport: function (el, tolerance) {
			if ( tolerance === void 0 ) tolerance=0;


			//special bonus for those using jQuery
			if (typeof jQuery === "function" && el instanceof jQuery) {
				el = el[0];
			}

			var rect = el.getBoundingClientRect();

			return (
				rect.top + tolerance >= 0
				&& rect.left + tolerance >= 0
				&& rect.bottom - tolerance <= $(window).height()
				&& rect.right - tolerance <= $(window).width()
			);
		},

		is_element_in_modal: function is_element_in_modal(element) {
			return Boolean($(element).parents('.modal').length);
		},

		set_style: function(txt, id) {
			if(!txt) { return; }

			var se = document.createElement('style');
			se.type = "text/css";

			if (id) {
				var element = document.getElementById(id);
				if (element) {
					element.parentNode.removeChild(element);
				}
				se.id = id;
			}

			if (se.styleSheet) {
				se.styleSheet.cssText = txt;
			} else {
				se.appendChild(document.createTextNode(txt));
			}
			document.getElementsByTagName('head')[0].appendChild(se);
			return se;
		},
		add: function(parent, newtag, className, cs, innerHTML, onclick) {
			if(parent && parent.substr){ parent = frappe.dom.by_id(parent); }
			var c = document.createElement(newtag);
			if(parent)
				{ parent.appendChild(c); }

			// if image, 3rd parameter is source
			if(className) {
				if(newtag.toLowerCase()=='img')
					{ c.src = className; }
				else
					{ c.className = className; }
			}
			if(cs) { frappe.dom.css(c,cs); }
			if(innerHTML) { c.innerHTML = innerHTML; }
			if(onclick) { c.onclick = onclick; }
			return c;
		},
		css: function(ele, s) {
			if(ele && s) {
				$.extend(ele.style, s);
			}
			return ele;
		},
		activate: function($parent, $child, common_class, active_class) {
			if ( active_class === void 0 ) active_class='active';

			$parent.find(("." + common_class + "." + active_class))
				.removeClass(active_class);
			$child.addClass(active_class);
		},
		freeze: function(msg, css_class) {
			// blur
			if(!$('#freeze').length) {
				var freeze = $('<div id="freeze" class="modal-backdrop fade"></div>')
					.on("click", function() {
						if (cur_frm && cur_frm.cur_grid) {
							cur_frm.cur_grid.toggle_view();
							return false;
						}
					})
					.appendTo("#body_div");

				freeze.html(repl('<div class="freeze-message-container"><div class="freeze-message"><p class="lead">%(msg)s</p></div></div>',
					{msg: msg || ""}));

				setTimeout(function() { freeze.addClass("in"); }, 1);

			} else {
				$("#freeze").addClass("in");
			}

			if (css_class) {
				$("#freeze").addClass(css_class);
			}

			frappe.dom.freeze_count++;
		},
		unfreeze: function() {
			if(!frappe.dom.freeze_count) { return; } // anything open?
			frappe.dom.freeze_count--;
			if(!frappe.dom.freeze_count) {
				var freeze = $('#freeze').removeClass("in").remove();
			}
		},
		save_selection: function() {
			// via http://stackoverflow.com/questions/5605401/insert-link-in-contenteditable-element
			if (window.getSelection) {
				var sel = window.getSelection();
				if (sel.getRangeAt && sel.rangeCount) {
					var ranges = [];
					for (var i = 0, len = sel.rangeCount; i < len; ++i) {
						ranges.push(sel.getRangeAt(i));
					}
					return ranges;
				}
			} else if (document.selection && document.selection.createRange) {
				return document.selection.createRange();
			}
			return null;
		},
		restore_selection: function(savedSel) {
			if (savedSel) {
				if (window.getSelection) {
					var sel = window.getSelection();
					sel.removeAllRanges();
					for (var i = 0, len = savedSel.length; i < len; ++i) {
						sel.addRange(savedSel[i]);
					}
				} else if (document.selection && savedSel.select) {
					savedSel.select();
				}
			}
		},
		is_touchscreen: function() {
			return ('ontouchstart' in window)
		},
		handle_broken_images: function handle_broken_images(container) {
			$(container).find('img').on('error', function (e) {
				var $img = $(e.currentTarget);
				$img.addClass('no-image');
			});
		},
		scroll_to_bottom: function scroll_to_bottom(container) {
			var $container = $(container);
			$container.scrollTop($container[0].scrollHeight);
		},
		file_to_base64: function file_to_base64(file_obj) {
			return new Promise(function (resolve) {
				var reader = new FileReader();
				reader.onload = function() {
					resolve(reader.result);
				};
				reader.readAsDataURL(file_obj);
			});
		},
		scroll_to_section: function scroll_to_section(section_name) {
			setTimeout(function () {
				var section = $(("a:contains(\"" + section_name + "\")"));
				if (section.length) {
					if(section.parent().hasClass('collapsed')) {
						// opens the section
						section.click();
					}
					frappe.ui.scroll(section.parent().parent());
				}
			}, 200);
		},
		pixel_to_inches: function pixel_to_inches(pixels) {
			var div = $('<div id="dpi" style="height: 1in; width: 1in; left: 100%; position: fixed; top: 100%;"></div>');
			div.appendTo(document.body);

			var dpi_x = document.getElementById('dpi').offsetWidth;
			var inches = pixels / dpi_x;
			div.remove();

			return inches;
		}
	};

	frappe.ellipsis = function(text, max) {
		if(!max) { max = 20; }
		text = cstr(text);
		if(text.length > max) {
			text = text.substr(0, max) + '...';
		}
		return text;
	};

	frappe.run_serially = function(tasks) {
		var result = Promise.resolve();
		tasks.forEach(function (task) {
			if(task) {
				result = result.then ? result.then(task) : Promise.resolve();
			}
		});
		return result;
	};

	frappe.load_image = function (src, onload, onerror, preprocess) {
		if ( preprocess === void 0 ) preprocess = function () {};

		var tester = new Image();
		tester.onload = function() {
			onload(this);
		};
		tester.onerror = onerror;

		preprocess(tester);
		tester.src = src;
	};

	frappe.timeout = function (seconds) {
		return new Promise(function (resolve) {
			setTimeout(function () { return resolve(); }, seconds * 1000);
		});
	};

	frappe.scrub = function(text, spacer) {
		if ( spacer === void 0 ) spacer='_';

		return text.replace(/ /g, spacer).toLowerCase();
	};

	frappe.get_modal = function(title, content) {
		return $(("<div class=\"modal fade\" style=\"overflow: auto;\" tabindex=\"-1\">\n\t\t<div class=\"modal-dialog\">\n\t\t\t<div class=\"modal-content\">\n\t\t\t\t<div class=\"modal-header\">\n\t\t\t\t\t<div class=\"flex justify-between\">\n\t\t\t\t\t\t<div class=\"fill-width flex\">\n\t\t\t\t\t\t\t<span class=\"indicator hidden\"></span>\n\t\t\t\t\t\t\t<h4 class=\"modal-title\" style=\"font-weight: bold;\">" + title + "</h4>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<div class=\"text-right buttons\">\n\t\t\t\t\t\t\t\t<button type=\"button\" class=\"btn btn-default btn-sm btn-modal-minimize hide\">\n\t\t\t\t\t\t\t\t\t<i class=\"octicon octicon-chevron-down\" style=\"padding: 1px 0px;\"></i>\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<button type=\"button\" class=\"btn btn-default btn-sm btn-modal-close\" data-dismiss=\"modal\">\n\t\t\t\t\t\t\t\t\t<i class=\"octicon octicon-x visible-xs\" style=\"padding: 1px 0px;\"></i>\n\t\t\t\t\t\t\t\t\t<span class=\"hidden-xs\">" + (__("Close")) + "</span>\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<button type=\"button\" class=\"btn btn-primary btn-sm hide\">\n\t\t\t\t\t\t\t\t\t" + (__("Confirm")) + "\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"modal-body ui-front\">" + content + "</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>"));
	};

	frappe.is_online = function() {
		if (frappe.boot.developer_mode == 1) {
			// always online in developer_mode
			return true;
		}
		if ('onLine' in navigator) {
			return navigator.onLine;
		}
		return true;
	};

	// bind online/offline events
	$(window).on('online', function() {
		frappe.show_alert({
			indicator: 'green',
			message: __('You are connected to internet.')
		});
	});

	$(window).on('offline', function() {
		frappe.show_alert({
			indicator: 'orange',
			message: __('Connection lost. Some features might not work.')
		});
	});

	frappe.ui.form.Layout = Class.extend({
		init: function(opts) {
			this.views = {};
			this.pages = [];
			this.sections = [];
			this.fields_list = [];
			this.fields_dict = {};

			$.extend(this, opts);
		},
		make: function() {
			if(!this.parent && this.body) {
				this.parent = this.body;
			}
			this.wrapper = $('<div class="form-layout">').appendTo(this.parent);
			this.message = $('<div class="form-message text-muted small hidden"></div>').appendTo(this.wrapper);
			if(!this.fields) {
				this.fields = this.get_doctype_fields();
			}
			this.setup_tabbing();
			this.render();
		},
		show_empty_form_message: function() {
			if(!(this.wrapper.find(".frappe-control:visible").length || this.wrapper.find(".section-head.collapsed").length)) {
				this.show_message(__("This form does not have any input"));
			}
		},
		get_doctype_fields: function() {
			var fields = [
				{
					parent: this.frm.doctype,
					fieldtype: 'Data',
					fieldname: '__newname',
					reqd: 1,
					hidden: 1,
					label: __('Name'),
					get_status: function(field) {
						if (field.frm && field.frm.is_new()
							&& field.frm.meta.autoname
							&& ['prompt', 'name'].includes(field.frm.meta.autoname.toLowerCase())) {
							return 'Write';
						}
						return 'None';
					}
				}
			];
			fields = fields.concat(frappe.meta.sort_docfields(frappe.meta.docfield_map[this.doctype]));
			return fields;
		},
		show_message: function(html, color) {
			if (this.message_color) {
				// remove previous color
				this.message.removeClass(this.message_color);
			}
			this.message_color = (color && ['yellow', 'blue'].includes(color)) ? color : 'blue';
			if(html) {
				if(html.substr(0, 1)!=='<') {
					// wrap in a block
					html = '<div>' + html + '</div>';
				}
				this.message.removeClass('hidden').addClass(this.message_color);
				$(html).appendTo(this.message);
			} else {
				this.message.empty().addClass('hidden');
			}
		},
		render: function(new_fields) {
			var me = this;
			var fields = new_fields || this.fields;

			this.section = null;
			this.column = null;

			if (this.with_dashboard) {
				this.setup_dashboard_section();
			}

			if (this.no_opening_section()) {
				this.make_section();
			}
			$.each(fields, function(i, df) {
				switch(df.fieldtype) {
					case "Fold":
						me.make_page(df);
						break;
					case "Section Break":
						me.make_section(df);
						break;
					case "Column Break":
						me.make_column(df);
						break;
					default:
						me.make_field(df);
				}
			});

		},

		no_opening_section: function() {
			return (this.fields[0] && this.fields[0].fieldtype!="Section Break") || !this.fields.length;
		},

		setup_dashboard_section: function() {
			if (this.no_opening_section()) {
				this.fields.unshift({fieldtype: 'Section Break'});
			}

			this.fields.unshift({
				fieldtype: 'Section Break',
				fieldname: '_form_dashboard',
				label: __('Dashboard'),
				cssClass: 'form-dashboard',
				collapsible: 1,
				//hidden: 1
			});
		},

		replace_field: function(fieldname, df, render) {
			df.fieldname = fieldname; // change of fieldname is avoided
			if (this.fields_dict[fieldname] && this.fields_dict[fieldname].df) {
				var fieldobj = this.init_field(df, render);
				this.fields_dict[fieldname].$wrapper.remove();
				this.fields_list.splice(this.fields_dict[fieldname], 1, fieldobj);
				this.fields_dict[fieldname] = fieldobj;
				if (this.frm) {
					fieldobj.perm = this.frm.perm;
				}
				this.section.fields_list.splice(this.section.fields_dict[fieldname], 1, fieldobj);
				this.section.fields_dict[fieldname] = fieldobj;
				this.refresh_fields([df]);
			}
		},

		make_field: function(df, colspan, render) {
			!this.section && this.make_section();
			!this.column && this.make_column();

			var fieldobj = this.init_field(df, render);
			this.fields_list.push(fieldobj);
			this.fields_dict[df.fieldname] = fieldobj;
			if(this.frm) {
				fieldobj.perm = this.frm.perm;
			}

			this.section.fields_list.push(fieldobj);
			this.section.fields_dict[df.fieldname] = fieldobj;
			fieldobj.section = this.section;
		},

		init_field: function(df, render) {
			if ( render === void 0 ) render = false;

			var fieldobj = frappe.ui.form.make_control({
				df: df,
				doctype: this.doctype,
				parent: this.column.wrapper.get(0),
				frm: this.frm,
				render_input: render,
				doc: this.doc
			});

			fieldobj.layout = this;
			return fieldobj;
		},

		make_page: function(df) {
			var me = this,
				head = $('<div class="form-clickable-section text-center">\
				<a class="btn-fold h6 text-muted">'+__("Show more details")+'</a>\
			</div>').appendTo(this.wrapper);

			this.page = $('<div class="form-page second-page hide"></div>').appendTo(this.wrapper);

			this.fold_btn = head.find(".btn-fold").on("click", function() {
				var page = $(this).parent().next();
				if(page.hasClass("hide")) {
					$(this).removeClass("btn-fold").html(__("Hide details"));
					page.removeClass("hide");
					frappe.utils.scroll_to($(this), true, 30);
					me.folded = false;
				} else {
					$(this).addClass("btn-fold").html(__("Show more details"));
					page.addClass("hide");
					me.folded = true;
				}
			});

			this.section = null;
			this.folded = true;
		},

		unfold: function() {
			this.fold_btn.trigger('click');
		},

		make_section: function(df) {
			this.section = new frappe.ui.form.Section(this, df);

			// append to layout fields
			if(df) {
				this.fields_dict[df.fieldname] = this.section;
				this.fields_list.push(this.section);
			}

			this.column = null;
		},

		make_column: function(df) {
			this.column = new frappe.ui.form.Column(this.section, df);
			if(df && df.fieldname) {
				this.fields_list.push(this.column);
			}
		},

		refresh: function(doc) {
			var me = this;
			if(doc) { this.doc = doc; }

			if (this.frm) {
				this.wrapper.find(".empty-form-alert").remove();
			}

			// NOTE this might seem redundant at first, but it needs to be executed when frm.refresh_fields is called
			me.attach_doc_and_docfields(true);

			if(this.frm && this.frm.wrapper) {
				$(this.frm.wrapper).trigger("refresh-fields");
			}

			// dependent fields
			this.refresh_dependency();

			// refresh sections
			this.refresh_sections();

			// collapse sections
			if(this.frm) {
				this.refresh_section_collapse();
			}
		},

		refresh_sections: function() {
			var cnt = 0;

			// hide invisible sections and set alternate background color
			this.wrapper.find(".form-section:not(.hide-control)").each(function() {
				var $this = $(this).removeClass("empty-section")
					.removeClass("visible-section")
					.removeClass("shaded-section");
				if(!$this.find(".frappe-control:not(.hide-control)").length
					&& !$this.hasClass('form-dashboard')) {
					// nothing visible, hide the section
					$this.addClass("empty-section");
				} else {
					$this.addClass("visible-section");
					if(cnt % 2) {
						$this.addClass("shaded-section");
					}
					cnt++;
				}
			});
		},

		refresh_fields: function(fields) {
			var fieldnames = fields.map(function (field) {
				if(field.fieldname) { return field.fieldname; }
			});

			this.fields_list.map(function (fieldobj) {
				if(fieldnames.includes(fieldobj.df.fieldname)) {
					fieldobj.refresh();
					if(fieldobj.df["default"]) {
						fieldobj.set_input(fieldobj.df["default"]);
					}
				}
			});
		},

		add_fields: function(fields) {
			this.render(fields);
			this.refresh_fields(fields);
		},

		refresh_section_collapse: function() {
			if(!this.doc) { return; }

			for(var i=0; i<this.sections.length; i++) {
				var section = this.sections[i];
				var df = section.df;
				if(df && df.collapsible) {
					var collapse = true;

					if(df.collapsible_depends_on) {
						collapse = !this.evaluate_depends_on_value(df.collapsible_depends_on);
					}

					if (collapse && section.has_missing_mandatory()) {
						collapse = false;
					}

					if(df.fieldname === '_form_dashboard') {
						collapse = localStorage.getItem('collapseFormDashboard')==='yes' ? true : false;
					}

					section.collapse(collapse);
				}
			}
		},

		attach_doc_and_docfields: function(refresh) {
			var me = this;
			for(var i=0, l=this.fields_list.length; i<l; i++) {
				var fieldobj = this.fields_list[i];
				if(me.doc) {
					fieldobj.doc = me.doc;
					fieldobj.doctype = me.doc.doctype;
					fieldobj.docname = me.doc.name;
					fieldobj.df = frappe.meta.get_docfield(me.doc.doctype,
						fieldobj.df.fieldname, me.frm ? me.frm.doc.name : me.doc.name) || fieldobj.df;

					// on form change, permissions can change
					if(me.frm) {
						fieldobj.perm = me.frm.perm;
					}
				}
				refresh && fieldobj.df && fieldobj.refresh && fieldobj.refresh();
			}
		},

		refresh_section_count: function() {
			this.wrapper.find(".section-count-label:visible").each(function(i) {
				$(this).html(i+1);
			});
		},
		setup_tabbing: function() {
			var me = this;
			this.wrapper.on("keydown", function(ev) {
				if(ev.which==9) {
					var current = $(ev.target),
						doctype = current.attr("data-doctype"),
						fieldname = current.attr("data-fieldname");
					if(doctype)
						{ return me.handle_tab(doctype, fieldname, ev.shiftKey); }
				}
			});
		},
		handle_tab: function(doctype, fieldname, shift) {
			var me = this,
				grid_row = null,
				prev = null,
				fields = me.fields_list,
				focused = false;

			// in grid
			if(doctype != me.doctype) {
				grid_row = me.get_open_grid_row();
				if(!grid_row || !grid_row.layout) {
					return;
				}
				fields = grid_row.layout.fields_list;
			}

			for(var i=0, len=fields.length; i < len; i++) {
				if(fields[i].df.fieldname==fieldname) {
					if(shift) {
						if(prev) {
							this.set_focus(prev);
						} else {
							$(this.primary_button).focus();
						}
						break;
					}
					if(i < len-1) {
						focused = me.focus_on_next_field(i, fields);
					}

					if (focused) {
						break;
					}
				}
				if(this.is_visible(fields[i]))
					{ prev = fields[i]; }
			}

			if (!focused) {
				// last field in this group
				if(grid_row) {
					// in grid
					if(grid_row.doc.idx==grid_row.grid.grid_rows.length) {
						// last row, close it and find next field
						grid_row.toggle_view(false, function() {
							grid_row.grid.frm.layout.handle_tab(grid_row.grid.df.parent, grid_row.grid.df.fieldname);
						});
					} else {
						// next row
						grid_row.grid.grid_rows[grid_row.doc.idx].toggle_view(true);
					}
				} else {
					$(this.primary_button).focus();
				}
			}

			return false;
		},
		focus_on_next_field: function(start_idx, fields) {
			// loop to find next eligible fields
			for(var i= start_idx + 1, len = fields.length; i < len; i++) {
				var field = fields[i];
				if(this.is_visible(field)) {
					if(field.df.fieldtype==="Table") {
						// open table grid
						if(!(field.grid.grid_rows && field.grid.grid_rows.length)) {
							// empty grid, add a new row
							field.grid.add_new_row();
						}
						// show grid row (if exists)
						field.grid.grid_rows[0].show_form();
						return true;

					} else if(!in_list(frappe.model.no_value_type, field.df.fieldtype)) {
						this.set_focus(field);
						return true;
					}
				}
			}
		},
		is_visible: function(field) {
			return field.disp_status==="Write" && (field.$wrapper && field.$wrapper.is(":visible"));
		},
		set_focus: function(field) {
			// next is table, show the table
			if(field.df.fieldtype=="Table") {
				if(!field.grid.grid_rows.length) {
					field.grid.add_new_row(1);
				} else {
					field.grid.grid_rows[0].toggle_view(true);
				}
			} else if(field.editor) {
				field.editor.set_focus();
			} else if(field.$input) {
				field.$input.focus();
			}
		},
		get_open_grid_row: function() {
			return $(".grid-row-open").data("grid_row");
		},
		refresh_dependency: function() {
			// Resolve "depends_on" and show / hide accordingly
			var me = this;

			// build dependants' dictionary
			var has_dep = false;

			for (var fkey in this.fields_list) {
				var f = this.fields_list[fkey];
				f.dependencies_clear = true;
				if (f.df.depends_on || f.df.mandatory_depends_on || f.df.read_only_depends_on) {
					has_dep = true;
				}
			}

			if (!has_dep) { return; }

			// show / hide based on values
			for (var i=me.fields_list.length-1;i>=0;i--) {
				var f = me.fields_list[i];
				f.guardian_has_value = true;
				if (f.df.depends_on) {
					// evaluate guardian

					f.guardian_has_value = this.evaluate_depends_on_value(f.df.depends_on);

					// show / hide
					if (f.guardian_has_value) {
						if(f.df.hidden_due_to_dependency) {
							f.df.hidden_due_to_dependency = false;
							f.refresh();
						}
					} else {
						if(!f.df.hidden_due_to_dependency) {
							f.df.hidden_due_to_dependency = true;
							f.refresh();
						}
					}
				}

				if (f.df.mandatory_depends_on) {
					this.set_dependant_property(f.df.mandatory_depends_on, f.df.fieldname, 'reqd');
				}

				if (f.df.read_only_depends_on) {
					this.set_dependant_property(f.df.read_only_depends_on, f.df.fieldname, 'read_only');
				}
			}

			this.refresh_section_count();
		},
		set_dependant_property: function(condition, fieldname, property) {
			var set_property = this.evaluate_depends_on_value(condition);
			var form_obj;

			if (this.frm) {
				form_obj = this.frm;
			} else if (this.is_dialog) {
				form_obj = this;
			}
			if (form_obj) {
				if (set_property) {
					form_obj.set_df_property(fieldname, property, 1);
				} else {
					form_obj.set_df_property(fieldname, property, 0);
				}
			}
		},
		evaluate_depends_on_value: function(expression) {
			var out = null;
			var doc = this.doc;

			if (!doc && this.get_values) {
				var doc = this.get_values(true);
			}

			if (!doc) {
				return;
			}

			var parent = this.frm ? this.frm.doc : this.doc || null;

			if(typeof(expression) === 'boolean') {
				out = expression;

			} else if(typeof(expression) === 'function') {
				out = expression(doc);

			} else if(expression.substr(0,5)=='eval:') {
				try {
					out = eval(expression.substr(5));
					if(parent && parent.istable && expression.includes('is_submittable')) {
						out = true;
					}
				} catch(e) {
					frappe.throw(__('Invalid "depends_on" expression'));
				}

			} else if(expression.substr(0,3)=='fn:' && this.frm) {
				out = this.frm.script_manager.trigger(expression.substr(3), this.doctype, this.docname);
			} else {
				var value = doc[expression];
				if($.isArray(value)) {
					out = !!value.length;
				} else {
					out = !!value;
				}
			}

			return out;
		}
	});

	frappe.ui.form.Section = Class.extend({
		init: function(layout, df) {
			this.layout = layout;
			this.df = df || {};
			this.fields_list = [];
			this.fields_dict = {};

			this.make();
			// if(this.frm)
			// 	this.section.body.css({"padding":"0px 3%"})
			this.row = {
				wrapper: this.wrapper
			};

			if (this.df.collapsible && this.df.fieldname !== '_form_dashboard') {
				this.collapse(true);
			}

			this.refresh();
		},
		make: function() {
			if(!this.layout.page) {
				this.layout.page = $('<div class="form-page"></div>').appendTo(this.layout.wrapper);
			}

			this.wrapper = $('<div class="row form-section">')
				.appendTo(this.layout.page);
			this.layout.sections.push(this);

			if(this.df) {
				if(this.df.label) {
					this.make_head();
				}
				if(this.df.description) {
					$('<div class="col-sm-12 small text-muted form-section-description">' + __(this.df.description) + '</div>')
						.appendTo(this.wrapper);
				}
				if(this.df.cssClass) {
					this.wrapper.addClass(this.df.cssClass);
				}
				if (this.df.hide_border) {
					this.wrapper.toggleClass("hide-border", true);
				}
			}

			// for bc
			this.body = $('<div class="section-body">').appendTo(this.wrapper);
		},

		make_head: function() {
			var me = this;
			if(!this.df.collapsible) {
				$('<div class="col-sm-12"><h6 class="form-section-heading uppercase">'
					+ __(this.df.label) + '</h6></div>')
					.appendTo(this.wrapper);
			} else {
				this.head = $('<div class="section-head"><a class="h6 uppercase">'
					+__(this.df.label)+'</a><span class="octicon octicon-chevron-down collapse-indicator"></span></div>').appendTo(this.wrapper);

				// show / hide based on status
				this.collapse_link = this.head.on("click", function() {
					me.collapse();
				});

				this.indicator = this.head.find(".collapse-indicator");
			}
		},
		refresh: function() {
			if(!this.df)
				{ return; }

			// hide if explictly hidden
			var hide = this.df.hidden || this.df.hidden_due_to_dependency;

			// hide if no perm
			if(!hide && this.layout && this.layout.frm && !this.layout.frm.get_perm(this.df.permlevel || 0, "read")) {
				hide = true;
			}

			this.wrapper.toggleClass("hide-control", !!hide);
		},
		collapse: function(hide) {
			// unknown edge case
			if (!(this.head && this.body)) {
				return;
			}

			if(hide===undefined) {
				hide = !this.body.hasClass("hide");
			}

			if (this.df.fieldname==='_form_dashboard') {
				localStorage.setItem('collapseFormDashboard', hide ? 'yes' : 'no');
			}

			this.body.toggleClass("hide", hide);
			this.head.toggleClass("collapsed", hide);
			this.indicator.toggleClass("octicon-chevron-down", hide);
			this.indicator.toggleClass("octicon-chevron-up", !hide);

			// refresh signature fields
			this.fields_list.forEach(function (f) {
				if (f.df.fieldtype=='Signature') {
					f.refresh();
				}
			});
		},

		is_collapsed: function is_collapsed() {
			return this.body.hasClass('hide');
		},

		has_missing_mandatory: function() {
			var missing_mandatory = false;
			for (var j=0, l=this.fields_list.length; j < l; j++) {
				var section_df = this.fields_list[j].df;
				if (section_df.reqd && this.layout.doc[section_df.fieldname]==null) {
					missing_mandatory = true;
					break;
				}
			}
			return missing_mandatory;
		}
	});

	frappe.ui.form.Column = Class.extend({
		init: function(section, df) {
			if(!df) { df = {}; }

			this.df = df;
			this.section = section;
			this.make();
			this.resize_all_columns();
		},
		make: function() {
			this.wrapper = $('<div class="form-column">\
			<form>\
			</form>\
		</div>').appendTo(this.section.body)
				.find("form")
				.on("submit", function() {
					return false;
				});

			if (this.df.label) {
				$('<label class="control-label">' + __(this.df.label)
					+ '</label>').appendTo(this.wrapper);
			}
		},
		resize_all_columns: function() {
			// distribute all columns equally
			var colspan = cint(12 / this.section.wrapper.find(".form-column").length);

			this.section.wrapper.find(".form-column").removeClass()
				.addClass("form-column")
				.addClass("col-sm-" + colspan);

		},
		refresh: function() {
			this.section.refresh();
		}
	});

	frappe.provide('frappe.ui');

	frappe.ui.FieldGroup = frappe.ui.form.Layout.extend({
		init: function(opts) {
			$.extend(this, opts);
			this.dirty = false;
			this._super();
			$.each(this.fields || [], function(i, f) {
				if(!f.fieldname && f.label) {
					f.fieldname = f.label.replace(/ /g, "_").toLowerCase();
				}
			});
			if(this.values) {
				this.set_values(this.values);
			}
		},
		make: function() {
			var this$1 = this;

			var me = this;
			if(this.fields) {
				this._super();
				this.refresh();
				// set default
				$.each(this.fields_list, function(i, field) {
					if (field.df["default"]) {
						var def_value = field.df["default"];

						if (def_value == 'Today' && field.df["fieldtype"] == 'Date') {
							def_value = frappe.datetime.get_today();
						}

						field.set_input(def_value);
						// if default and has depends_on, render its fields.
						me.refresh_dependency();
					}
				});

				if(!this.no_submit_on_enter) {
					this.catch_enter_as_submit();
				}

				$(this.wrapper).find('input, select').on('change', function () {
					this$1.dirty = true;

					frappe.run_serially([
						function () { return frappe.timeout(0.1); },
						function () { return me.refresh_dependency(); }
					]);
				});

			}
		},
		first_button: false,
		focus_on_first_input: function() {
			if(this.no_focus) { return; }
			$.each(this.fields_list, function(i, f) {
				if(!in_list(['Date', 'Datetime', 'Time', 'Check'], f.df.fieldtype) && f.set_focus) {
					f.set_focus();
					return false;
				}
			});
		},
		catch_enter_as_submit: function() {
			var me = this;
			$(this.body).find('input[type="text"], input[type="password"], select').keypress(function(e) {
				if(e.which==13) {
					if(me.has_primary_action) {
						e.preventDefault();
						me.get_primary_btn().trigger("click");
					}
				}
			});
		},
		get_input: function(fieldname) {
			var field = this.fields_dict[fieldname];
			return $(field.txt ? field.txt : field.input);
		},
		get_field: function(fieldname) {
			return this.fields_dict[fieldname];
		},
		get_values: function(ignore_errors) {
			var ret = {};
			var errors = [];
			for (var key in this.fields_dict) {
				var f = this.fields_dict[key];
				if (f.get_value) {
					var v = f.get_value();
					if (f.df.reqd && is_null(v))
						{ errors.push(__(f.df.label)); }

					if (f.df.reqd
						&& f.df.fieldtype === 'Text Editor'
						&& is_null(strip_html(cstr(v))))
						{ errors.push(__(f.df.label)); }

					if (!is_null(v)) { ret[f.df.fieldname] = v; }
				}
			}
			if (errors.length && !ignore_errors) {
				frappe.msgprint({
					title: __('Missing Values Required'),
					message: __('Following fields have missing values:') +
						'<br><br><ul><li>' + errors.join('<li>') + '</ul>',
					indicator: 'orange'
				});
				return null;
			}
			return ret;
		},
		get_value: function(key) {
			var f = this.fields_dict[key];
			return f && (f.get_value ? f.get_value() : null);
		},
		set_value: function(key, val){
			var this$1 = this;

			return new Promise(function (resolve) {
				var f = this$1.fields_dict[key];
				if(f) {
					f.set_value(val).then(function () {
						f.set_input(val);
						this$1.refresh_dependency();
						resolve();
					});
				} else {
					resolve();
				}
			});
		},
		set_input: function(key, val) {
			return this.set_value(key, val);
		},
		set_values: function(dict) {
			var promises = [];
			for(var key in dict) {
				if(this.fields_dict[key]) {
					promises.push(this.set_value(key, dict[key]));
				}
			}

			return Promise.all(promises);
		},
		clear: function() {
			for(var key in this.fields_dict) {
				var f = this.fields_dict[key];
				if(f && f.set_input) {
					f.set_input(f.df['default'] || '');
				}
			}
		},
		set_df_property: function (fieldname, prop, value) {
			var field    = this.get_field(fieldname);
			field.df[prop] = value;
			field.refresh();
		}
	});

	frappe.provide('frappe.ui');

	window.cur_dialog = null;

	frappe.ui.open_dialogs = [];

	frappe.ui.Dialog = class Dialog extends frappe.ui.FieldGroup {
		constructor(opts) {
			super();
			this.display = false;
			this.is_dialog = true;

			$.extend(this, { animate: true, size: null }, opts);
			this.make();
		}

		make() {
			var this$1 = this;

			this.$wrapper = frappe.get_modal("", "");

			if(this.static) {
				this.$wrapper.modal({
					backdrop: 'static',
					keyboard: false
				});
				this.get_close_btn().hide();
			}

			this.wrapper = this.$wrapper.find('.modal-dialog')
				.get(0);
			if ( this.size == "small" )
				{ $(this.wrapper).addClass("modal-sm"); }
			else if ( this.size == "large" )
				{ $(this.wrapper).addClass("modal-lg"); }

			this.make_head();
			this.modal_body = this.$wrapper.find(".modal-body");
			this.$body = $('<div></div>').appendTo(this.modal_body);
			this.body = this.$body.get(0);
			this.$message = $('<div class="hide modal-message"></div>').appendTo(this.modal_body);
			this.header = this.$wrapper.find(".modal-header");
			this.buttons = this.header.find('.buttons');
			this.set_indicator();

			// make fields (if any)
			super.make();

			// show footer
			this.action = this.action || { primary: { }, secondary: { } };
			if(this.primary_action || (this.action.primary && this.action.primary.onsubmit)) {
				this.set_primary_action(this.primary_action_label || this.action.primary.label || __("Submit"),
					this.primary_action || this.action.primary.onsubmit);
			}

			if(this.secondary_action) {
				this.set_secondary_action(this.secondary_action);
			}

			if (this.secondary_action_label || (this.action.secondary && this.action.secondary.label)) {
				this.get_close_btn().html(this.secondary_action_label || this.action.secondary.label);
			}

			if (this.minimizable) {
				this.header.find('.modal-title').click(function () { return this$1.toggle_minimize(); });
				this.get_minimize_btn().removeClass('hide').on('click', function () { return this$1.toggle_minimize(); });
			}

			var me = this;
			this.$wrapper
				.on("hide.bs.modal", function() {
					me.display = false;
					me.secondary_action && me.secondary_action();

					if(frappe.ui.open_dialogs[frappe.ui.open_dialogs.length-1]===me) {
						frappe.ui.open_dialogs.pop();
						if(frappe.ui.open_dialogs.length) {
							window.cur_dialog = frappe.ui.open_dialogs[frappe.ui.open_dialogs.length-1];
						} else {
							window.cur_dialog = null;
						}
					}
					me.onhide && me.onhide();
					me.on_hide && me.on_hide();
				})
				.on("shown.bs.modal", function() {
					// focus on first input
					me.display = true;
					window.cur_dialog = me;
					frappe.ui.open_dialogs.push(me);
					me.focus_on_first_input();
					me.on_page_show && me.on_page_show();
					$(document).trigger('frappe.ui.Dialog:shown');
				})
				.on('scroll', function() {
					var $input = $('input:focus');
					if ($input.length && ['Date', 'Datetime', 'Time'].includes($input.attr('data-fieldtype'))) {
						$input.blur();
					}
				});

		}

		get_primary_btn() {
			return this.$wrapper.find(".modal-header .btn-primary");
		}

		get_minimize_btn() {
			return this.$wrapper.find(".modal-header .btn-modal-minimize");
		}

		set_message(text) {
			this.$message.removeClass('hide');
			this.$body.addClass('hide');
			this.$message.text(text);
		}

		clear_message() {
			this.$message.addClass('hide');
			this.$body.removeClass('hide');
		}

		clear() {
			super.clear();
			this.clear_message();
		}

		set_primary_action(label, click) {
			this.has_primary_action = true;
			var me = this;
			return this.get_primary_btn()
				.removeClass("hide")
				.html(label)
				.click(function() {
					me.primary_action_fulfilled = true;
					// get values and send it
					// as first parameter to click callback
					// if no values then return
					var values = me.get_values();
					if(!values) { return; }
					click && click.apply(me, [values]);
				});
		}

		set_secondary_action(click) {
			this.get_close_btn().on('click', click);
		}

		set_secondary_action_label(label) {
			this.get_close_btn()
				.removeClass("hide")
				.html(label);
		}

		disable_primary_action() {
			this.get_primary_btn().addClass('disabled');
		}
		enable_primary_action() {
			this.get_primary_btn().removeClass('disabled');
		}
		make_head() {
			this.set_title(this.title);
		}
		set_title(t) {
			this.$wrapper.find(".modal-title").html(t);
		}
		set_indicator() {
			if (this.indicator) {
				this.header.find('.indicator').removeClass().addClass('indicator ' + this.indicator);
			}
		}
		show() {
			// show it
			if ( this.animate ) {
				this.$wrapper.addClass('fade');
			} else {
				this.$wrapper.removeClass('fade');
			}
			this.$wrapper.modal("show");

			// clear any message
			this.clear_message();

			this.primary_action_fulfilled = false;
			this.is_visible = true;
			return this;
		}
		hide() {
			this.$wrapper.modal("hide");
			this.is_visible = false;
		}
		get_close_btn() {
			return this.$wrapper.find(".btn-modal-close");
		}
		no_cancel() {
			this.get_close_btn().toggle(false);
		}
		cancel() {
			this.get_close_btn().trigger("click");
		}
		toggle_minimize() {
			var modal = this.$wrapper.closest('.modal').toggleClass('modal-minimize');
			modal.attr('tabindex') ? modal.removeAttr('tabindex') : modal.attr('tabindex', -1);
			this.get_minimize_btn().find('i').toggleClass('octicon-chevron-down').toggleClass('octicon-chevron-up');
			this.is_minimized = !this.is_minimized;
			this.on_minimize_toggle && this.on_minimize_toggle(this.is_minimized);
			this.header.find('.modal-title').toggleClass('cursor-pointer');
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.messages");

	frappe.messages.waiting = function(parent, msg) {
		return $(frappe.messages.get_waiting_message(msg))
			.appendTo(parent);
	};

	frappe.messages.get_waiting_message = function(msg) {
		return repl('<div class="msg-box" style="width: 63%; margin: 30px auto;">\
		<p class="text-center">%(msg)s</p></div>', { msg: msg });
	};

	frappe.throw = function(msg) {
		if(typeof msg==='string') {
			msg = {message: msg, title: __('Error')};
		}
		if(!msg.indicator) { msg.indicator = 'red'; }
		frappe.msgprint(msg);
		throw new Error(msg.message);
	};

	frappe.confirm = function(message, ifyes, ifno) {
		var d = new frappe.ui.Dialog({
			title: __("Confirm"),
			fields: [
				{fieldtype:"HTML", options:("<p class=\"frappe-confirm-message\">" + message + "</p>")}
			],
			primary_action_label: __("Yes"),
			primary_action: function() {
				if(ifyes) { ifyes(); }
				d.hide();
			},
			secondary_action_label: __("No")
		});
		d.show();

		// flag, used to bind "okay" on enter
		d.confirm_dialog = true;

		// no if closed without primary action
		if(ifno) {
			d.onhide = function() {
				if(!d.primary_action_fulfilled) {
					ifno();
				}
			};
		}
		return d;
	};

	frappe.warn = function(title, message_html, proceed_action, primary_label, is_minimizable) {
		var d = new frappe.ui.Dialog({
			title: title,
			indicator: 'red',
			fields: [
				{
					fieldtype: 'HTML',
					fieldname: 'warning_message',
					options: ("<div class=\"frappe-warning-message\">" + message_html + "</div>")
				}
			],
			primary_action_label: primary_label,
			primary_action: function () {
				if (proceed_action) { proceed_action(); }
				d.hide();
			},
			secondary_action_label: __("Cancel"),
			minimizable: is_minimizable
		});

		d.footer = $("<div class=\"modal-footer\"></div>").insertAfter($(d.modal_body));

		d.get_close_btn().appendTo(d.footer);
		d.get_primary_btn().appendTo(d.footer);

		d.footer.find('.btn-primary').removeClass('btn-primary').addClass('btn-danger');

		d.show();
		return d;
	};

	frappe.prompt = function(fields, callback, title, primary_label) {
		if (typeof fields === "string") {
			fields = [{
				label: fields,
				fieldname: "value",
				fieldtype: "Data",
				reqd: 1
			}];
		}
		if(!$.isArray(fields)) { fields = [fields]; }
		var d = new frappe.ui.Dialog({
			fields: fields,
			title: title || __("Enter Value"),
		});
		d.set_primary_action(primary_label || __("Submit"), function() {
			var values = d.get_values();
			if(!values) {
				return;
			}
			d.hide();
			callback(values);
		});
		d.show();
		return d;
	};

	frappe.msgprint = function(msg, title, is_minimizable) {
		if(!msg) { return; }

		if($.isPlainObject(msg)) {
			var data = msg;
		} else {
			// passed as JSON
			if(typeof msg==='string' && msg.substr(0,1)==='{') {
				var data = JSON.parse(msg);
			} else {
				var data = {'message': msg, 'title': title};
			}
		}

		if(!data.indicator) {
			data.indicator = 'blue';
		}

		if(data.message instanceof Array) {
			data.message.forEach(function(m) {
				frappe.msgprint(m);
			});
			return;
		}

		if(data.alert) {
			frappe.show_alert(data);
			return;
		}

		if(!frappe.msg_dialog) {
			frappe.msg_dialog = new frappe.ui.Dialog({
				title: __("Message"),
				onhide: function() {
					if(frappe.msg_dialog.custom_onhide) {
						frappe.msg_dialog.custom_onhide();
					}
					frappe.msg_dialog.msg_area.empty();
				},
				minimizable: data.is_minimizable || is_minimizable
			});

			// class "msgprint" is used in tests
			frappe.msg_dialog.msg_area = $('<div class="msgprint">')
				.appendTo(frappe.msg_dialog.body);

			frappe.msg_dialog.clear = function() {
				frappe.msg_dialog.msg_area.empty();
			};

			frappe.msg_dialog.indicator = frappe.msg_dialog.header.find('.indicator');
		}

		// setup and bind an action to the primary button
		if (data.primary_action) {
			if (data.primary_action.server_action && typeof data.primary_action.server_action === 'string') {
				data.primary_action.action = function () {
					frappe.call({
						method: data.primary_action.server_action,
						args: {
							args: data.primary_action.args
						},
						callback: function callback() {
							if (data.primary_action.hide_on_success) {
								frappe.hide_msgprint();
							}
						}
					});
				};
			}

			if (data.primary_action.client_action && typeof data.primary_action.client_action === 'string') {
				var parts = data.primary_action.client_action.split('.');
				var obj = window;
				for (var i = 0, list = parts; i < list.length; i += 1) {
					var part = list[i];

					obj = obj[part];
				}
				data.primary_action.action = function () {
					if (typeof obj === 'function') {
						obj(data.primary_action.args);
					}
				};
			}

			frappe.msg_dialog.set_primary_action(
				__(data.primary_action.label || "Done"),
				data.primary_action.action
			);
		} else {
			if (frappe.msg_dialog.has_primary_action) {
				frappe.msg_dialog.get_primary_btn().addClass('hide');
				frappe.msg_dialog.has_primary_action = false;
			}
		}

		if (data.secondary_action) {
			frappe.msg_dialog.set_secondary_action(data.secondary_action.action);
			frappe.msg_dialog.set_secondary_action_label(__(data.secondary_action.label || "Close"));
		}

		if(data.message==null) {
			data.message = '';
		}

		if(data.message.search(/<br>|<p>|<li>/)==-1) {
			msg = frappe.utils.replace_newlines(data.message);
		}

		var msg_exists = false;
		if(data.clear) {
			frappe.msg_dialog.msg_area.empty();
		} else {
			msg_exists = frappe.msg_dialog.msg_area.html();
		}

		if(data.title || !msg_exists) {
			// set title only if it is explicitly given
			// and no existing title exists
			frappe.msg_dialog.set_title(data.title || __('Message'));
		}

		// show / hide indicator
		if(data.indicator) {
			frappe.msg_dialog.indicator.removeClass().addClass('indicator ' + data.indicator);
		} else {
			frappe.msg_dialog.indicator.removeClass().addClass('hidden');
		}

		// width
		if (data.wide) {
			// msgprint should be narrower than the usual dialog
			if (frappe.msg_dialog.wrapper.classList.contains('msgprint-dialog')) {
				frappe.msg_dialog.wrapper.classList.remove('msgprint-dialog');
			}
		} else {
			// msgprint should be narrower than the usual dialog
			frappe.msg_dialog.wrapper.classList.add('msgprint-dialog');
		}

		if (data.scroll) {
			// limit modal height and allow scrolling instead
			frappe.msg_dialog.body.classList.add('msgprint-scroll');
		} else {
			if (frappe.msg_dialog.body.classList.contains('msgprint-scroll')) {
				frappe.msg_dialog.body.classList.remove('msgprint-scroll');
			}
		}


		if(msg_exists) {
			frappe.msg_dialog.msg_area.append("<hr>");
		// append a <hr> if another msg already exists
		}

		frappe.msg_dialog.msg_area.append(data.message);

		// make msgprint always appear on top
		frappe.msg_dialog.$wrapper.css("z-index", 2000);
		frappe.msg_dialog.show();

		return frappe.msg_dialog;
	};

	window.msgprint = frappe.msgprint;

	frappe.hide_msgprint = function(instant) {
		// clear msgprint
		if(frappe.msg_dialog && frappe.msg_dialog.msg_area) {
			frappe.msg_dialog.msg_area.empty();
		}
		if(frappe.msg_dialog && frappe.msg_dialog.$wrapper.is(":visible")) {
			if(instant) {
				frappe.msg_dialog.$wrapper.removeClass("fade");
			}
			frappe.msg_dialog.hide();
			if(instant) {
				frappe.msg_dialog.$wrapper.addClass("fade");
			}
		}
	};

	// update html in existing msgprint
	frappe.update_msgprint = function(html) {
		if(!frappe.msg_dialog || (frappe.msg_dialog && !frappe.msg_dialog.$wrapper.is(":visible"))) {
			frappe.msgprint(html);
		} else {
			frappe.msg_dialog.msg_area.html(html);
		}
	};

	frappe.verify_password = function(callback) {
		frappe.prompt({
			fieldname: "password",
			label: __("Enter your password"),
			fieldtype: "Password",
			reqd: 1
		}, function(data) {
			frappe.call({
				method: "frappe.core.doctype.user.user.verify_password",
				args: {
					password: data.password
				},
				callback: function(r) {
					if(!r.exc) {
						callback();
					}
				}
			});
		}, __("Verify Password"), __("Verify"));
	};

	frappe.show_progress = function(title, count, total, description) {
		if ( total === void 0 ) total=100;

		if(frappe.cur_progress && frappe.cur_progress.title === title && frappe.cur_progress.is_visible) {
			var dialog = frappe.cur_progress;
		} else {
			var dialog = new frappe.ui.Dialog({
				title: title,
			});
			dialog.progress = $("<div>\n\t\t\t<div class=\"progress\">\n\t\t\t\t<div class=\"progress-bar\"></div>\n\t\t\t</div>\n\t\t\t<p class=\"description text-muted small\"></p>\n\t\t</div").appendTo(dialog.body);
			dialog.progress_bar = dialog.progress.css({"margin-top": "10px"})
				.find(".progress-bar");
			dialog.$wrapper.removeClass("fade");
			dialog.show();
			frappe.cur_progress = dialog;
		}
		if (description) {
			dialog.progress.find('.description').text(description);
		}
		dialog.percent = cint(flt(count) * 100 / total);
		dialog.progress_bar.css({"width": dialog.percent + "%" });
		return dialog;
	};

	frappe.hide_progress = function() {
		if(frappe.cur_progress) {
			frappe.cur_progress.hide();
			frappe.cur_progress = null;
		}
	};

	// Floating Message
	frappe.show_alert = function(message, seconds, actions) {
		if ( seconds === void 0 ) seconds=7;
		if ( actions === void 0 ) actions={};

		if(typeof message==='string') {
			message = {
				message: message
			};
		}
		if(!$('#dialog-container').length) {
			$('<div id="dialog-container"><div id="alert-container"></div></div>').appendTo('body');
		}

		var body_html;

		if (message.body) {
			body_html = message.body;
		}

		var div = $("\n\t\t<div class=\"alert desk-alert\">\n\t\t\t<div class=\"alert-message small\"></div>\n\t\t\t<div class=\"alert-body\" style=\"display: none\"></div>\n\t\t\t<a class=\"close\">&times;</a>\n\t\t</div>");

		if(message.indicator) {
			div.find('.alert-message').append(("<span class=\"indicator " + (message.indicator) + "\"></span>"));
		}

		div.find('.alert-message').append(message.message);

		if (body_html) {
			div.find('.alert-body').show().html(body_html);
		}

		div.hide().appendTo("#alert-container").show()
			.css('transform', 'translateX(0)');

		div.find('.close, button').click(function() {
			div.remove();
			return false;
		});

		Object.keys(actions).map(function (key) {
			div.find(("[data-action=" + key + "]")).on('click', actions[key]);
		});

		div.delay(seconds * 1000).fadeOut(300);
		return div;
	};

	// Proxy for frappe.show_alert
	Object.defineProperty(window, 'show_alert', {
		get: function() {
			console.warn('Please use `frappe.show_alert` instead of `show_alert`. It will be deprecated soon.');
			return frappe.show_alert;
		}
	});

	frappe.provide('frappe.ui.keys');

	var shortcut_groups = new WeakMap();
	var shortcut_group_list = [];
	frappe.ui.keys.shortcut_groups = shortcut_groups;

	frappe.ui.keys.get_shortcut_group = function (parent) {
		// parent must be an object
		if (!shortcut_groups.has(parent)) {
			shortcut_groups.set(parent, new frappe.ui.keys.AltShortcutGroup());
		}
		return shortcut_groups.get(parent);
	};

	var listener_added = false;
	var $current_dropdown = null;
	var $body = $(document.body);

	frappe.ui.keys.bind_shortcut_group_event = function () {
		if (listener_added) { return; }
		listener_added = true;

		function highlight_alt_shortcuts() {
			if ($current_dropdown) {
				$current_dropdown.addClass('alt-pressed');
				$body.removeClass('alt-pressed');
			} else {
				$body.addClass('alt-pressed');
				$current_dropdown && $current_dropdown.removeClass('alt-pressed');
			}
		}

		function unhighlight_alt_shortcuts() {
			$current_dropdown && $current_dropdown.removeClass('alt-pressed');
			$body.removeClass('alt-pressed');
		}

		$(document).on('keydown', function (e) {
			var key = (frappe.ui.keys.key_map[e.which] || '').toLowerCase();

			if (key === 'alt') {
				highlight_alt_shortcuts();
			}

			if (e.shiftKey || e.ctrlKey || e.metaKey) {
				return;
			}

			if (key && e.altKey) {
				var shortcut = get_shortcut_for_key(key);
				if (shortcut) {
					e.preventDefault();
					shortcut.$target[0].click();
				}
				highlight_alt_shortcuts();
			}
		});
		$(document).on('keyup', function (e) {
			if (e.key === 'Alt') {
				unhighlight_alt_shortcuts();
			}
		});
		$(document).on('mousemove', function () {
			unhighlight_alt_shortcuts();
		});
	};

	function get_shortcut_for_key(key) {
		// Get the shortcut for combination of alt+key
		// Priority 1: Open dropdown
		// Priority 2: Current Page

		var shortcuts = shortcut_group_list
			.filter(function (shortcut_group) { return key in shortcut_group.shortcuts_dict; })
			.map(function (shortcut_group) { return shortcut_group.shortcuts_dict[key]; })
			.filter(function (shortcut) { return shortcut.$target.is(':visible'); });

		var shortcut = null;

		if ($current_dropdown && $current_dropdown.is('.open')) {
			shortcut = shortcuts.find(
				function (shortcut) { return $.contains($current_dropdown[0], shortcut.$target[0]); }
			);
		}

		if (shortcut) { return shortcut; }

		shortcut = shortcuts.find(
			function (shortcut) { return $.contains(window.cur_page.page.page.wrapper[0], shortcut.$target[0]); }
		);

		return shortcut;
	}

	frappe.ui.keys.AltShortcutGroup = class AltShortcutGroup {
		constructor() {
			this.shortcuts_dict = {};
			$current_dropdown = null;
			this.bind_events();
			frappe.ui.keys.bind_shortcut_group_event();
			shortcut_group_list.push(this);
		}

		bind_events() {
			$(document).on('show.bs.dropdown', function (e) {
				$current_dropdown && $current_dropdown.removeClass('alt-pressed');
				var $target = $(e.target);
				if ($target.is('.dropdown, .btn-group')) {
					$current_dropdown = $target;
				}
			});
			$(document).on('hide.bs.dropdown', function () {
				$current_dropdown && $current_dropdown.removeClass('alt-pressed');
				$current_dropdown = null;
			});
		}

		add($target, $text_el) {
			var this$1 = this;

			if (!$text_el) {
				$text_el = $target;
			}
			var text_content = $text_el.text().trim();
			var letters = text_content.split('');
			// first unused letter
			var shortcut_letter = letters.find(function (letter) {
				letter = letter.toLowerCase();
				var is_valid_char = letter >= 'a' && letter <= 'z';
				return !this$1.is_taken(letter) && is_valid_char;
			});
			if (!shortcut_letter) {
				return;
			}
			for (var key in this.shortcuts_dict) {
				var shortcut$1 = this.shortcuts_dict[key];
				if (shortcut$1.text === text_content) {
					shortcut$1.$target = $target;
					shortcut$1.$text_el = $text_el;
					this.underline_text(shortcut$1);
					return;
				}
			}

			var shortcut = {
				$target: $target,
				$text_el: $text_el,
				letter: shortcut_letter,
				text: text_content
			};
			this.shortcuts_dict[shortcut_letter.toLowerCase()] = shortcut;
			this.underline_text(shortcut);
		}

		underline_text(shortcut) {
			shortcut.$text_el.attr('data-label', shortcut.text);
			var underline_el_found = false;
			var text_html = shortcut.text.split('').map(function (letter) {
				if (letter === shortcut.letter && !underline_el_found) {
					letter = "<span class=\"alt-underline\">" + letter + "</span>";
					underline_el_found = true;
				}
				return letter;
			}).join('');
			var original_text_html = shortcut.$text_el.html();
			text_html = original_text_html.replace(shortcut.text.trim(), text_html.trim());
			shortcut.$text_el.html(text_html);
		}

		is_taken(letter) {
			var is_in_global_shortcut = frappe.ui.keys.standard_shortcuts
				.filter(function (s) { return !s.page; })
				.some(function (s) { return s.shortcut === ("alt+" + letter); });
			return letter in this.shortcuts_dict || is_in_global_shortcut;
		}
	};

	frappe.provide('frappe.ui.keys.handlers');

	frappe.ui.keys.setup = function() {
		$(window).on('keydown', function(e) {
			var key = frappe.ui.keys.get_key(e);
			if(frappe.ui.keys.handlers[key]) {
				var out = null;
				for(var i=0, l = frappe.ui.keys.handlers[key].length; i<l; i++) {
					var handler = frappe.ui.keys.handlers[key][i];
					var _out = handler.apply(this, [e]);
					if(_out===false) {
						out = _out;
					}
				}
				return out;
			}
		});
	};

	var standard_shortcuts = [];
	frappe.ui.keys.standard_shortcuts = standard_shortcuts;
	frappe.ui.keys.add_shortcut = function (ref) {
		if ( ref === void 0 ) ref = {};
		var shortcut = ref.shortcut;
		var action = ref.action;
		var description = ref.description;
		var page = ref.page;
		var target = ref.target;
		var condition = ref.condition;
		var ignore_inputs = ref.ignore_inputs; if ( ignore_inputs === void 0 ) ignore_inputs = false;

		if (target instanceof jQuery) {
			var $target = target;
			action = function () {
				$target[0].click();
			};
		}
		if (!condition) {
			condition = function () { return true; };
		}
		var handler = function (e) {
			var $focused_element = $(document.activeElement);
			var is_input_focused = $focused_element.is('input, select, textarea, [contenteditable=true]');
			if (is_input_focused && !ignore_inputs) { return; }
			if (!condition()) { return; }

			if (!page || page.wrapper.is(':visible')) {
				var prevent_default = action(e);
				// prevent default if true is explicitly returned
				// or nothing returned (undefined)
				if (prevent_default || prevent_default === undefined) {
					e.preventDefault();
				}
			}
		};
		// monkey patch page to handler
		handler.page = page;
		// remove handler with the same page attached to it
		frappe.ui.keys.off(shortcut, page);
		// attach new handler
		frappe.ui.keys.on(shortcut, handler);

		// update standard shortcut list
		var existing_shortcut_index = standard_shortcuts.findIndex(
			function (s) { return s.shortcut === shortcut; }
		);
		var new_shortcut = { shortcut: shortcut, action: action, description: description, page: page, condition: condition };
		if (existing_shortcut_index === -1) {
			standard_shortcuts.push(new_shortcut);
		} else {
			standard_shortcuts[existing_shortcut_index] = new_shortcut;
		}
	};

	frappe.ui.keys.show_keyboard_shortcut_dialog = function () {
		if (frappe.ui.keys.is_dialog_shown) { return; }

		var global_shortcuts = standard_shortcuts.filter(function (shortcut) { return !shortcut.page; });
		var current_page_shortcuts = standard_shortcuts.filter(
			function (shortcut) { return shortcut.page && shortcut.page === window.cur_page.page.page; });

		function generate_shortcuts_html(shortcuts, heading) {
			if (!shortcuts.length) {
				return '';
			}
			var html = shortcuts
				.filter(function (s) { return s.condition ? s.condition() : true; })
				.map(function (shortcut) {
					var shortcut_label = shortcut.shortcut
						.split('+')
						.map(frappe.utils.to_title_case)
						.join('+');
					if (frappe.utils.is_mac()) {
						shortcut_label = shortcut_label.replace('Ctrl', '⌘');
					}
					return ("<tr>\n\t\t\t\t\t<td width=\"40%\"><kbd>" + shortcut_label + "</kbd></td>\n\t\t\t\t\t<td width=\"60%\">" + (shortcut.description || '') + "</td>\n\t\t\t\t</tr>");
				}).join('');
			html = "<h5 style=\"margin: 0;\">" + heading + "</h5>\n\t\t\t<table style=\"margin-top: 10px;\" class=\"table table-bordered\">\n\t\t\t\t" + html + "\n\t\t\t</table>";
			return html;
		}

		var global_shortcuts_html = generate_shortcuts_html(global_shortcuts, __('Global Shortcuts'));
		var current_page_shortcuts_html = generate_shortcuts_html(current_page_shortcuts, __('Page Shortcuts'));

		var dialog = new frappe.ui.Dialog({
			title: __('Keyboard Shortcuts'),
			on_hide: function on_hide() {
				frappe.ui.keys.is_dialog_shown = false;
			}
		});

		dialog.$body.append(global_shortcuts_html);
		dialog.$body.append(current_page_shortcuts_html);
		dialog.$body.append(("\n\t\t<div class=\"text-muted\">\n\t\t\t" + (__('Press Alt Key to trigger additional shortcuts in Menu and Sidebar')) + "\n\t\t</div>\n\t"));

		dialog.show();
		frappe.ui.keys.is_dialog_shown = true;
	};

	frappe.ui.keys.get_key = function(e) {
		var keycode = e.keyCode || e.which;
		var key = frappe.ui.keys.key_map[keycode] || String.fromCharCode(keycode);

		if(e.ctrlKey || e.metaKey) {
			// add ctrl+ the key
			key = 'ctrl+' + key;
		}
		if(e.shiftKey) {
			// add ctrl+ the key
			key = 'shift+' + key;
		}
		if (e.altKey) {
			// add alt+ the key
			key = 'alt+' + key;
		}
		if (e.altKey && e.ctrlKey) {
			// add alt+ctrl+ the key or single key e.g f1,f2,etc..
			return key.toLowerCase();
		}
		return key.toLowerCase();
	};

	frappe.ui.keys.on = function(key, handler) {
		if(!frappe.ui.keys.handlers[key]) {
			frappe.ui.keys.handlers[key] = [];
		}
		frappe.ui.keys.handlers[key].push(handler);
	};

	frappe.ui.keys.off = function(key, page) {
		var handlers = frappe.ui.keys.handlers[key];
		if (!handlers || handlers.length === 0) { return; }
		frappe.ui.keys.handlers[key] = handlers.filter(function (h) {
			if (!page) { return false; }
			return h.page !== page;
		});
	};

	frappe.ui.keys.add_shortcut({
		shortcut: 'ctrl+s',
		action: function(e) {
			frappe.app.trigger_primary_action();
			e.preventDefault();
			return false;
		},
		description: __('Trigger Primary Action'),
		ignore_inputs: true
	});

	frappe.ui.keys.add_shortcut({
		shortcut: 'ctrl+g',
		action: function(e) {
			$("#navbar-search").focus();
			e.preventDefault();
			return false;
		},
		description: __('Open Awesomebar')
	});

	frappe.ui.keys.add_shortcut({
		shortcut: 'ctrl+h',
		action: function(e) {
			e.preventDefault();
			$('.navbar-home img').click();
		},
		description: __('Navigate Home')
	});

	frappe.ui.keys.add_shortcut({
		shortcut: 'alt+s',
		action: function(e) {
			e.preventDefault();
			$('.dropdown-navbar-user a').eq(0).click();
		},
		description: __('Open Settings')
	});

	frappe.ui.keys.add_shortcut({
		shortcut: 'shift+/',
		action: function() {
			frappe.ui.keys.show_keyboard_shortcut_dialog();
		},
		description: __('Show Keyboard Shortcuts')
	});

	frappe.ui.keys.add_shortcut({
		shortcut: 'alt+h',
		action: function(e) {
			e.preventDefault();
			$('.dropdown-help a').eq(0).click();
		},
		description: __('Open Help')
	});

	frappe.ui.keys.on('escape', function(e) {
		close_grid_and_dialog();
	});

	frappe.ui.keys.on('esc', function(e) {
		close_grid_and_dialog();
	});

	frappe.ui.keys.on('enter', function(e) {
		if(window.cur_dialog && cur_dialog.confirm_dialog) {
			cur_dialog.get_primary_btn().trigger('click');
		}
	});

	frappe.ui.keys.on('ctrl+down', function(e) {
		var grid_row = frappe.ui.form.get_open_grid_form();
		grid_row && grid_row.toggle_view(false, function() { grid_row.open_next(); });
	});

	frappe.ui.keys.on('ctrl+up', function(e) {
		var grid_row = frappe.ui.form.get_open_grid_form();
		grid_row && grid_row.toggle_view(false, function() { grid_row.open_prev(); });
	});

	frappe.ui.keys.add_shortcut({
		shortcut: 'shift+ctrl+r',
		action: function() {
			frappe.ui.toolbar.clear_cache();
		},
		description: __('Clear Cache and Reload')
	});

	frappe.ui.keys.key_map = {
		8: 'backspace',
		9: 'tab',
		13: 'enter',
		16: 'shift',
		17: 'ctrl',
		91: 'meta',
		18: 'alt',
		27: 'escape',
		37: 'left',
		39: 'right',
		38: 'up',
		40: 'down',
		32: 'space',
		112: 'f1',
		113: 'f2',
		114: 'f3',
		115: 'f4',
		116: 'f5',
		191: '/',
		188: '<',
		190: '>'
	};

	'abcdefghijklmnopqrstuvwxyz'.split('').forEach(function (letter, i) {
		frappe.ui.keys.key_map[65 + i] = letter;
	});

	// keyCode map
	frappe.ui.keyCode = {
		ESCAPE: 27,
		LEFT: 37,
		RIGHT: 39,
		UP: 38,
		DOWN: 40,
		ENTER: 13,
		TAB: 9,
		SPACE: 32,
		BACKSPACE: 8
	};

	function close_grid_and_dialog() {
		// close open grid row
		var open_row = $(".grid-row-open");
		if (open_row.length) {
			var grid_row = open_row.data("grid_row");
			grid_row.toggle_view(false);
			return false;
		}

		// close open dialog
		if (cur_dialog && !cur_dialog.no_cancel_flag) {
			cur_dialog.cancel();
			return false;
		}
	}

	// blur when escape is pressed on dropdowns
	$(document).on('keydown', '.dropdown-toggle', function (e) {
		if (e.which === frappe.ui.keyCode.ESCAPE) {
			$(e.currentTarget).blur();
		}
	});

	// Copyright (c) 2017, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.ui");

	frappe.ui.color_map = {
		red: ["#ffc4c4", "#ff8989", "#ff4d4d", "#a83333"],
		brown: ["#ffe8cd", "#ffd19c", "#ffb868", "#a87945"],
		orange: ["#ffd2c2", "#ffa685", "#ff7846", "#a85b5b"],
		peach: ["#ffd7d7", "#ffb1b1", "#ff8989", "#a84f2e"],
		yellow: ["#fffacd", "#fff168", "#fff69c", "#a89f45"],
		yellowgreen: ["#ebf8cc", "#d9f399", "#c5ec63", "#7b933d"],
		green: ["#cef6d1", "#9deca2", "#6be273", "#428b46"],
		cyan: ["#d2f8ed", "#a4f3dd", "#77ecca", "#49937e"],
		skyblue: ["#d2f1ff", "#a6e4ff", "#78d6ff", "#4f8ea8"],
		blue: ["#d2d2ff", "#a3a3ff", "#7575ff", "#4d4da8"],
		purple: ["#dac7ff", "#b592ff", "#8e58ff", "#5e3aa8"],
		pink: ["#f8d4f8", "#f3aaf0", "#ec7dea", "#934f92"],
		white: ["#d1d8dd", "#fafbfc", "#ffffff", ""],
		black: ["#8D99A6", "#6c7680", "#36414c", "#212a33"]
	};

	frappe.ui.color = {
		get: function(color_name, shade) {
			if(color_name && shade) { return this.get_color_shade(color_name, shade); }
			if(color_name) { return this.get_color_shade(color_name, 'default'); }
			return frappe.ui.color_map;
		},
		get_color: function(color_name) {
			var color_names = Object.keys(frappe.ui.color_map);
			if(color_names.includes(color_name)) {
				return frappe.ui.color_map[color_name];
			} else {
				// eslint-disable-next-line
				console.warn(("'color_name' can be one of " + color_names + " and not " + color_name));
			}
		},
		get_color_shade: function(color_name, shade) {
			var shades = {
				'default': 2,
				'light': 1,
				'extra-light': 0,
				'dark': 3
			};

			if(Object.keys(shades).includes(shade)) {
				return frappe.ui.color_map[color_name][shades[shade]];
			} else {
				// eslint-disable-next-line
				console.warn(("'shade' can be one of " + (Object.keys(shades)) + " and not " + shade));
			}
		},
		all: function() {
			return Object.values(frappe.ui.color_map)
				.reduce(function (acc, curr) { return acc.concat(curr); } , []);
		},
		names: function() {
			return Object.keys(frappe.ui.color_map);
		},
		is_standard: function(color_name) {
			if(!color_name) { return false; }
			if(color_name.startsWith('#')) {
				return this.all().includes(color_name);
			}
			return this.names().includes(color_name);
		},
		get_color_name: function(hex) {
			for (var key in frappe.ui.color_map) {
				var colors = frappe.ui.color_map[key];
				if (colors.includes(hex)) { return key; }
			}
		},
		get_contrast_color: function(hex) {
			if(!this.validate_hex(hex)) {
				return;
			}
			if(!this.is_standard(hex)) {
				var brightness = this.brightness(hex);
				if(brightness < 128) {
					return this.lighten(hex, 0.5);
				}
				return this.lighten(hex, -0.5);
			}

			var color_name = this.get_color_name(hex);
			var colors = this.get_color(color_name);
			var shade_value = colors.indexOf(hex);
			if(shade_value <= 1) {
				return this.get(color_name, 'dark');
			}
			return this.get(color_name, 'extra-light');
		},

		validate_hex: function(hex) {
			// https://stackoverflow.com/a/8027444/5353542
			return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
		},

		lighten: function lighten(color, percent) {
			// https://stackoverflow.com/a/13542669/5353542
			var f = parseInt(color.slice(1), 16),
				t = percent < 0 ? 0 : 255,
				p = percent < 0 ? percent * -1 : percent,
				R = f >> 16,
				G = f >> 8 & 0x00FF,
				B = f & 0x0000FF;
			return "#" +
				(0x1000000 +
					(Math.round((t - R) * p) + R) *
					0x10000 +
					(Math.round((t - G) * p) + G) *
					0x100 + (Math.round((t - B) * p) + B)
				).toString(16).slice(1);
		},

		hex_to_rgb: function hex_to_rgb(hex) {
			if(hex.startsWith('#')) {
				hex = hex.substring(1);
			}
			var r = parseInt(hex.substring(0, 2), 16);
			var g = parseInt(hex.substring(2, 4), 16);
			var b = parseInt(hex.substring(4, 6), 16);
			return {r: r, g: g, b: b};
		},

		brightness: function brightness(hex) {
			var rgb = this.hex_to_rgb(hex);
			// https://www.w3.org/TR/AERT#color-contrast
			// 255 - brightest (#fff)
			// 0 - darkest (#000)
			return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
		}
	};

	frappe.provide('frappe.ui');

	frappe.ui.Sidebar = class Sidebar {
		constructor(ref) {
		var wrapper = ref.wrapper;
		var css_class = ref.css_class;

			this.wrapper = wrapper;
			this.css_class = css_class;
			this.items = {};
			this.make_dom();
		}

		make_dom() {
			this.wrapper.html(("\n\t\t\t<div class=\"" + (this.css_class) + " overlay-sidebar hidden-xs hidden-sm\">\n\t\t\t</div>\n\t\t"));

			this.$sidebar = this.wrapper.find('.' + this.css_class);
		}

		add_item(item, section, h6) {
			if ( h6 === void 0 ) h6=false;

			var $section, $li_item;
			if(!section && this.wrapper.find('.sidebar-menu').length === 0) {
				// if no section, add section with no heading
				$section = this.get_section();
			} else {
				$section = this.get_section(section);
			}

			if(item instanceof jQuery) {
				$li_item = $("<li>");
				item.appendTo($li_item);
			} else {
				var className = h6 ? 'h6' : '';
				var html = "<li class=" + className + ">\n\t\t\t\t<a " + (item.href ? ("href=\"" + (item.href) + "\"") : '') + ">" + (item.label) + "</a>\n\t\t\t</li>";
				$li_item = $(html).click(
					function () { return item.on_click && item.on_click(); }
				);
			}

			$section.append($li_item);

			if(item.name) {
				this.items[item.name] = $li_item;
			}
		}

		remove_item(name) {
			if(this.items[name]) {
				this.items[name].remove();
			}
		}

		get_section(section_heading) {
			if ( section_heading === void 0 ) section_heading="";

			var $section = $(this.wrapper.find(
				("[data-section-heading=\"" + section_heading + "\"]")));
			if($section.length) {
				return $section;
			}

			var $section_heading = section_heading ?
				("<li class=\"h6\">" + section_heading + "</li>") : '';

			$section = $(("\n\t\t\t<ul class=\"list-unstyled sidebar-menu\" data-section-heading=\"" + (section_heading || 'default') + "\">\n\t\t\t\t" + $section_heading + "\n\t\t\t</ul>\n\t\t"));

			this.$sidebar.append($section);
			return $section;
		}
	};

	frappe.ui.LinkPreview = class {

		constructor() {
			this.popovers_list = [];
			this.LINK_CLASSES = 'a[data-doctype], input[data-fieldtype="Link"], .popover';
			this.popover_timeout = null;
			this.setup_events();
		}

		setup_events() {
			var this$1 = this;

			$(document.body).on('mouseover', this.LINK_CLASSES, function (e) {
				this$1.link_hovered = true;
				this$1.element = $(e.currentTarget);
				this$1.is_link = this$1.element.get(0).tagName.toLowerCase() === 'a';

				if (!this$1.element.parents().find('.popover').length) {
					this$1.identify_doc();
					this$1.popover = this$1.element.data("bs.popover");
					if (this$1.name && this$1.doctype) {
						this$1.setup_popover_control(e);
					}
				}
			});
			this.handle_popover_hide();

		}

		identify_doc() {
			if (this.is_link) {
				this.doctype = this.element.attr('data-doctype');
				this.name = this.element.attr('data-name');
				this.href = this.element.attr('href');
			} else {
				this.href = this.element.parents('.control-input-wrapper').find('.control-value a').attr('href');
				// input
				this.doctype = this.element.attr('data-target');
				this.name = this.element.val();
			}
		}

		setup_popover_control(e) {
			var this$1 = this;

			if (!(frappe.boot.link_preview_doctypes || []).includes(this.doctype)) {
				return;
			}
			//If control field value is changed, new popover has to be created
			this.element.on('change', function () {
				this$1.new_popover = true;
			});
			if (!this.popover || this.new_popover) {
				this.data_timeout = setTimeout(function () {
					this$1.create_popover(e);
				}, 100);

			} else {
				this.popover_timeout = setTimeout(function () {
					if (this$1.element.is(':focus')) {
						return;
					}
					this$1.show_popover(e);
				}, 1000);
			}
		}

		create_popover(e) {
			var this$1 = this;

			this.new_popover = false;
			if (this.element.is(':focus')) {
				return;
			}

			this.get_preview_data().then(function (preview_data) {
				if (preview_data) {
					if (this$1.popover_timeout) {
						clearTimeout(this$1.popover_timeout);
					}

					this$1.popover_timeout = setTimeout(function () {
						if (this$1.popover) {
							var new_content = this$1.get_popover_html(preview_data);
							this$1.popover.options.content = new_content;
						} else {
							this$1.init_preview_popover(preview_data);
						}
						this$1.show_popover(e);

					}, 1000);
				}
			});
		}

		show_popover(e) {
			var this$1 = this;

			this.default_timeout = setTimeout(function () {
				this$1.clear_all_popovers();
			}, 10000);

			if (!this.is_link) {
				var left = e.pageX;
				this.element.popover('show');
				var width = $('.popover').width();
				$('.control-field-popover').css('left', (left - (width / 2)) + 'px');
			} else {
				this.element.popover('show');
			}
		}

		handle_popover_hide() {
			var this$1 = this;

			$(document).on('mouseout', this.LINK_CLASSES, function () {
				// To allow popover to be hovered on
				if (!$('.popover:hover').length) {
					this$1.link_hovered = false;
				}
				if (!this$1.link_hovered) {
					if (this$1.data_timeout) {
						clearTimeout(this$1.data_timeout);
					}
					if (this$1.popover_timeout) {
						clearTimeout(this$1.popover_timeout);
					}
					if (this$1.default_timeout) {
						clearTimeout(this$1.default_timeout);
					}
					this$1.clear_all_popovers();
				}
			});

			$(window).on('hashchange', function () {
				this$1.clear_all_popovers();
			});
		}

		clear_all_popovers() {
			this.popovers_list.forEach(function ($el) { return $el.hide(); });
		}

		get_preview_data() {
			return frappe.xcall('frappe.desk.link_preview.get_preview_data', {
				'doctype': this.doctype,
				'docname': this.name,
			});
		}

		init_preview_popover(preview_data) {
			var popover_content = this.get_popover_html(preview_data);
			this.element.popover({
				container: 'body',
				html: true,
				content: popover_content,
				trigger: 'manual',
				placement: 'top auto',
				animation: false,
			});

			var $popover = this.element.data('bs.popover').tip();

			$popover.addClass('link-preview-popover');
			$popover.toggleClass('control-field-popover', this.is_link);

			this.popovers_list.push(this.element.data('bs.popover'));

		}

		get_popover_html(preview_data) {
			if (!this.href) {
				this.href = window.location.href;
			}

			if (this.href && this.href.includes(' ')) {
				this.href = this.href.replace(new RegExp(' ', 'g'), '%20');
			}

			var image_html = '';
			var id_html = '';
			var content_html = '';

			if (preview_data.preview_image) {
				var image_url = encodeURI(preview_data.preview_image);
				image_html = "\n\t\t\t\t<div class=\"preview-header\">\n\t\t\t\t\t<img src=\"" + image_url + "\" onerror=\"this.src='/assets/frappe/images/fallback-thumbnail.jpg'\" class=\"preview-image\"></img>\n\t\t\t\t</div>\n\t\t\t";
			}

			if (preview_data.preview_title != preview_data.name) {
				id_html = "<a class=\"text-muted\" href=" + (this.href) + ">" + (preview_data.name) + "</a>";
			}

			Object.keys(preview_data).forEach(function (key) {
				if (!['preview_image', 'preview_title', 'name'].includes(key)) {
					var value = frappe.ellipsis(preview_data[key], 280);
					var label = key;
					content_html += "\n\t\t\t\t\t<div class=\"preview-field\">\n\t\t\t\t\t\t<div class='small preview-label text-muted bold'>" + label + "</div>\n\t\t\t\t\t\t<div class=\"small preview-value\">" + value + "</div>\n\t\t\t\t\t</div>\n\t\t\t\t";
				}
			});
			content_html = "<div class=\"preview-table\">" + content_html + "</div>";

			var popover_content ="\n\t\t\t<div class=\"preview-popover-header\">" + image_html + "\n\t\t\t\t<div class=\"preview-header\">\n\t\t\t\t\t<div class=\"preview-main\">\n\t\t\t\t\t\t<a class=\"preview-name bold\" href=" + (this.href) + ">" + (preview_data.preview_title) + "</a>\n\t\t\t\t\t\t<span class=\"text-muted small\">" + (this.doctype) + " " + id_html + "</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<hr>\n\t\t\t<div class=\"popover-body\">\n\t\t\t\t" + content_html + "\n\t\t\t</div>\n\t\t";

			return popover_content;
		}

	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// My HTTP Request

	frappe.provide('frappe.request');
	frappe.provide('frappe.request.error_handlers');
	frappe.request.url = '/';
	frappe.request.ajax_count = 0;
	frappe.request.waiting_for_ajax = [];

	frappe.xcall = function(method, params) {
		return new Promise(function (resolve, reject) {
			frappe.call({
				method: method,
				args: params,
				callback: function (r) {
					resolve(r.message);
				},
				error: function (r) {
					reject(r.message);
				}
			});
		});
	};

	// generic server call (call page, object)
	frappe.call = function(opts) {
		if (!frappe.is_online()) {
			frappe.show_alert({
				indicator: 'orange',
				message: __('You are not connected to Internet. Retry after sometime.')
			}, 3);
			opts.always && opts.always();
			return $.ajax();
		}
		if (typeof arguments[0]==='string') {
			opts = {
				method: arguments[0],
				args: arguments[1],
				callback: arguments[2],
				headers: arguments[3]
			};
		}

		if(opts.quiet) {
			opts.no_spinner = true;
		}
		var args = $.extend({}, opts.args);

		// cmd
		if(opts.module && opts.page) {
			args.cmd = opts.module+'.page.'+opts.page+'.'+opts.page+'.'+opts.method;
		} else if(opts.doc) {
			$.extend(args, {
				cmd: "runserverobj",
				docs: frappe.get_doc(opts.doc.doctype, opts.doc.name),
				method: opts.method,
				args: opts.args,
			});
		} else if(opts.method) {
			args.cmd = opts.method;
		}

		var callback = function(data, response_text) {
			if(data.task_id) {
				// async call, subscribe
				frappe.socketio.subscribe(data.task_id, opts);

				if(opts.queued) {
					opts.queued(data);
				}
			}
			else if (opts.callback) {
				// ajax
				return opts.callback(data, response_text);
			}
		};

		var url = opts.url;
		if (!url) {
			url = '/api/method/' + args.cmd;
			if (window.cordova) {
				var host = frappe.request.url;
				host = host.slice(0, host.length - 1);
				url = host + url;
			}
			delete args.cmd;
		}

		return frappe.request.call({
			type: opts.type || "POST",
			args: args,
			success: callback,
			error: opts.error,
			always: opts.always,
			btn: opts.btn,
			freeze: opts.freeze,
			freeze_message: opts.freeze_message,
			headers: opts.headers || {},
			error_handlers: opts.error_handlers || {},
			// show_spinner: !opts.no_spinner,
			async: opts.async,
			silent: opts.silent,
			url: url,
		});
	};


	frappe.request.call = function(opts) {
		frappe.request.prepare(opts);

		var statusCode = {
			200: function(data, xhr) {
				opts.success_callback && opts.success_callback(data, xhr.responseText);
			},
			401: function(xhr) {
				if(frappe.app.session_expired_dialog && frappe.app.session_expired_dialog.display) {
					frappe.app.redirect_to_login();
				} else {
					frappe.app.handle_session_expired();
				}
			},
			404: function(xhr) {
				frappe.msgprint({title:__("Not found"), indicator:'red',
					message: __('The resource you are looking for is not available')});
			},
			403: function(xhr) {
				if (frappe.session.user === 'Guest') {
					// session expired
					frappe.app.handle_session_expired();
				}
				else if(xhr.responseJSON && xhr.responseJSON._error_message) {
					frappe.msgprint({
						title:__("Not permitted"), indicator:'red',
						message: xhr.responseJSON._error_message
					});

					xhr.responseJSON._server_messages = null;
				}
				else if (xhr.responseJSON && xhr.responseJSON._server_messages) {
					var _server_messages = JSON.parse(xhr.responseJSON._server_messages);

					// avoid double messages
					if (_server_messages.indexOf(__("Not permitted"))!==-1) {
						return;
					}
				}
				else {
					frappe.msgprint({
						title:__("Not permitted"), indicator:'red',
						message: __('You do not have enough permissions to access this resource. Please contact your manager to get access.')});
				}


			},
			508: function(xhr) {
				frappe.utils.play_sound("error");
				frappe.msgprint({title:__('Please try again'), indicator:'red',
					message:__("Another transaction is blocking this one. Please try again in a few seconds.")});
			},
			413: function(data, xhr) {
				frappe.msgprint({indicator:'red', title:__('File too big'), message:__("File size exceeded the maximum allowed size of {0} MB",
					[(frappe.boot.max_file_size || 5242880) / 1048576])});
			},
			417: function(xhr) {
				var r = xhr.responseJSON;
				if (!r) {
					try {
						r = JSON.parse(xhr.responseText);
					} catch (e) {
						r = xhr.responseText;
					}
				}

				opts.error_callback && opts.error_callback(r);
			},
			501: function(data, xhr) {
				if(typeof data === "string") { data = JSON.parse(data); }
				opts.error_callback && opts.error_callback(data, xhr.responseText);
			},
			500: function(xhr) {
				frappe.utils.play_sound("error");
				try {
					opts.error_callback && opts.error_callback();
					frappe.request.report_error(xhr, opts);
				} catch (e) {
					frappe.request.report_error(xhr, opts);
				}
			},
			504: function(xhr) {
				frappe.msgprint(__("Request Timed Out"));
				opts.error_callback && opts.error_callback();
			},
			502: function(xhr) {
				frappe.msgprint(__("Internal Server Error"));
			}
		};

		var ajax_args = {
			url: opts.url || frappe.request.url,
			data: opts.args,
			type: opts.type,
			dataType: opts.dataType || 'json',
			async: opts.async,
			headers: Object.assign({
				"X-Frappe-CSRF-Token": frappe.csrf_token,
				"Accept": "application/json",
	 			"X-Frappe-CMD": (opts.args && opts.args.cmd  || '') || ''
			}, opts.headers),
			cache: false
		};

		if (opts.args && opts.args.doctype) {
			ajax_args.headers["X-Frappe-Doctype"] = encodeURIComponent(opts.args.doctype);
		}

		frappe.last_request = ajax_args.data;

		return $.ajax(ajax_args)
			.done(function(data, textStatus, xhr) {
				try {
					if(typeof data === "string") { data = JSON.parse(data); }

					// sync attached docs
					if(data.docs || data.docinfo) {
						frappe.model.sync(data);
					}

					// sync translated messages
					if(data.__messages) {
						$.extend(frappe._messages, data.__messages);
					}

					// callbacks
					var status_code_handler = statusCode[xhr.statusCode().status];
					if (status_code_handler) {
						status_code_handler(data, xhr);
					}
				} catch(e) {
					console.log("Unable to handle success response"); // eslint-disable-line
					console.trace(e); // eslint-disable-line
				}

			})
			.always(function(data, textStatus, xhr) {
				try {
					if(typeof data==="string") {
						data = JSON.parse(data);
					}
					if(data.responseText) {
						var xhr = data;
						data = JSON.parse(data.responseText);
					}
				} catch(e) {
					data = null;
					// pass
				}
				frappe.request.cleanup(opts, data);
				if(opts.always) {
					opts.always(data);
				}
			})
			.fail(function(xhr, textStatus) {
				try {
					var status_code_handler = statusCode[xhr.statusCode().status];
					if (status_code_handler) {
						status_code_handler(xhr);
					} else {
						// if not handled by error handler!
						opts.error_callback && opts.error_callback(xhr);
					}
				} catch(e) {
					console.log("Unable to handle failed response"); // eslint-disable-line
					console.trace(e); // eslint-disable-line
				}
			});
	};

	// call execute serverside request
	frappe.request.prepare = function(opts) {
		$("body").attr("data-ajax-state", "triggered");

		// btn indicator
		if(opts.btn) { $(opts.btn).prop("disabled", true); }

		// freeze page
		if(opts.freeze) { frappe.dom.freeze(opts.freeze_message); }

		// stringify args if required
		for(var key in opts.args) {
			if(opts.args[key] && ($.isPlainObject(opts.args[key]) || $.isArray(opts.args[key]))) {
				opts.args[key] = JSON.stringify(opts.args[key]);
			}
		}

		// no cmd?
		if(!opts.args.cmd && !opts.url) {
			console.log(opts);
			throw "Incomplete Request";
		}

		opts.success_callback = opts.success;
		opts.error_callback = opts.error;
		delete opts.success;
		delete opts.error;

	};

	frappe.request.cleanup = function(opts, r) {
		// stop button indicator
		if(opts.btn) {
			$(opts.btn).prop("disabled", false);
		}

		$("body").attr("data-ajax-state", "complete");

		// un-freeze page
		if(opts.freeze) { frappe.dom.unfreeze(); }

		if(r) {

			// session expired? - Guest has no business here!
			if (r.session_expired || frappe.session.user === "Guest") {
				frappe.app.handle_session_expired();
				return;
			}

			// error handlers
			var global_handlers = frappe.request.error_handlers[r.exc_type] || [];
			var request_handler = opts.error_handlers ? opts.error_handlers[r.exc_type] : null;
			var handlers = [].concat(global_handlers, request_handler).filter(Boolean);

			if (r.exc_type) {
				handlers.forEach(function (handler) {
					handler(r);
				});
			}

			// show messages
			if(r._server_messages && !opts.silent) {
				// show server messages if no handlers exist
				if (handlers.length === 0) {
					r._server_messages = JSON.parse(r._server_messages);
					frappe.hide_msgprint();
					frappe.msgprint(r._server_messages);
				}
			}

			// show errors
			if(r.exc) {
				r.exc = JSON.parse(r.exc);
				if(r.exc instanceof Array) {
					$.each(r.exc, function(i, v) {
						if(v) {
							console.log(v);
						}
					});
				} else {
					console.log(r.exc);
				}
			}

			// debug messages
			if(r._debug_messages) {
				if(opts.args) {
					console.log("======== arguments ========");
					console.log(opts.args);
					console.log("========");
				}
				$.each(JSON.parse(r._debug_messages), function(i, v) { console.log(v); });
				console.log("======== response ========");
				delete r._debug_messages;
				console.log(r);
				console.log("========");
			}
		}

		frappe.last_response = r;
	};

	frappe.after_server_call = function () {
		if(frappe.request.ajax_count) {
			return new Promise(function (resolve) {
				frappe.request.waiting_for_ajax.push(function () {
					resolve();
				});
			});
		} else {
			return null;
		}
	};

	frappe.after_ajax = function(fn) {
		return new Promise(function (resolve) {
			if(frappe.request.ajax_count) {
				frappe.request.waiting_for_ajax.push(function () {
					if(fn) { return resolve(fn()); }
					resolve();
				});
			} else {
				if(fn) { return resolve(fn()); }
				resolve();
			}
		});
	};

	frappe.request.report_error = function(xhr, request_opts) {
		var data = JSON.parse(xhr.responseText);
		var exc;
		if (data.exc) {
			try {
				exc = (JSON.parse(data.exc) || []).join("\n");
			} catch (e) {
				exc = data.exc;
			}
			delete data.exc;
		} else {
			exc = "";
		}

		var show_communication = function() {
			var error_report_message = [
				'<h5>Please type some additional information that could help us reproduce this issue:</h5>',
				'<div style="min-height: 100px; border: 1px solid #bbb; \
				border-radius: 5px; padding: 15px; margin-bottom: 15px;"></div>',
				'<hr>',
				'<h5>App Versions</h5>',
				'<pre>' + JSON.stringify(frappe.boot.versions, null, "\t") + '</pre>',
				'<h5>Route</h5>',
				'<pre>' + frappe.get_route_str() + '</pre>',
				'<hr>',
				'<h5>Error Report</h5>',
				'<pre>' + exc + '</pre>',
				'<hr>',
				'<h5>Request Data</h5>',
				'<pre>' + JSON.stringify(request_opts, null, "\t") + '</pre>',
				'<hr>',
				'<h5>Response JSON</h5>',
				'<pre>' + JSON.stringify(data, null, '\t')+ '</pre>'
			].join("\n");

			var communication_composer = new frappe.views.CommunicationComposer({
				subject: 'Error Report [' + frappe.datetime.nowdate() + ']',
				recipients: error_report_email,
				message: frappe.utils.xss_sanitise(error_report_message),
				doc: {
					doctype: "User",
					name: frappe.session.user
				}
			});
			communication_composer.dialog.$wrapper.css("z-index", cint(frappe.msg_dialog.$wrapper.css("z-index")) + 1);
		};

		if (exc) {
			var error_report_email = frappe.boot.error_report_email;

			request_opts = frappe.request.cleanup_request_opts(request_opts);

			// window.msg_dialog = frappe.msgprint({message:error_message, indicator:'red', big: true});

			if (!frappe.error_dialog) {
				frappe.error_dialog = new frappe.ui.Dialog({
					title: 'Server Error',
					primary_action_label: __('Report'),
					primary_action: function () {
						if (error_report_email) {
							show_communication();
						} else {
							frappe.msgprint(__('Support Email Address Not Specified'));
						}
						frappe.error_dialog.hide();
					}
				});
				frappe.error_dialog.wrapper.classList.add('msgprint-dialog');

			}

			var parts = strip(exc).split('\n');

			frappe.error_dialog.$body.html(parts[parts.length - 1]);
			frappe.error_dialog.show();

		}
	};

	frappe.request.cleanup_request_opts = function(request_opts) {
		var doc = (request_opts.args || {}).doc;
		if (doc) {
			doc = JSON.parse(doc);
			$.each(Object.keys(doc), function(i, key) {
				if (key.indexOf("password")!==-1 && doc[key]) {
					// mask the password
					doc[key] = "*****";
				}
			});
			request_opts.args.doc = JSON.stringify(doc);
		}
		return request_opts;
	};

	frappe.request.on_error = function(error_type, handler) {
		frappe.request.error_handlers[error_type] = frappe.request.error_handlers[error_type] || [];
		frappe.request.error_handlers[error_type].push(handler);
	};

	$(document).ajaxSend(function() {
		frappe.request.ajax_count++;
	});

	$(document).ajaxComplete(function() {
		frappe.request.ajax_count--;
		if(!frappe.request.ajax_count) {
			$.each(frappe.request.waiting_for_ajax || [], function(i, fn) {
				fn();
			});
			frappe.request.waiting_for_ajax = [];
		}
	});

	frappe.socketio = {
		open_tasks: {},
		open_docs: [],
		emit_queue: [],
		init: function(port) {
			if ( port === void 0 ) port = 3000;

			if (!window.io) {
				return;
			}

			if (frappe.boot.disable_async) {
				return;
			}

			if (frappe.socketio.socket) {
				return;
			}

			//Enable secure option when using HTTPS
			if (window.location.protocol == "https:") {
				frappe.socketio.socket = io.connect(frappe.socketio.get_host(port), {secure: true});
			}
			else if (window.location.protocol == "http:") {
				frappe.socketio.socket = io.connect(frappe.socketio.get_host(port));
			}
			else if (window.location.protocol == "file:") {
				frappe.socketio.socket = io.connect(window.localStorage.server);
			}

			if (!frappe.socketio.socket) {
				console.log("Unable to connect to " + frappe.socketio.get_host(port));
				return;
			}

			frappe.socketio.socket.on('msgprint', function(message) {
				frappe.msgprint(message);
			});

			frappe.socketio.socket.on('eval_js', function(message) {
				eval(message);
			});

			frappe.socketio.socket.on('progress', function(data) {
				if(data.progress) {
					data.percent = flt(data.progress[0]) / data.progress[1] * 100;
				}
				if(data.percent) {
					if(data.percent==100) {
						frappe.hide_progress();
					} else {
						frappe.show_progress(data.title || __("Progress"), data.percent, 100, data.description);
					}
				}
			});

			frappe.socketio.setup_listeners();
			frappe.socketio.setup_reconnect();
			frappe.socketio.uploader = new frappe.socketio.SocketIOUploader();

			$(document).on('form-load form-rename', function(e, frm) {
				if (frm.is_new()) {
					return;
				}

				for (var i=0, l=frappe.socketio.open_docs.length; i<l; i++) {
					var d = frappe.socketio.open_docs[i];
					if (frm.doctype==d.doctype && frm.docname==d.name) {
						// already subscribed
						return false;
					}
				}

				frappe.socketio.doc_subscribe(frm.doctype, frm.docname);
			});

			$(document).on("form-refresh", function(e, frm) {
				if (frm.is_new()) {
					return;
				}

				frappe.socketio.doc_open(frm.doctype, frm.docname);
			});

			$(document).on('form-unload', function(e, frm) {
				if (frm.is_new()) {
					return;
				}

				// frappe.socketio.doc_unsubscribe(frm.doctype, frm.docname);
				frappe.socketio.doc_close(frm.doctype, frm.docname);
			});

			$(document).on('form-typing', function(e, frm) {
				frappe.socketio.form_typing(frm.doctype, frm.docname);
			});

			$(document).on('form-stopped-typing', function(e, frm) {
				frappe.socketio.form_stopped_typing(frm.doctype, frm.docname);
			});

			window.onbeforeunload = function() {
				if (!cur_frm || cur_frm.is_new()) {
					return;
				}

				// if tab/window is closed, notify other users
				if (cur_frm.doc) {
					frappe.socketio.doc_close(cur_frm.doctype, cur_frm.docname);
				}
			};
		},
		get_host: function(port) {
			if ( port === void 0 ) port = 3000;

			var host = window.location.origin;
			if(window.dev_server) {
				var parts = host.split(":");
				port = frappe.boot.socketio_port || port.toString() || '3000';
				if(parts.length > 2) {
					host = parts[0] + ":" + parts[1];
				}
				host = host + ":" + port;
			}
			return host;
		},
		subscribe: function(task_id, opts) {
			// TODO DEPRECATE

			frappe.socketio.socket.emit('task_subscribe', task_id);
			frappe.socketio.socket.emit('progress_subscribe', task_id);

			frappe.socketio.open_tasks[task_id] = opts;
		},
		task_subscribe: function(task_id) {
			frappe.socketio.socket.emit('task_subscribe', task_id);
		},
		task_unsubscribe: function(task_id) {
			frappe.socketio.socket.emit('task_unsubscribe', task_id);
		},
		doc_subscribe: function(doctype, docname) {
			if (frappe.flags.doc_subscribe) {
				console.log('throttled');
				return;
			}

			frappe.flags.doc_subscribe = true;

			// throttle to 1 per sec
			setTimeout(function() { frappe.flags.doc_subscribe = false; }, 1000);

			frappe.socketio.socket.emit('doc_subscribe', doctype, docname);
			frappe.socketio.open_docs.push({doctype: doctype, docname: docname});
		},
		doc_unsubscribe: function(doctype, docname) {
			frappe.socketio.socket.emit('doc_unsubscribe', doctype, docname);
			frappe.socketio.open_docs = $.filter(frappe.socketio.open_docs, function(d) {
				if(d.doctype===doctype && d.name===docname) {
					return null;
				} else {
					return d;
				}
			});
		},
		doc_open: function(doctype, docname) {
			// notify that the user has opened this doc, if not already notified
			if(!frappe.socketio.last_doc
				|| (frappe.socketio.last_doc[0]!=doctype && frappe.socketio.last_doc[1]!=docname)) {
				frappe.socketio.socket.emit('doc_open', doctype, docname);
			}
			frappe.socketio.last_doc = [doctype, docname];
		},
		doc_close: function(doctype, docname) {
			// notify that the user has closed this doc
			frappe.socketio.socket.emit('doc_close', doctype, docname);

			// if the doc is closed the user has also stopped typing
			frappe.socketio.socket.emit('doc_typing_stopped', doctype, docname);
		},
		form_typing: function(doctype, docname) {
			// notifiy that the user is typing on the doc
			frappe.socketio.socket.emit('doc_typing', doctype, docname);
		},
		form_stopped_typing: function(doctype, docname) {
			// notifiy that the user has stopped typing
			frappe.socketio.socket.emit('doc_typing_stopped', doctype, docname);
		},
		setup_listeners: function() {
			frappe.socketio.socket.on('task_status_change', function(data) {
				frappe.socketio.process_response(data, data.status.toLowerCase());
			});
			frappe.socketio.socket.on('task_progress', function(data) {
				frappe.socketio.process_response(data, "progress");
			});
		},
		setup_reconnect: function() {
			// subscribe again to open_tasks
			frappe.socketio.socket.on("connect", function() {
				// wait for 5 seconds before subscribing again
				// because it takes more time to start python server than nodejs server
				// and we use validation requests to python server for subscribing
				setTimeout(function() {
					$.each(frappe.socketio.open_tasks, function(task_id, opts) {
						frappe.socketio.subscribe(task_id, opts);
					});

					// re-connect open docs
					$.each(frappe.socketio.open_docs, function(d) {
						if(locals[d.doctype] && locals[d.doctype][d.name]) {
							frappe.socketio.doc_subscribe(d.doctype, d.name);
						}
					});

					if (cur_frm && cur_frm.doc) {
						frappe.socketio.doc_open(cur_frm.doc.doctype, cur_frm.doc.name);
					}
				}, 5000);
			});
		},
		process_response: function(data, method) {
			if(!data) {
				return;
			}

			// success
			var opts = frappe.socketio.open_tasks[data.task_id];
			if(opts[method]) {
				opts[method](data);
			}

			// "callback" is std frappe term
			if(method==="success") {
				if(opts.callback) { opts.callback(data); }
			}

			// always
			frappe.request.cleanup(opts, data);
			if(opts.always) {
				opts.always(data);
			}

			// error
			if(data.status_code && data.status_code > 400 && opts.error) {
				opts.error(data);
			}
		}
	};

	frappe.provide("frappe.realtime");
	frappe.realtime.on = function(event, callback) {
		frappe.socketio.socket && frappe.socketio.socket.on(event, callback);
	};

	frappe.realtime.off = function(event, callback) {
		frappe.socketio.socket && frappe.socketio.socket.off(event, callback);
	};

	frappe.realtime.publish = function(event, message) {
		if(frappe.socketio.socket) {
			frappe.socketio.socket.emit(event, message);
		}
	};

	frappe.socketio.SocketIOUploader = class SocketIOUploader {
		constructor() {
		var this$1 = this;

			frappe.socketio.socket.on('upload-request-slice', function (data) {
				var place = data.currentSlice * this$1.chunk_size,
					slice = this$1.file.slice(place,
						place + Math.min(this$1.chunk_size, this$1.file.size - place));

				if (this$1.on_progress) {
					// update progress
					this$1.on_progress(place / this$1.file.size * 100);
				}

				this$1.reader.readAsArrayBuffer(slice);
				this$1.started = true;
				this$1.keep_alive();
			});

			frappe.socketio.socket.on('upload-end', function (data) {
				this$1.reader = null;
				this$1.file = null;
				if (data.file_url.substr(0, 7)==='/public') {
					data.file_url = data.file_url.substr(7);
				}
				this$1.callback(data);
			});

			frappe.socketio.socket.on('upload-error', function (data) {
				this$1.disconnect(false);
				frappe.msgprint({
					title: __('Upload Failed'),
					message: data.error,
					indicator: 'red'
				});
			});

			frappe.socketio.socket.on('disconnect', function () {
				this$1.disconnect();
			});
		}

		start(ref) {
			var this$1 = this;
			if ( ref === void 0 ) ref = {};
			var file = ref.file; if ( file === void 0 ) file = null;
			var is_private = ref.is_private; if ( is_private === void 0 ) is_private = 0;
			var filename = ref.filename; if ( filename === void 0 ) filename = '';
			var callback = ref.callback; if ( callback === void 0 ) callback = null;
			var on_progress = ref.on_progress; if ( on_progress === void 0 ) on_progress = null;
			var chunk_size = ref.chunk_size; if ( chunk_size === void 0 ) chunk_size = 24576;
			var fallback = ref.fallback; if ( fallback === void 0 ) fallback = null;


			if (this.reader) {
				frappe.throw(__('File Upload in Progress. Please try again in a few moments.'));
			}

			function fallback_required() {
				return !frappe.socketio.socket.connected
					|| !( !frappe.boot.sysdefaults || frappe.boot.sysdefaults.use_socketio_to_upload_file );
			}

			if (fallback_required()) {
				return fallback ? fallback() : frappe.throw(__('Socketio is not connected. Cannot upload'));
			}

			this.reader = new FileReader();
			this.file = file;
			this.chunk_size = chunk_size;
			this.callback = callback;
			this.on_progress = on_progress;
			this.fallback = fallback;
			this.started = false;

			this.reader.onload = function () {
				frappe.socketio.socket.emit('upload-accept-slice', {
					is_private: is_private,
					name: filename,
					type: this$1.file.type,
					size: this$1.file.size,
					data: this$1.reader.result
				});
				this$1.keep_alive();
			};

			var slice = file.slice(0, this.chunk_size);
			this.reader.readAsArrayBuffer(slice);
		}

		keep_alive() {
			var this$1 = this;

			if (this.next_check) {
				clearTimeout (this.next_check);
			}
			this.next_check = setTimeout (function () {
				if (!this$1.started) {
					// upload never started, so try fallback
					if (this$1.fallback) {
						this$1.fallback();
					} else {
						this$1.disconnect();
					}
				}
				this$1.disconnect();
			}, 3000);
		}

		disconnect(with_message) {
			if ( with_message === void 0 ) with_message = true;

			if (this.reader) {
				this.reader = null;
				this.file = null;
				frappe.hide_progress();
				if (with_message) {
					frappe.msgprint({
						title: __('File Upload'),
						message: __('File Upload Disconnected. Please try again.'),
						indicator: 'red'
					});
				}
			}
		}
	};

	var isArray = Array.isArray;
	var keyList = Object.keys;
	var hasProp = Object.prototype.hasOwnProperty;

	var fastDeepEqual = function equal(a, b) {
	  if (a === b) { return true; }

	  if (a && b && typeof a == 'object' && typeof b == 'object') {
	    var arrA = isArray(a)
	      , arrB = isArray(b)
	      , i
	      , length
	      , key;

	    if (arrA && arrB) {
	      length = a.length;
	      if (length != b.length) { return false; }
	      for (i = length; i-- !== 0;)
	        { if (!equal(a[i], b[i])) { return false; } }
	      return true;
	    }

	    if (arrA != arrB) { return false; }

	    var dateA = a instanceof Date
	      , dateB = b instanceof Date;
	    if (dateA != dateB) { return false; }
	    if (dateA && dateB) { return a.getTime() == b.getTime(); }

	    var regexpA = a instanceof RegExp
	      , regexpB = b instanceof RegExp;
	    if (regexpA != regexpB) { return false; }
	    if (regexpA && regexpB) { return a.toString() == b.toString(); }

	    var keys = keyList(a);
	    length = keys.length;

	    if (length !== keyList(b).length)
	      { return false; }

	    for (i = length; i-- !== 0;)
	      { if (!hasProp.call(b, keys[i])) { return false; } }

	    for (i = length; i-- !== 0;) {
	      key = keys[i];
	      if (!equal(a[key], b[key])) { return false; }
	    }

	    return true;
	  }

	  return a!==a && b!==b;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	frappe.provide('frappe.utils');

	Object.assign(frappe.utils, {
		get_random: function(len) {
			var text = "";
			var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

			for( var i=0; i < len; i++ )
				{ text += possible.charAt(Math.floor(Math.random() * possible.length)); }

			return text;
		},
		get_file_link: function(filename) {
			filename = cstr(filename);
			if(frappe.utils.is_url(filename)) {
				return filename;
			} else if(filename.indexOf("/")===-1) {
				return "files/" + filename;
			} else {
				return filename;
			}
		},
		replace_newlines: function replace_newlines(t) {
			return t?t.replace(/\n/g, '<br>'):'';
		},
		is_html: function(txt) {
			if (!txt) { return false; }

			if(txt.indexOf("<br>")==-1 && txt.indexOf("<p")==-1
				&& txt.indexOf("<img")==-1 && txt.indexOf("<div")==-1 && !txt.includes('<span')) {
				return false;
			}
			return true;
		},
		is_mac: function() {
			return window.navigator.platform === 'MacIntel';
		},
		is_xs: function() {
			return $(document).width() < 768;
		},
		is_sm: function() {
			return $(document).width() < 991 && $(document).width() >= 768;
		},
		is_md: function() {
			return $(document).width() < 1199 && $(document).width() >= 991;
		},
		is_json: function(str) {
			try {
				JSON.parse(str);
			} catch (e) {
				return false;
			}
			return true;
		},
		strip_whitespace: function(html) {
			return (html || "").replace(/<p>\s*<\/p>/g, "").replace(/<br>(\s*<br>\s*)+/g, "<br><br>");
		},
		encode_tags: function(html) {
			var tagsToReplace = {
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;'
			};

			function replaceTag(tag) {
				return tagsToReplace[tag] || tag;
			}

			return html.replace(/[&<>]/g, replaceTag);
		},
		strip_original_content: function(txt) {
			var out = [],
				part = [],
				newline = txt.indexOf("<br>")===-1 ? "\n" : "<br>";

			$.each(txt.split(newline), function(i, t) {
				var tt = strip(t);
				if(tt && (tt.substr(0,1)===">" || tt.substr(0,4)==="&gt;")) {
					part.push(t);
				} else {
					out.push(t);
					part = [];
				}
			});
			return out.join(newline);
		},
		escape_html: function(txt) {
			return $("<div></div>").text(txt || "").html();
		},

		html2text: function(html) {
			var d = document.createElement('div');
			d.innerHTML = html;
			return d.textContent;
		},

		is_url: function(txt) {
			return txt.toLowerCase().substr(0,7)=='http://'
				|| txt.toLowerCase().substr(0,8)=='https://'
		},
		to_title_case: function(string, with_space) {
			if ( with_space === void 0 ) with_space=false;

			var titlecased_string = string.toLowerCase().replace(/(?:^|[\s-/])\w/g, function(match) {
				return match.toUpperCase();
			});

			var replace_with = with_space ? ' ' : '';

			return titlecased_string.replace(/-|_/g, replace_with);
		},
		toggle_blockquote: function(txt) {
			if (!txt) { return txt; }

			var content = $("<div></div>").html(txt);
			content.find("blockquote").parent("blockquote").addClass("hidden")
				.before('<p><a class="text-muted btn btn-default toggle-blockquote" style="padding: 2px 7px 0px; line-height: 1;"> \
					• • • \
				</a></p>');
			return content.html();
		},
		scroll_to: function(element, animate, additional_offset, element_to_be_scrolled) {
			element_to_be_scrolled = element_to_be_scrolled || $("html, body");

			var y = 0;
			if (element && typeof element==="number") {
				y = element;
			} else if(element) {
				var header_offset = $(".navbar").height() + $(".page-head").height();
				var y = $(element).offset().top - header_offset - cint(additional_offset);
			}

			if(y < 0) {
				y = 0;
			}

			// already there
			if (y == element_to_be_scrolled.scrollTop()) {
				return;
			}

			if (animate !== false) {
				element_to_be_scrolled.animate({ scrollTop: y });
			} else {
				element_to_be_scrolled.scrollTop(y);
			}

		},
		filter_dict: function(dict, filters) {
			var ret = [];
			if(typeof filters=='string') {
				return [dict[filters]]
			}
			$.each(dict, function(i, d) {
				for(var key in filters) {
					if($.isArray(filters[key])) {
						if(filters[key][0]=="in") {
							if(filters[key][1].indexOf(d[key])==-1)
								{ return; }
						} else if(filters[key][0]=="not in") {
							if(filters[key][1].indexOf(d[key])!=-1)
								{ return; }
						} else if(filters[key][0]=="<") {
							if (!(d[key] < filters[key])) { return; }
						} else if(filters[key][0]=="<=") {
							if (!(d[key] <= filters[key])) { return; }
						} else if(filters[key][0]==">") {
							if (!(d[key] > filters[key])) { return; }
						} else if(filters[key][0]==">=") {
							if (!(d[key] >= filters[key])) { return; }
						}
					} else {
						if(d[key]!=filters[key]) { return; }
					}
				}
				ret.push(d);
			});
			return ret;
		},
		comma_or: function(list) {
			return frappe.utils.comma_sep(list, " " + __("or") + " ");
		},
		comma_and: function(list) {
			return frappe.utils.comma_sep(list, " " + __("and") + " ");
		},
		comma_sep: function(list, sep) {
			if(list instanceof Array) {
				if(list.length==0) {
					return "";
				} else if (list.length==1) {
					return list[0];
				} else {
					return list.slice(0, list.length-1).join(", ") + sep + list.slice(-1)[0];
				}
			} else {
				return list;
			}
		},
		set_footnote: function(footnote_area, wrapper, txt) {
			if(!footnote_area) {
				footnote_area = $('<div class="text-muted footnote-area level">')
					.appendTo(wrapper);
			}

			if(txt) {
				footnote_area.html(txt);
			} else {
				footnote_area.remove();
				footnote_area = null;
			}
			return footnote_area;
		},
		get_args_dict_from_url: function(txt) {
			var args = {};
			$.each(decodeURIComponent(txt).split("&"), function(i, arg) {
				arg = arg.split("=");
				args[arg[0]] = arg[1];
			});
			return args;
		},
		get_url_from_dict: function(args) {
			return $.map(args, function(val, key) {
				if(val!==null)
					{ return encodeURIComponent(key)+"="+encodeURIComponent(val); }
				else
					{ return null; }
			}).join("&") || "";
		},
		validate_type: function ( val, type ) {
			// from https://github.com/guillaumepotier/Parsley.js/blob/master/parsley.js#L81
			var regExp;

			switch ( type ) {
				case "phone":
					regExp = /^([0-9\ \+\_\-\,\.\*\#\(\)]){1,20}$/;
					break;
				case "name":
					regExp = /^[\w][\w'-]*([ \w][\w'-]+)*$/;
					break;
				case "number":
					regExp = /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/;
					break;
				case "digits":
					regExp = /^\d+$/;
					break;
				case "alphanum":
					regExp = /^\w+$/;
					break;
				case "email":
					// from https://emailregex.com/
					regExp = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
					break;
				case "url":
					regExp = /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
					break;
				case "dateIso":
					regExp = /^(\d{4})\D?(0[1-9]|1[0-2])\D?([12]\d|0[1-9]|3[01])$/;
					break;
				default:
					return false;
			}

			// test regExp if not null
			return '' !== val ? regExp.test( val ) : false;
		},
		guess_style: function(text, default_style, _colour) {
			var style = default_style || "default";
			var colour = "darkgrey";
			if(text) {
				if(has_words(["Pending", "Review", "Medium", "Not Approved"], text)) {
					style = "warning";
					colour = "orange";
				} else if(has_words(["Open", "Urgent", "High", "Failed", "Rejected", "Error"], text)) {
					style = "danger";
					colour = "red";
				} else if(has_words(["Closed", "Finished", "Converted", "Completed", "Complete", "Confirmed",
					"Approved", "Yes", "Active", "Available", "Paid", "Success"], text)) {
					style = "success";
					colour = "green";
				} else if(has_words(["Submitted"], text)) {
					style = "info";
					colour = "blue";
				}
			}
			return _colour ? colour : style;
		},

		guess_colour: function(text) {
			return frappe.utils.guess_style(text, null, true);
		},

		get_indicator_color: function(state) {
			return frappe.db.get_list('Workflow State', {filters: {name: state}, fields: ['name', 'style']}).then(function (res) {
				var state = res[0];
				if (!state.style) {
					return frappe.utils.guess_colour(state.name);
				}
				var style = state.style;
				var colour_map = {
					"Success": "green",
					"Warning": "orange",
					"Danger": "red",
					"Primary": "blue",
				};

				return colour_map[style];
			});

		},

		sort: function(list, key, compare_type, reverse) {
			if(!list || list.length < 2)
				{ return list || []; }

			var sort_fn = {
				"string": function(a, b) {
					return cstr(a[key]).localeCompare(cstr(b[key]));
				},
				"number": function(a, b) {
					return flt(a[key]) - flt(b[key]);
				}
			};

			if(!compare_type)
				{ compare_type = typeof list[0][key]==="string" ? "string" : "number"; }

			list.sort(sort_fn[compare_type]);

			if(reverse) { list.reverse(); }

			return list;
		},

		unique: function(list) {
			var dict = {},
				arr = [];
			for(var i=0, l=list.length; i < l; i++) {
				if(!dict.hasOwnProperty(list[i])) {
					dict[list[i]] = null;
					arr.push(list[i]);
				}
			}
			return arr;
		},

		remove_nulls: function(list) {
			var new_list = [];
			for (var i=0, l=list.length; i < l; i++) {
				if (!is_null(list[i])) {
					new_list.push(list[i]);
				}
			}
			return new_list;
		},

		all: function(lst) {
			for(var i=0, l=lst.length; i<l; i++) {
				if(!lst[i]) {
					return false;
				}
			}
			return true;
		},

		dict: function(keys,values) {
			// make dictionaries from keys and values
			var out = [];
			$.each(values, function(row_idx, row) {
				var new_row = {};
				$.each(keys, function(key_idx, key) {
					new_row[key] = row[key_idx];
				});
				out.push(new_row);
			});
			return out;
		},

		sum: function(list) {
			return list.reduce(function(previous_value, current_value) { return flt(previous_value) + flt(current_value); }, 0.0);
		},

		arrays_equal: function(arr1, arr2) {
			if (!arr1 || !arr2) {
				return false;
			}
			if (arr1.length != arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if ($.isArray(arr1[i])) {
					if (!frappe.utils.arrays_equal(arr1[i], arr2[i])) {
						return false;
					}
				}
				else if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		},

		intersection: function(a, b) {
			// from stackoverflow: http://stackoverflow.com/questions/1885557/simplest-code-for-array-intersection-in-javascript
			/* finds the intersection of
			 * two arrays in a simple fashion.
			 *
			 * PARAMS
			 *  a - first array, must already be sorted
			 *  b - second array, must already be sorted
			 *
			 * NOTES
			 *
			 *  Should have O(n) operations, where n is
			 *    n = MIN(a.length(), b.length())
			 */
			var ai=0, bi=0;
			var result = new Array();

			// sorted copies
			a = ([].concat(a)).sort();
			b = ([].concat(b)).sort();

			while( ai < a.length && bi < b.length ) {
				if (a[ai] < b[bi] ) { ai++; }
				else if (a[ai] > b[bi] ) { bi++; }
				else {
					/* they're equal */
					result.push(a[ai]);
					ai++;
					bi++;
				}
			}

			return result;
		},

		resize_image: function(reader, callback, max_width, max_height) {
			var tempImg = new Image();
			if(!max_width) { max_width = 600; }
			if(!max_height) { max_height = 400; }
			tempImg.src = reader.result;

			tempImg.onload = function() {
				var tempW = tempImg.width;
				var tempH = tempImg.height;
				if (tempW > tempH) {
					if (tempW > max_width) {
						tempH *= max_width / tempW;
						tempW = max_width;
					}
				} else {
					if (tempH > max_height) {
						tempW *= max_height / tempH;
						tempH = max_height;
					}
				}

				var canvas = document.createElement('canvas');
				canvas.width = tempW;
				canvas.height = tempH;
				var ctx = canvas.getContext("2d");
				ctx.drawImage(this, 0, 0, tempW, tempH);
				var dataURL = canvas.toDataURL("image/jpeg");
				setTimeout(function() { callback(dataURL); }, 10 );
			};
		},

		csv_to_array: function (strData, strDelimiter) {
			// Check to see if the delimiter is defined. If not,
			// then default to comma.
			strDelimiter = (strDelimiter || ",");

			// Create a regular expression to parse the CSV values.
			var objPattern = new RegExp(
				(
					// Delimiters.
					"(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

					// Quoted fields.
					"(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

					// Standard fields.
					"([^\"\\" + strDelimiter + "\\r\\n]*))"
				),
				"gi"
				);


			// Create an array to hold our data. Give the array
			// a default empty first row.
			var arrData = [[]];

			// Create an array to hold our individual pattern
			// matching groups.
			var arrMatches = null;


			// Keep looping over the regular expression matches
			// until we can no longer find a match.
			while ((arrMatches = objPattern.exec( strData ))){

				// Get the delimiter that was found.
				var strMatchedDelimiter = arrMatches[ 1 ];

				// Check to see if the given delimiter has a length
				// (is not the start of string) and if it matches
				// field delimiter. If id does not, then we know
				// that this delimiter is a row delimiter.
				if (
					strMatchedDelimiter.length &&
					strMatchedDelimiter !== strDelimiter
					){

					// Since we have reached a new row of data,
					// add an empty row to our data array.
					arrData.push( [] );

				}

				var strMatchedValue;

				// Now that we have our delimiter out of the way,
				// let's check to see which kind of value we
				// captured (quoted or unquoted).
				if (arrMatches[ 2 ]){

					// We found a quoted value. When we capture
					// this value, unescape any double quotes.
					strMatchedValue = arrMatches[ 2 ].replace(
						new RegExp( "\"\"", "g" ),
						"\""
						);

				} else {

					// We found a non-quoted value.
					strMatchedValue = arrMatches[ 3 ];

				}


				// Now that we have our value string, let's add
				// it to the data array.
				arrData[ arrData.length - 1 ].push( strMatchedValue );
			}

			// Return the parsed data.
			return( arrData );
		},

		warn_page_name_change: function(frm) {
			frappe.msgprint(__("Note: Changing the Page Name will break previous URL to this page."));
		},

		notify: function(subject, body, route, onclick) {
			console.log('push notifications are evil and deprecated');
		},

		set_title: function(title) {
			frappe._original_title = title;
			if(frappe._title_prefix) {
				title = frappe._title_prefix + " " + title.replace(/<[^>]*>/g, "");
			}
			document.title = title;
		},

		set_title_prefix: function(prefix) {
			frappe._title_prefix = prefix;

			// reset the original title
			frappe.utils.set_title(frappe._original_title);
		},

		is_image_file: function(filename) {
			if (!filename) { return false; }
			// url can have query params
			filename = filename.split('?')[0];
			return (/\.(gif|jpg|jpeg|tiff|png|svg)$/i).test(filename);
		},

		play_sound: function(name) {
			try {
				if (frappe.boot.user.mute_sounds) {
					return;
				}

				var audio = $("#sound-" + name)[0];
				audio.volume = audio.getAttribute("volume");
				audio.play();

			} catch(e) {
				console.log("Cannot play sound", name, e);
				// pass
			}

		},
		split_emails: function(txt) {
			var email_list = [];

			if (!txt) {
				return email_list;
			}

			// emails can be separated by comma or newline
			txt.split(/[,\n](?=(?:[^"]|"[^"]*")*$)/g).forEach(function(email) {
				email = email.trim();
				if (email) {
					email_list.push(email);
				}
			});

			return email_list;
		},
		supportsES6: function() {
			try {
				new Function("(a = 0) => a");
				return true;
			}
			catch (err) {
				return false;
			}
		}(),
		throttle: function (func, wait, options) {
			var context, args, result;
			var timeout = null;
			var previous = 0;
			if (!options) { options = {}; }

			var later = function () {
				previous = options.leading === false ? 0 : Date.now();
				timeout = null;
				result = func.apply(context, args);
				if (!timeout) { context = args = null; }
			};

			return function () {
				var now = Date.now();
				if (!previous && options.leading === false) { previous = now; }
				var remaining = wait - (now - previous);
				context = this;
				args = arguments;
				if (remaining <= 0 || remaining > wait) {
					if (timeout) {
						clearTimeout(timeout);
						timeout = null;
					}
					previous = now;
					result = func.apply(context, args);
					if (!timeout) { context = args = null; }
				} else if (!timeout && options.trailing !== false) {
					timeout = setTimeout(later, remaining);
				}
				return result;
			};
		},
		debounce: function(func, wait, immediate) {
			var timeout;
			return function() {
				var context = this, args = arguments;
				var later = function() {
					timeout = null;
					if (!immediate) { func.apply(context, args); }
				};
				var callNow = immediate && !timeout;
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
				if (callNow) { func.apply(context, args); }
			};
		},
		get_form_link: function(doctype, name, html, display_text) {
			if ( html === void 0 ) html = false;
			if ( display_text === void 0 ) display_text = null;

			display_text = display_text || name;
			doctype = encodeURIComponent(doctype);
			name = encodeURIComponent(name);
			var route = ['#Form', doctype, name].join('/');
			if (html) {
				return ("<a href=\"" + route + "\">" + display_text + "</a>");
			}
			return route;
		},
		get_route_label: function get_route_label(route_str) {
			var route = route_str.split('/');

			if (route[2] === 'Report' || route[0] === 'query-report') {
				return __('{0} Report', [route[3] || route[1]]);
			}
			if (route[0] === 'List') {
				return __('{0} List', [route[1]]);
			}
			if (route[0] === 'modules') {
				return __('{0} Modules', [route[1]]);
			}
			if (route[0] === 'dashboard') {
				return __('{0} Dashboard', [route[1]]);
			}
			return __(frappe.utils.to_title_case(route[0], true));
		},
		report_column_total: function(values, column, type) {
			if (column.column.disable_total) {
				return '';
			} else if (values.length > 0) {
				if (column.column.fieldtype == "Percent" || type === "mean") {
					return values.reduce(function (a, b) { return a + flt(b); }) / values.length;
				} else if (column.column.fieldtype == "Int") {
					return values.reduce(function (a, b) { return a + cint(b); });
				} else if (frappe.model.is_numeric_field(column.column.fieldtype)) {
					return values.reduce(function (a, b) { return a + flt(b); });
				} else {
					return null;
				}
			}
			else {
				return null;
			}
		},
		setup_search: function setup_search($wrapper, el_class, text_class, data_attr) {
			var $search_input = $wrapper.find('[data-element="search"]').show();
			$search_input.focus().val('');
			var $elements = $wrapper.find(el_class).show();

			$search_input.off('keyup').on('keyup', function () {
				var text_filter = $search_input.val().toLowerCase();
				// Replace trailing and leading spaces
				text_filter = text_filter.replace(/^\s+|\s+$/g, '');
				for (var i = 0; i < $elements.length; i++) {
					var text_element = $elements.eq(i).find(text_class);
					var text = text_element.text().toLowerCase();

					var name = '';
					if (data_attr && text_element.attr(data_attr)) {
						name = text_element.attr(data_attr).toLowerCase();
					}

					if (text.includes(text_filter) || name.includes(text_filter)) {
						$elements.eq(i).css('display', '');
					} else {
						$elements.eq(i).css('display', 'none');
					}
				}
			});
		},
		deep_equal: function deep_equal$1(a, b) {
			return fastDeepEqual(a, b);
		},

		file_name_ellipsis: function file_name_ellipsis(filename, length) {
			var first_part_length = length * 2 / 3;
			var last_part_length = length - first_part_length;
			var parts = filename.split('.');
			var extn = parts.pop();
			var name = parts.join('');
			var first_part = name.slice(0, first_part_length);
			var last_part = name.slice(-last_part_length);
			if (name.length > length) {
				return (first_part + "..." + last_part + "." + extn);
			} else {
				return filename;
			}
		},
		get_decoded_string: function get_decoded_string(dataURI) {
			// decodes base64 to string
			var parts = dataURI.split(',');
			var encoded_data = parts[1];
			return decodeURIComponent(escape(atob(encoded_data)));
		},
		copy_to_clipboard: function copy_to_clipboard(string) {
			var input = $("<input>");
			$("body").append(input);
			input.val(string).select();

			document.execCommand("copy");
			input.remove();

			frappe.show_alert({
				indicator: 'green',
				message: __('Copied to clipboard.')
			});
		},
		is_rtl: function is_rtl() {
			return ["ar", "he", "fa"].includes(frappe.boot.lang);
		},
		bind_actions_with_object: function bind_actions_with_object($el, object) {
			// remove previously bound event
			$($el).off('click.class_actions');
			// attach new event
			$($el).on('click.class_actions', '[data-action]', function (e) {
				var $target = $(e.currentTarget);
				var action = $target.data('action');
				var method = object[action];
				method ? object[action](e, $target) : null;
			});

			return $el;
		},

		get_browser: function get_browser() {
			var ua = navigator.userAgent,
				tem,
				M =
					ua.match(
						/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i
					) || [];
			if (/trident/i.test(M[1])) {
				tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
				return { name: "IE", version: tem[1] || "" };
			}
			if (M[1] === "Chrome") {
				tem = ua.match(/\bOPR|Edge\/(\d+)/);
				if (tem != null) {
					return { name: "Opera", version: tem[1] };
				}
			}
			M = M[2]
				? [M[1], M[2]]
				: [navigator.appName, navigator.appVersion, "-?"];
			if ((tem = ua.match(/version\/(\d+)/i)) != null) {
				M.splice(1, 1, tem[1]);
			}
			return {
				name: M[0],
				version: M[1],
			};
		},

		get_formatted_duration: function get_formatted_duration(value, duration_options) {
			if ( duration_options === void 0 ) duration_options=null;

			var duration = '';
			if (!duration_options) {
				duration_options = {
					hide_days: 0,
					hide_seconds: 0
				};
			}
			if (value) {
				var total_duration = frappe.utils.seconds_to_duration(value, duration_options);

				if (total_duration.days) {
					duration += total_duration.days + __('d', null, 'Days (Field: Duration)');
				}
				if (total_duration.hours) {
					duration += (duration.length ? " " : "");
					duration += total_duration.hours + __('h', null, 'Hours (Field: Duration)');
				}
				if (total_duration.minutes) {
					duration += (duration.length ? " " : "");
					duration += total_duration.minutes + __('m', null, 'Minutes (Field: Duration)');
				}
				if (total_duration.seconds) {
					duration += (duration.length ? " " : "");
					duration += total_duration.seconds + __('s', null, 'Seconds (Field: Duration)');
				}
			}
			return duration;
		},

		seconds_to_duration: function seconds_to_duration(value, duration_options) {
			var secs = value;
			var total_duration = {
				days: Math.floor(secs / (3600 * 24)),
				hours: Math.floor(secs % (3600 * 24) / 3600),
				minutes: Math.floor(secs % 3600 / 60),
				seconds: Math.floor(secs % 60)
			};
			if (duration_options.hide_days) {
				total_duration.hours = Math.floor(secs / 3600);
				total_duration.days = 0;
			}
			return total_duration;
		},

		duration_to_seconds: function duration_to_seconds(days, hours, minutes, seconds) {
			if ( days === void 0 ) days=0;
			if ( hours === void 0 ) hours=0;
			if ( minutes === void 0 ) minutes=0;
			if ( seconds === void 0 ) seconds=0;

			var value = 0;
			if (days) {
				value += days * 24 * 60 * 60;
			}
			if (hours) {
				value += hours * 60 * 60;
			}
			if (minutes) {
				value += minutes * 60;
			}
			if (seconds) {
				value += seconds;
			}
			return value;
		},

		get_duration_options: function(docfield) {
			var duration_options = {
				hide_days: docfield.hide_days,
				hide_seconds: docfield.hide_seconds
			};
			return duration_options;
		}
	});

	// Array de duplicate
	if (!Array.prototype.uniqBy) {
		Object.defineProperty(Array.prototype, 'uniqBy', {
			value: function (key) {
				var seen = {};
				return this.filter(function (item) {
					var k = key(item);
					return seen.hasOwnProperty(k) ? false : (seen[k] = true);
				});
			}
		});
		Object.defineProperty(Array.prototype, 'move', {
			value: function(from, to) {
				this.splice(to, 0, this.splice(from, 1)[0]);
			}
		});
	}

	// Pluralize
	String.prototype.plural = function(revert) {
		var plural = {
			"(quiz)$": "$1zes",
			"^(ox)$": "$1en",
			"([m|l])ouse$": "$1ice",
			"(matr|vert|ind)ix|ex$": "$1ices",
			"(x|ch|ss|sh)$": "$1es",
			"([^aeiouy]|qu)y$": "$1ies",
			"(hive)$": "$1s",
			"(?:([^f])fe|([lr])f)$": "$1$2ves",
			"(shea|lea|loa|thie)f$": "$1ves",
			sis$: "ses",
			"([ti])um$": "$1a",
			"(tomat|potat|ech|her|vet)o$": "$1oes",
			"(bu)s$": "$1ses",
			"(alias)$": "$1es",
			"(octop)us$": "$1i",
			"(ax|test)is$": "$1es",
			"(us)$": "$1es",
			"([^s]+)$": "$1s",
		};

		var singular = {
			"(quiz)zes$": "$1",
			"(matr)ices$": "$1ix",
			"(vert|ind)ices$": "$1ex",
			"^(ox)en$": "$1",
			"(alias)es$": "$1",
			"(octop|vir)i$": "$1us",
			"(cris|ax|test)es$": "$1is",
			"(shoe)s$": "$1",
			"(o)es$": "$1",
			"(bus)es$": "$1",
			"([m|l])ice$": "$1ouse",
			"(x|ch|ss|sh)es$": "$1",
			"(m)ovies$": "$1ovie",
			"(s)eries$": "$1eries",
			"([^aeiouy]|qu)ies$": "$1y",
			"([lr])ves$": "$1f",
			"(tive)s$": "$1",
			"(hive)s$": "$1",
			"(li|wi|kni)ves$": "$1fe",
			"(shea|loa|lea|thie)ves$": "$1f",
			"(^analy)ses$": "$1sis",
			"((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$":
				"$1$2sis",
			"([ti])a$": "$1um",
			"(n)ews$": "$1ews",
			"(h|bl)ouses$": "$1ouse",
			"(corpse)s$": "$1",
			"(us)es$": "$1",
			s$: "",
		};

		var irregular = {
			move: "moves",
			foot: "feet",
			goose: "geese",
			sex: "sexes",
			child: "children",
			man: "men",
			tooth: "teeth",
			person: "people",
		};

		var uncountable = [
			"sheep",
			"fish",
			"deer",
			"moose",
			"series",
			"species",
			"money",
			"rice",
			"information",
			"equipment" ];

		// save some time in the case that singular and plural are the same
		if (uncountable.indexOf(this.toLowerCase()) >= 0) { return this; }

		// check for irregular forms
		var word;
		var pattern;
		var replace;
		for (word in irregular) {
			if (revert) {
				pattern = new RegExp(irregular[word] + "$", "i");
				replace = word;
			} else {
				pattern = new RegExp(word + "$", "i");
				replace = irregular[word];
			}
			if (pattern.test(this)) { return this.replace(pattern, replace); }
		}

		var array;
		if (revert) { array = singular; }
		else { array = plural; }

		// check for matches using regular expressions
		var reg;
		for (reg in array) {
			pattern = new RegExp(reg, "i");

			if (pattern.test(this)) { return this.replace(pattern, array[reg]); }
		}

		return this;
	};

	frappe.provide('frappe.utils');
	/**
	 * Simple EventEmitterMixin which uses jQuery's event system
	 */
	var EventEmitterMixin = {
		init: function init() {
			this.jq = jQuery({});
		},

		trigger: function trigger(evt, data) {
			!this.jq && this.init();
			this.jq.trigger(evt, data);
		},

		once: function once(evt, handler) {
			!this.jq && this.init();
			this.jq.one(evt, function (e, data) { return handler(data); });
		},

		on: function on(evt, handler) {
			!this.jq && this.init();
			this.jq.bind(evt, function (e, data) { return handler(data); });
		},

		off: function off(evt, handler) {
			!this.jq && this.init();
			this.jq.unbind(evt, function (e, data) { return handler(data); });
		}
	};

	frappe.utils.make_event_emitter = function(object) {
		Object.assign(object, EventEmitterMixin);
		return object;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// route urls to their virtual pages

	// re-route map (for rename)
	frappe.provide('frappe.views');
	frappe.re_route = {"#login": ""};
	frappe.route_titles = {};
	frappe.route_flags = {};
	frappe.route_history = [];
	frappe.view_factory = {};
	frappe.view_factories = [];
	frappe.route_options = null;
	frappe.route_hooks = {};

	frappe.route = function() {

		// Application is not yet initiated
		if (!frappe.app) { return; }

		if(frappe.re_route[window.location.hash] !== undefined) {
			// after saving a doc, for example,
			// "New DocType 1" and the renamed "TestDocType", both exist in history
			// now if we try to go back,
			// it doesn't allow us to go back to the one prior to "New DocType 1"
			// Hence if this check is true, instead of changing location hash,
			// we just do a back to go to the doc previous to the "New DocType 1"
			var re_route_val = frappe.get_route_str(frappe.re_route[window.location.hash]);
			var cur_route_val = frappe.get_route_str(frappe._cur_route);
			if (decodeURIComponent(re_route_val) === decodeURIComponent(cur_route_val)) {
				window.history.back();
				return;
			} else {
				window.location.hash = frappe.re_route[window.location.hash];
			}
		}

		frappe._cur_route = window.location.hash;

		var route = frappe.get_route();
		if (route === false) {
			return;
		}

		frappe.route_history.push(route);

		if(route[0]) {
			var title_cased_route = frappe.utils.to_title_case(route[0]);
			if (title_cased_route === 'Workspace') {
				frappe.views.pageview.show('');
			}

			if (route[1] && frappe.views[title_cased_route + "Factory"]) {
				// has a view generator, generate!
				if(!frappe.view_factory[title_cased_route]) {
					frappe.view_factory[title_cased_route] = new frappe.views[title_cased_route + "Factory"]();
				}

				frappe.view_factory[title_cased_route].show();
			} else {
				// show page
				var route_name = frappe.utils.xss_sanitise(route[0]);
				if (frappe.views.pageview) {
					frappe.views.pageview.show(route_name);
				}
			}
		} else {
			// Show desk
			frappe.views.pageview.show('');
		}


		if(frappe.route_titles[window.location.hash]) {
			frappe.utils.set_title(frappe.route_titles[window.location.hash]);
		} else {
			setTimeout(function() {
				frappe.route_titles[frappe.get_route_str()] = frappe._original_title || document.title;
			}, 1000);
		}

		if(window.mixpanel) {
			window.mixpanel.track(route.slice(0, 2).join(' '));
		}
	};

	frappe.get_route = function(route) {
		// for app
		route = frappe.get_raw_route_str(route).split('/');
		route = $.map(route, frappe._decode_str);
		var parts = null;
		var doc_name = route[route.length - 1];
		// if the last part contains ? then check if it is valid query string
		if(doc_name.indexOf("?") < doc_name.indexOf("=")){
			parts = doc_name.split("?");
			route[route.length - 1] = parts[0];
		} else {
			parts = doc_name;
		}
		if (parts.length > 1) {
			var query_params = frappe.utils.get_query_params(parts[1]);
			frappe.route_options = $.extend(frappe.route_options || {}, query_params);
		}

		// backward compatibility
		if (route && route[0]==='Module') {
			frappe.set_route('modules', route[1]);
			return false;
		}

		return route;
	};

	frappe.get_prev_route = function() {
		if(frappe.route_history && frappe.route_history.length > 1) {
			return frappe.route_history[frappe.route_history.length - 2];
		} else {
			return [];
		}
	};

	frappe._decode_str = function(r) {
		try {
			return decodeURIComponent(r);
		} catch(e) {
			if (e instanceof URIError) {
				return r;
			} else {
				throw e;
			}
		}
	};

	frappe.get_raw_route_str = function(route) {
		if(!route)
			{ route = window.location.hash; }

		if(route.substr(0,1)=='#') { route = route.substr(1); }
		if(route.substr(0,1)=='!') { route = route.substr(1); }

		return route;
	};

	frappe.get_route_str = function(route) {
		var rawRoute = frappe.get_raw_route_str(route);
		route = $.map(rawRoute.split('/'), frappe._decode_str).join('/');

		return route;
	};

	frappe.set_route = function() {
		var arguments$1 = arguments;

		return new Promise(function (resolve) {
			var params = arguments$1;
			if(params.length===1 && $.isArray(params[0])) {
				params = params[0];
			}
			var route = $.map(params, function(a) {
				if($.isPlainObject(a)) {
					frappe.route_options = a;
					return null;
				} else {
					a = String(a);
					if (a && a.match(/[%'"]/)) {
						// if special chars, then encode
						a = encodeURIComponent(a);
					}
					return a;
				}
			}).join('/');

			// Perform a redirect when redirect is set in route_options
			if (frappe.route_options && frappe.route_options.redirect) {
				var url = new URL(window.location);
				url.hash = route;
				window.location.replace(url);
			} else {
				window.location.hash = route;
			}

			// Set favicon (app.js)
			frappe.provide('frappe.app');
			frappe.app.set_favicon && frappe.app.set_favicon();
			setTimeout(function () {
				frappe.after_ajax && frappe.after_ajax(function () {
					resolve();
				});
			}, 100);
		});
	};

	frappe.set_re_route = function() {
		var tmp = window.location.hash;
		frappe.set_route.apply(null, arguments);
		frappe.re_route[tmp] = window.location.hash;
	};

	frappe.has_route_options = function() {
		return Boolean(Object.keys(frappe.route_options || {}).length);
	};

	frappe._cur_route = null;

	$(window).on('hashchange', function() {
		// save the title
		frappe.route_titles[frappe._cur_route] = frappe._original_title || document.title;

		if(window.location.hash==frappe._cur_route)
			{ return; }

		// hide open dialog
		if(window.cur_dialog) {
			if (!cur_dialog.minimizable) {
				cur_dialog.hide();
			} else if (!cur_dialog.is_minimized) {
				cur_dialog.toggle_minimize();
			}
		}

		frappe.route();

		frappe.route.trigger('change');
	});

	frappe.utils.make_event_emitter(frappe.route);

	frappe.provide('frappe.route');
	frappe.route_history_queue = [];
	var routes_to_skip = ['Form', 'social', 'setup-wizard', 'recorder'];

	var save_routes = frappe.utils.debounce(function () {
		var routes = frappe.route_history_queue;
		frappe.route_history_queue = [];
		frappe.xcall('frappe.deferred_insert.deferred_insert', {
			'doctype': 'Route History',
			'records': routes
		}).catch(function () {
			frappe.route_history_queue.concat(routes);
		});
	}, 10000);

	frappe.route.on('change', function () {
		var route = frappe.get_route();
		if (is_route_useful(route)) {
			frappe.route_history_queue.push({
				'user': frappe.session.user,
				'creation': frappe.datetime.now_datetime(),
				'route': frappe.get_route_str()
			});

			save_routes();
		}
	});

	function is_route_useful(route) {
		if (!route[1]) {
			return false;
		} else if ((route[0] === 'List' && !route[2]) || routes_to_skip.includes(route[0])) {
			return false;
		} else {
			return true;
		}
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.defaults = {
		get_user_default: function(key) {
			var defaults = frappe.boot.user.defaults;
			var d = defaults[key];
			if(!d && frappe.defaults.is_a_user_permission_key(key))
				{ d = defaults[frappe.model.scrub(key)]; }
			if($.isArray(d)) { d = d[0]; }

			if(!frappe.defaults.in_user_permission(key, d)) {
				return;
			}

			return d;
		},
		get_user_defaults: function(key) {
			var defaults = frappe.boot.user.defaults;
			var d = defaults[key];

			if (frappe.defaults.is_a_user_permission_key(key)) {
				if (d && $.isArray(d) && d.length===1) {
					// Use User Permission value when only when it has a single value
					d = d[0];
				} else {
					d = defaults[key] || defaults[frappe.model.scrub(key)];
				}
			}
			if(!$.isArray(d)) { d = [d]; }

			// filter out values which are not permitted to the user
			d.filter(function (item) {
				if(frappe.defaults.in_user_permission(key, item)) {
					return item;
				}
			});
			return d;
		},
		get_global_default: function(key) {
			var d = frappe.sys_defaults[key];
			if($.isArray(d)) { d = d[0]; }
			return d;
		},
		get_global_defaults: function(key) {
			var d = frappe.sys_defaults[key];
			if(!$.isArray(d)) { d = [d]; }
			return d;
		},
		set_default: function(key, value, callback) {
			if(typeof value!=="string")
				{ value = JSON.stringify(value); }

			frappe.boot.user.defaults[key] = value;
			return frappe.call({
				method: "frappe.client.set_default",
				args: {
					key: key,
					value: value
				},
				callback: callback || function(r) {}
			});
		},
		set_user_default_local: function(key, value) {
			frappe.boot.user.defaults[key] = value;
		},
		get_default: function(key) {
			var defaults = frappe.boot.user.defaults;
			var value = defaults[key];
			if (frappe.defaults.is_a_user_permission_key(key)) {
				if (value && $.isArray(value) && value.length===1) {
					value = value[0];
				} else {
					value = defaults[frappe.model.scrub(key)];
				}
			}

			if(!frappe.defaults.in_user_permission(key, value)) {
				return;
			}

			if(value) {
				try {
					return JSON.parse(value)
				} catch(e) {
					return value;
				}
			}
		},

		is_a_user_permission_key: function(key) {
			return key.indexOf(":")===-1 && key !== frappe.model.scrub(key);
		},

		in_user_permission: function(key, value) {
			var user_permission = this.get_user_permissions()[frappe.model.unscrub(key)];

			if (user_permission && user_permission.length) {

				var doc_found = user_permission.some(function (perm) {
					return perm.doc === value;
				});
				return doc_found;

			} else {
				// there is no user permission for this doctype
				// so we can allow this doc i.e., value
				return true;
			}

		},

		get_user_permissions: function() {
			return this._user_permissions || {};
		},

		update_user_permissions: function() {
			var this$1 = this;

			var method = 'frappe.core.doctype.user_permission.user_permission.get_user_permissions';
			frappe.call(method).then(function (r) {
				if (r.message) {
					this$1._user_permissions = Object.assign({}, r.message);
				}
			});
		}
	};

	frappe.RoleEditor = Class.extend({
		init: function(wrapper, frm, disable) {
			var me = this;
			this.frm = frm;
			this.wrapper = wrapper;
			this.disable = disable;
			$(wrapper).html('<div class="help">' + __("Loading") + '...</div>');
			frappe.call({
				method: 'frappe.core.doctype.user.user.get_all_roles',
				callback: function(r) {
					me.roles = r.message;
					me.show_roles();

					// refresh call could've already happened
					// when all role checkboxes weren't created
					if(me.frm.doc) {
						me.frm.roles_editor.show();
					}
				}
			});
		},
		show_roles: function() {
			var me = this;
			$(this.wrapper).empty();
			if(me.frm.doctype != 'User') {
				var role_toolbar = $('<p><button class="btn btn-default btn-add btn-sm" style="margin-right: 5px;"></button>\
				<button class="btn btn-sm btn-default btn-remove"></button></p>').appendTo($(this.wrapper));

				role_toolbar.find(".btn-add")
					.html(__('Add all roles'))
					.on("click", function() {
						$(me.wrapper).find('input[type="checkbox"]').each(function(i, check) {
							if (!$(check).is(":checked")) {
								check.checked = true;
							}
						});
					});

				role_toolbar.find(".btn-remove")
					.html(__('Clear all roles'))
					.on("click", function() {
						$(me.wrapper).find('input[type="checkbox"]').each(function(i, check) {
							if($(check).is(":checked")) {
								check.checked = false;
							}
						});
					});
			}

			$.each(this.roles, function(i, role) {
				$(me.wrapper).append(repl('<div class="user-role" \
				data-user-role="%(role_value)s">\
				<input type="checkbox" style="margin-top:0px;" class="box"> \
				<a href="#" class="grey role">%(role_display)s</a>\
			</div>', {role_value: role,role_display:__(role)}));
			});

			$(this.wrapper).find('input[type="checkbox"]').change(function() {
				me.set_roles_in_table();
				me.frm.dirty();
			});
			$(this.wrapper).find('.user-role a').click(function() {
				me.show_permissions($(this).parent().attr('data-user-role'));
				return false;
			});
		},
		show: function() {
			var me = this;
			$('.box').attr('disabled', this.disable);

			// uncheck all roles
			$(this.wrapper).find('input[type="checkbox"]')
				.each(function(i, checkbox) {
					checkbox.checked = false;
				});

			// set user roles as checked
			$.each((me.frm.doc.roles || []), function(i, user_role) {
				var checkbox = $(me.wrapper)
					.find('[data-user-role="'+user_role.role+'"] input[type="checkbox"]').get(0);
				if(checkbox) { checkbox.checked = true; }
			});

			this.set_enable_disable();
		},
		set_enable_disable: function() {
			$('.box').attr('disabled', this.disable ? true : false);
		},
		set_roles_in_table: function() {
			var opts = this.get_roles();
			var existing_roles_map = {};
			var existing_roles_list = [];
			var me = this;

			$.each((me.frm.doc.roles || []), function(i, user_role) {
				existing_roles_map[user_role.role] = user_role.name;
				existing_roles_list.push(user_role.role);
			});

			// remove unchecked roles
			$.each(opts.unchecked_roles, function(i, role) {
				if(existing_roles_list.indexOf(role)!=-1) {
					frappe.model.clear_doc("Has Role", existing_roles_map[role]);
				}
			});

			// add new roles that are checked
			$.each(opts.checked_roles, function(i, role) {
				if(existing_roles_list.indexOf(role)==-1) {
					var user_role = frappe.model.add_child(me.frm.doc, "Has Role", "roles");
					user_role.role = role;
				}
			});

			refresh_field("roles");
		},
		get_roles: function() {
			var checked_roles = [];
			var unchecked_roles = [];
			$(this.wrapper).find('[data-user-role]').each(function() {
				if($(this).find('input[type="checkbox"]:checked').length) {
					checked_roles.push($(this).attr('data-user-role'));
				} else {
					unchecked_roles.push($(this).attr('data-user-role'));
				}
			});

			return {
				checked_roles: checked_roles,
				unchecked_roles: unchecked_roles
			};
		},
		show_permissions: function(role) {
			// show permissions for a role
			var me = this;
			if(!this.perm_dialog)
				{ this.make_perm_dialog(); }
			$(this.perm_dialog.body).empty();
			return frappe.call({
				method: 'frappe.core.doctype.user.user.get_perm_info',
				args: {role: role},
				callback: function(r) {
					var $body = $(me.perm_dialog.body);
					// TODO fix the overflow issue and also display perms like report, import, etc.

					$body.append('<table class="user-perm"><thead><tr>'
						+ '<th style="text-align: left">' + __('Document Type') + '</th>'
						+ '<th>' + __('Level') + '</th>'
						+ '<th>' + __('Read') + '</th>'
						+ '<th>' + __('Write') + '</th>'
						+ '<th>' + __('Create') + '</th>'
						+ '<th>' + __('Delete') + '</th>'
						+ '<th>' + __('Submit') + '</th>'
						+ '<th>' + __('Cancel') + '</th>'
						+ '<th>' + __('Amend') + '</th>'
						+ '<th>' + __('Set User Permissions') + '</th>'
						+ '</tr></thead><tbody></tbody></table>');

					for(var i=0, l=r.message.length; i<l; i++) {
						var perm = r.message[i];

						// if permission -> icon
						for(var key in perm) {
							if(key!='parent' && key!='permlevel') {
								if(perm[key]) {
									perm[key] = '<i class="fa fa-check"></i>';
								} else {
									perm[key] = '';
								}
							}
						}

						$body.find('tbody').append(repl('<tr>\
						<td style="text-align: left">%(parent)s</td>\
						<td>%(permlevel)s</td>\
						<td>%(read)s</td>\
						<td>%(write)s</td>\
						<td>%(create)s</td>\
						<td>%(delete)s</td>\
						<td>%(submit)s</td>\
						<td>%(cancel)s</td>\
						<td>%(amend)s</td>\
						<td>%(set_user_permissions)s</td>\
						</tr>', perm));
					}
					me.perm_dialog.set_title(role);
					me.perm_dialog.show();
				}
			});

		},
		make_perm_dialog: function() {
			this.perm_dialog = new frappe.ui.Dialog({
				title: __('Role Permissions')
			});

			this.perm_dialog.$wrapper.find('.modal-dialog').css("width", "800px");
		}
	});

	// Simple JavaScript Templating
	// Adapted from John Resig - http://ejohn.org/ - MIT Licensed

	frappe.template = {compiled: {}, debug:{}};
	frappe.template.compile = function(str, name) {
		var key = name || str;

		if(!frappe.template.compiled[key]) {
			if(str.indexOf("'")!==-1) {
				str.replace(/'/g, "\\'");
				//console.warn("Warning: Single quotes (') may not work in templates");
			}

			// replace jinja style tags
			str = str.replace(/{{/g, "{%=").replace(/}}/g, "%}");

			// {% if not test %} --> {% if (!test) { %}
			str = str.replace(/{%\s?if\s?\s?not\s?([^\(][^%{]+)\s?%}/g, "{% if (! $1) { %}");

			// {% if test %} --> {% if (test) { %}
			str = str.replace(/{%\s?if\s?([^\(][^%{]+)\s?%}/g, "{% if ($1) { %}");

			// {% for item in list %}
			//       --> {% for (var i=0, len=list.length; i<len; i++) {  var item = list[i]; %}
			function replacer(match, p1, p2, offset, string) {
				var i = frappe.utils.get_random(3);
				var len = frappe.utils.get_random(3);
				return "{% for (var "+i+"=0, "+len+"="+p2+".length; "+i+"<"+len+"; "+i+"++) { var "
					+p1+" = "+p2+"["+i+"]; "+p1+"._index = "+i+"; %}";
			}
			str = str.replace(/{%\s?for\s([a-z._]+)\sin\s([a-z._]+)\s?%}/g, replacer);

			// {% endfor %} --> {% } %}
			str = str.replace(/{%\s?endif\s?%}/g, "{% }; %}");

			// {% else %} --> {% } else { %}
			str = str.replace(/{%\s?else\s?%}/g, "{% } else { %}");

			// {% endif %} --> {% } %}
			str = str.replace(/{%\s?endfor\s?%}/g, "{% }; %}");

			var fn_str = "var _p=[],print=function(){_p.push.apply(_p,arguments)};" +

		        // Introduce the data as local variables using with(){}
		        "with(obj){\n_p.push('" +

		        // Convert the template into pure JavaScript
		        str
		          .replace(/[\r\t\n]/g, " ")
		          .split("{%").join("\t")
		          .replace(/((^|%})[^\t]*)'/g, "$1\r")
		          .replace(/\t=(.*?)%}/g, "',$1,'")
		          .split("\t").join("');\n")
		          .split("%}").join("\n_p.push('")
		          .split("\r").join("\\'")
		      + "');}return _p.join('');";

			  frappe.template.debug[name] = fn_str;
			try {
				frappe.template.compiled[key] = new Function("obj", fn_str);
			} catch (e) {
				console.log("Error in Template:");
				console.log(fn_str);
				if(e.lineNumber) {
					console.log("Error in Line "+e.lineNumber+", Col "+e.columnNumber+":");
					console.log(fn_str.split("\n")[e.lineNumber - 1]);
				}
			}
	    }

		return frappe.template.compiled[key];
	};
	frappe.render = function(str, data, name) {
		return frappe.template.compile(str, name)(data);
	};
	frappe.render_template = function(name, data) {
		if(name.indexOf(' ')!==-1) {
			var template = name;
		} else {
			var template = frappe.templates[name];
		}
		if(data===undefined) {
			data = {};
		}
		return frappe.render(template, data, name);
	};
	frappe.render_grid = function(opts) {
		// build context
		if(opts.grid) {
			opts.columns = opts.grid.getColumns();
			opts.data = opts.grid.getData().getItems();
		}

		// show landscape view if columns more than 10
		if (opts.landscape == null) {
			if(opts.columns && opts.columns.length > 10) {
				opts.landscape = true;
			} else {
				opts.landscape = false;
			}
		}

		// render content
		if(!opts.content) {
			opts.content = frappe.render_template(opts.template || "print_grid", opts);
		}

		// render HTML wrapper page
		opts.base_url = frappe.urllib.get_base_url();
		opts.print_css = frappe.boot.print_css;
		var html = frappe.render_template("print_template", opts);

		var w = window.open();

		if(!w) {
			frappe.msgprint(__("Please enable pop-ups in your browser"));
		}

		w.document.write(html);
		w.document.close();
	},
	frappe.render_tree = function(opts) {
		opts.base_url = frappe.urllib.get_base_url();
		opts.landscape = false;
		opts.print_css = frappe.boot.print_css;
		var tree = frappe.render_template("print_tree", opts);
		var w = window.open();

		if(!w) {
			frappe.msgprint(__("Please enable pop-ups in your browser"));
		}

		w.document.write(tree);
		w.document.close();
	};
	frappe.render_pdf = function(html, opts) {
		if ( opts === void 0 ) opts = {};

		//Create a form to place the HTML content
		var formData = new FormData();

		//Push the HTML content into an element
		formData.append("html", html);
		if (opts.orientation) {
			formData.append("orientation", opts.orientation);
		}
		var blob = new Blob([], { type: "text/xml"});
		formData.append("blob", blob);

		var xhr = new XMLHttpRequest();
		xhr.open("POST", '/api/method/frappe.utils.print_format.report_to_pdf');
		xhr.setRequestHeader("X-Frappe-CSRF-Token", frappe.csrf_token);
		xhr.responseType = "arraybuffer";

		xhr.onload = function(success) {
			if (this.status === 200) {
				var blob = new Blob([success.currentTarget.response], {type: "application/pdf"});
				var objectUrl = URL.createObjectURL(blob);

				//Open report in a new window
				window.open(objectUrl);
			}
		};
		xhr.send(formData);
	};

	frappe.templates['page'] = '<div class="page-head flex align-center">  <div class="container">   <div class="row flex align-center">    <div class="col-md-7 col-sm-8 col-xs-6 page-title">          <h1 class="flex" style="margin: auto;">      <div class="title-image hide hidden-md hidden-lg">      </div>      <div class="flex fill-width title-area" style="max-width: 100%">       <div class="ellipsis title-text"></div>       <span class="indicator whitespace-nowrap hide"></span>      </div>     </h1>    </div>    <div class="text-right col-md-5 col-sm-4 col-xs-6 page-actions">          <span class="checked-items-status text-ellipsis text-muted small hide hidden-xs hidden-sm" style="margin-right: 20px;">## items selected</span>     <h6 class="ellipsis sub-heading hide text-muted"></h6>     <span class="page-icon-group hide hidden-xs hidden-sm"></span>           <div class="btn-group menu-btn-group hide">      <button type="button" class="btn btn-default btn-sm dropdown-toggle" data-toggle="dropdown" aria-expanded="false">       <span class="hidden-xs">        <span class="menu-btn-group-label">{%= __("Menu") %}</span>        <span class="caret"></span>       </span>       <span class="visible-xs">        <i class="octicon octicon-triangle-down"></i>       </span>      </button>      <ul class="dropdown-menu" role="menu"></ul>     </div>     <button class="btn btn-secondary btn-default btn-sm hide"></button>     <div class="btn-group actions-btn-group hide">      <button type="button" class="btn btn-primary btn-sm dropdown-toggle" data-toggle="dropdown" aria-expanded="false">       <span class="hidden-xs">        <span class="actions-btn-group-label">{%= __("Actions") %}</span>        <span class="caret"></span>       </span>       <span class="visible-xs octicon octicon-check"></span>      </button>      <ul class="dropdown-menu" role="menu">      </ul>     </div>     <button class="btn btn-primary btn-sm hide primary-action"></button>    </div>   </div>  </div> </div> <div class="container page-body">  <div class="page-toolbar hide">   <div class="container">   </div>  </div>  <div class="page-wrapper">   <div class="page-content">    <div class="workflow-button-area btn-group pull-right hide"></div>    <div class="clearfix"></div>   </div>  </div> </div>';

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	/**
	 * Make a standard page layout with a toolbar and title
	 *
	 * @param {Object} opts
	 *
	 * @param {string} opts.parent [HTMLElement] Parent element
	 * @param {boolean} opts.single_column Whether to include sidebar
	 * @param {string} [opts.title] Page title
	 * @param {Object} [opts.make_page]
	 *
	 * @returns {frappe.ui.Page}
	 */

	/**
	 * @typedef {Object} frappe.ui.Page
	 */


	frappe.ui.make_app_page = function(opts) {
		opts.parent.page = new frappe.ui.Page(opts);
		return opts.parent.page;
	};

	frappe.ui.pages = {};

	frappe.ui.Page = Class.extend({
		init: function(opts) {
			$.extend(this, opts);

			this.set_document_title = true;
			this.buttons = {};
			this.fields_dict = {};
			this.views = {};

			this.make();
			frappe.ui.pages[frappe.get_route_str()] = this;
		},

		make: function() {
			this.wrapper = $(this.parent);
			this.add_main_section();
		},

		get_empty_state: function(title, message, primary_action) {
			var $empty_state = $(("<div class=\"page-card-container\">\n\t\t\t<div class=\"page-card\">\n\t\t\t\t<div class=\"page-card-head\">\n\t\t\t\t\t<span class=\"indicator blue\">\n\t\t\t\t\t\t" + title + "</span>\n\t\t\t\t</div>\n\t\t\t\t<p>" + message + "</p>\n\t\t\t\t<div>\n\t\t\t\t\t<button class=\"btn btn-primary btn-sm\">" + primary_action + "</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>"));

			return $empty_state;
		},

		load_lib: function(callback) {
			frappe.require(this.required_libs, callback);
		},

		add_main_section: function() {
			$(frappe.render_template("page", {})).appendTo(this.wrapper);
			if(this.single_column) {
				// nesting under col-sm-12 for consistency
				this.add_view("main", '<div class="row layout-main">\
					<div class="col-md-12 layout-main-section-wrapper">\
						<div class="layout-main-section"></div>\
						<div class="layout-footer hide"></div>\
					</div>\
				</div>');
			} else {
				this.add_view("main", '<div class="row layout-main">\
				<div class="col-md-2 layout-side-section"></div>\
				<div class="col-md-10 layout-main-section-wrapper">\
					<div class="layout-main-section"></div>\
					<div class="layout-footer hide"></div>\
				</div>\
			</div>');
			}

			this.setup_page();
		},

		setup_page: function() {
			this.$title_area = this.wrapper.find("h1");

			this.$sub_title_area = this.wrapper.find("h6");

			if(this.set_document_title!==undefined)
				{ this.set_document_title = this.set_document_title; }

			if(this.title)
				{ this.set_title(this.title); }

			if(this.icon)
				{ this.get_main_icon(this.icon); }

			this.body = this.main = this.wrapper.find(".layout-main-section");
			this.sidebar = this.wrapper.find(".layout-side-section");
			this.footer = this.wrapper.find(".layout-footer");
			this.indicator = this.wrapper.find(".indicator");

			this.page_actions = this.wrapper.find(".page-actions");

			this.btn_primary = this.page_actions.find(".primary-action");
			this.btn_secondary = this.page_actions.find(".btn-secondary");

			this.menu = this.page_actions.find(".menu-btn-group .dropdown-menu");
			this.menu_btn_group = this.page_actions.find(".menu-btn-group");

			this.actions = this.page_actions.find(".actions-btn-group .dropdown-menu");
			this.actions_btn_group = this.page_actions.find(".actions-btn-group");

			this.page_form = $('<div class="page-form row hide"></div>').prependTo(this.main);
			this.inner_toolbar = $('<div class="form-inner-toolbar hide"></div>').prependTo(this.main);
			this.icon_group = this.page_actions.find(".page-icon-group");

			if(this.make_page) {
				this.make_page();
			}

			// keyboard shortcuts
			var menu_btn = this.menu_btn_group.find('button');
			frappe.ui.keys
				.get_shortcut_group(this.page_actions[0])
				.add(menu_btn, menu_btn.find('.menu-btn-group-label'));

			var action_btn = this.actions_btn_group.find('button');
			frappe.ui.keys
				.get_shortcut_group(this.page_actions[0])
				.add(action_btn, action_btn.find('.actions-btn-group-label'));
		},

		set_indicator: function(label, color) {
			this.clear_indicator().removeClass("hide").html(("<span>" + label + "</span>")).addClass(color);
		},

		add_action_icon: function(icon, click) {
			return $('<a class="text-muted no-decoration"><i class="'+icon+'"></i></a>')
				.appendTo(this.icon_group.removeClass("hide"))
				.click(click);
		},

		clear_indicator: function() {
			return this.indicator.removeClass().addClass("indicator whitespace-nowrap hide");
		},

		get_icon_label: function(icon, label) {
			return '<i class="visible-xs ' + icon + '"></i><span class="hidden-xs">' + label + '</span>'
		},

		set_action: function(btn, opts) {
			var me = this;
			if (opts.icon) {
				opts.label = this.get_icon_label(opts.icon, opts.label);
			}

			this.clear_action_of(btn);

			btn.removeClass("hide")
				.prop("disabled", false)
				.html(opts.label)
				.on("click", function() {
					var response = opts.click.apply(this);
					me.btn_disable_enable(btn, response);
				});

			if (opts.working_label) {
				btn.attr("data-working-label", opts.working_label);
			}

			// alt shortcuts
			var text_span = btn.find('span');
			frappe.ui.keys
				.get_shortcut_group(this)
				.add(btn, text_span.length ? text_span : btn);
		},

		set_primary_action: function(label, click, icon, working_label) {
			this.set_action(this.btn_primary, {
				label: label,
				click: click,
				icon: icon,
				working_label: working_label
			});
			return this.btn_primary;

		},

		set_secondary_action: function(label, click, icon, working_label) {
			this.set_action(this.btn_secondary, {
				label: label,
				click: click,
				icon: icon,
				working_label: working_label
			});

			return this.btn_secondary;
		},


		clear_action_of: function(btn) {
			btn.addClass("hide").unbind("click").removeAttr("data-working-label");
		},

		clear_primary_action: function() {
			this.clear_action_of(this.btn_primary);
		},

		clear_secondary_action: function() {
			this.clear_action_of(this.btn_secondary);
		},

		clear_actions: function() {
			this.clear_primary_action();
			this.clear_secondary_action();
		},

		clear_icons: function() {
			this.icon_group.addClass("hide").empty();
		},

		//--- Menu --//

		add_menu_item: function(label, click, standard, shortcut) {
			return this.add_dropdown_item({
				label: label,
				click: click,
				standard: standard,
				parent: this.menu,
				shortcut: shortcut
			});
		},

		clear_menu: function() {
			this.clear_btn_group(this.menu);
		},

		show_menu: function() {
			this.menu_btn_group.removeClass("hide");
		},

		hide_menu: function() {
			this.menu_btn_group.addClass("hide");
		},

		show_icon_group: function() {
			this.icon_group.removeClass("hide");
		},

		hide_icon_group: function() {
			this.icon_group.addClass("hide");
		},

		//--- Actions Menu--//

		show_actions_menu: function() {
			this.actions_btn_group.removeClass("hide");
		},

		hide_actions_menu: function() {
			this.actions_btn_group.addClass("hide");
		},


		add_action_item: function(label, click, standard) {
			return this.add_dropdown_item({
				label: label,
				click: click,
				standard: standard,
				parent: this.actions
			});
		},

		add_actions_menu_item: function(label, click, standard) {
			return this.add_dropdown_item({
				label: label,
				click: click,
				standard: standard,
				parent: this.actions,
				show_parent: false
			});
		},

		clear_actions_menu: function() {
			this.clear_btn_group(this.actions);
		},


		//-- Generic --//

		/*
		* Add label to given drop down menu. If label, is already contained in the drop
		* down menu, it will be ignored.
		* @param {string} label - Text for the drop down menu
		* @param {function} click - function to be called when `label` is clicked
		* @param {Boolean} standard
		* @param {object} parent - DOM object representing the parent of the drop down item lists
		* @param {string} shortcut - Keyboard shortcut associated with the element
		* @param {Boolean} show_parent - Whether to show the dropdown button if dropdown item is added
		*/
		add_dropdown_item: function(ref) {
			var label = ref.label;
			var click = ref.click;
			var standard = ref.standard;
			var parent = ref.parent;
			var shortcut = ref.shortcut;
			var show_parent = ref.show_parent; if ( show_parent === void 0 ) show_parent = true;

			if (show_parent) {
				parent.parent().removeClass("hide");
			}

			var $li;
			if (shortcut) {
				var shortcut_obj = this.prepare_shortcut_obj(shortcut, click, label);
				$li = $(("<li><a class=\"grey-link dropdown-item\" href=\"#\" onClick=\"return false;\">\n\t\t\t\t<span class=\"menu-item-label\">" + label + "</span>\n\t\t\t\t<span class=\"text-muted pull-right\">" + (shortcut_obj.shortcut_label) + "</span>\n\t\t\t</a><li>"));
				frappe.ui.keys.add_shortcut(shortcut_obj);
			} else {
				$li = $(("<li><a class=\"grey-link dropdown-item\" href=\"#\" onClick=\"return false;\">\n\t\t\t\t<span class=\"menu-item-label\">" + label + "</span></a><li>"));
			}
			var $link = $li.find("a").on("click", click);

			if (this.is_in_group_button_dropdown(parent, 'li > a.grey-link', label)) { return; }

			if (standard) {
				$li.appendTo(parent);
			} else {
				this.divider = parent.find(".divider");
				if(!this.divider.length) {
					this.divider = $('<li class="divider user-action"></li>').prependTo(parent);
				}
				$li.addClass("user-action").insertBefore(this.divider);
			}

			// alt shortcut
			frappe.ui.keys
				.get_shortcut_group(parent.get(0))
				.add($link, $link.find('.menu-item-label'));

			return $link;
		},

		prepare_shortcut_obj: function prepare_shortcut_obj(shortcut, click, label) {
			var shortcut_obj;
			// convert to object, if shortcut string passed
			if (typeof shortcut === 'string') {
				shortcut_obj = { shortcut: shortcut };
			} else {
				shortcut_obj = shortcut;
			}
			// label
			if (frappe.utils.is_mac()) {
				shortcut_obj.shortcut_label = shortcut_obj.shortcut.replace('Ctrl', '⌘');
			} else {
				shortcut_obj.shortcut_label = shortcut_obj.shortcut;
			}
			// actual shortcut string
			shortcut_obj.shortcut = shortcut_obj.shortcut.toLowerCase();
			// action is button click
			if (!shortcut_obj.action) {
				shortcut_obj.action = click;
			}
			// shortcut description can be button label
			if (!shortcut_obj.description) {
				shortcut_obj.description = label;
			}
			// page
			shortcut_obj.page = this;
			return shortcut_obj;
		},

		/*
		* Check if there already exists a button with a specified label in a specified button group
		* @param {object} parent - This should be the `ul` of the button group.
		* @param {string} selector - CSS Selector of the button to be searched for. By default, it is `li`.
		* @param {string} label - Label of the button
		*/
		is_in_group_button_dropdown: function(parent, selector, label) {

			if (!selector) { selector = 'li'; }

			if (!label || !parent) { return false; }

			var result = $(parent).find((selector + ":contains('" + label + "')"))
				.filter(function() {
					var item = $(this).html();
					return $(item).attr('data-label') === label;
				});
			return result.length > 0;
		},

		clear_btn_group: function(parent) {
			parent.empty();
			parent.parent().addClass("hide");
		},

		add_divider: function() {
			return $('<li class="divider"></li>').appendTo(this.menu);
		},

		get_or_add_inner_group_button: function(label) {
			var $group = this.inner_toolbar.find('.btn-group[data-label="'+encodeURIComponent(label)+'"]');
			if(!$group.length) {
				$group = $('<div class="btn-group" data-label="'+encodeURIComponent(label)+'" style="margin-left: 10px;">\
				<button type="button" class="btn btn-default dropdown-toggle btn-xs" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">\
				'+label+' <span class="caret"></span></button>\
				<ul role="menu" class="dropdown-menu" style="margin-top: -8px;"></ul></div>').appendTo(this.inner_toolbar);
			}
			return $group;
		},

		get_inner_group_button: function(label) {
			return this.inner_toolbar.find('.btn-group[data-label="'+encodeURIComponent(label)+'"]');
		},

		set_inner_btn_group_as_primary: function(label) {
			this.get_or_add_inner_group_button(label).find("button").removeClass("btn-default").addClass("btn-primary");
		},

		btn_disable_enable: function(btn, response) {
			if (response && response.then) {
				btn.prop('disabled', true);
				response.then(function () {
					btn.prop('disabled', false);
				});
			} else if (response && response.always) {
				btn.prop('disabled', true);
				response.always(function () {
					btn.prop('disabled', false);
				});
			}
		},

		/*
		* Add button to button group. If there exists another button with the same label,
		* `add_inner_button` will not add the new button to the button group even if the callback
		* function is different.
		*
		* @param {string} label - Label of the button to be added to the group
		* @param {object} action - function to be called when button is clicked
		* @param {string} group - Label of the group button
		*/
		add_inner_button: function(label, action, group, type) {
			if ( type === void 0 ) type="default";

			var me = this;
			var _action = function() {
				var btn = $(this);
				var response = action();
				me.btn_disable_enable(btn, response);
			};
			if(group) {
				var $group = this.get_or_add_inner_group_button(group);
				$(this.inner_toolbar).removeClass("hide");

				if (!this.is_in_group_button_dropdown($group.find(".dropdown-menu"), 'li', label)) {
					return $('<li><a href="#" onclick="return false;" data-label="'+encodeURIComponent(label)+'">'+label+'</a></li>')
						.on('click', _action)
						.appendTo($group.find(".dropdown-menu"));
				}

			} else {
				var button = this.inner_toolbar.find('button[data-label="'+encodeURIComponent(label)+'"]');
				if( button.length == 0 ) {
					return $('<button data-label="'+encodeURIComponent(label)+"\" class=\"btn btn-" + type + " btn-xs\" style=\"margin-left: 10px;\">"+__(label)+'</btn>')
						.on("click", _action)
						.appendTo(this.inner_toolbar.removeClass("hide"));
				} else {
					return button;
				}
			}
		},

		remove_inner_button: function(label, group) {
			if (typeof label === 'string') {
				label = [label];
			}
			// translate
			label = label.map(function (l) { return __(l); });

			if (group) {
				var $group = this.get_inner_group_button(__(group));
				if($group.length) {
					$group.find('.dropdown-menu li a[data-label="'+encodeURIComponent(label)+'"]').remove();
				}
				if ($group.find('.dropdown-menu li a').length === 0) { $group.remove(); }
			} else {

				this.inner_toolbar.find('button[data-label="'+encodeURIComponent(label)+'"]').remove();
			}
		},

		add_inner_message: function(message) {
			var $message = $(("<span class='inner-page-message text-muted small'>" + message + "</div>"));
			this.inner_toolbar.find('.inner-page-message').remove();
			this.inner_toolbar.removeClass("hide").prepend($message);

			return $message;
		},

		clear_inner_toolbar: function() {
			this.inner_toolbar.empty().addClass("hide");
		},

		//-- Sidebar --//

		add_sidebar_item: function(label, action, insert_after, prepend) {
			var parent = this.sidebar.find(".sidebar-menu.standard-actions");
			var li = $('<li>');
			var link = $('<a>').html(label).on("click", action).appendTo(li);

			if (insert_after) {
				li.insertAfter(parent.find(insert_after));
			} else {
				if(prepend) {
					li.prependTo(parent);
				} else {
					li.appendTo(parent);
				}
			}
			return link;
		},

		//---//

		clear_user_actions: function() {
			this.menu.find(".user-action").remove();
		},

		// page::title
		get_title_area: function() {
			return this.$title_area;
		},

		set_title: function(txt, icon, stripHtml, tabTitle) {
			if ( icon === void 0 ) icon = '';
			if ( stripHtml === void 0 ) stripHtml = true;
			if ( tabTitle === void 0 ) tabTitle = '';

			if(!txt) { txt = ""; }

			if(stripHtml) {
				txt = strip_html(txt);
			}
			this.title = txt;

			frappe.utils.set_title(tabTitle || txt);
			if(icon) {
				txt = '<span class="'+ icon +' text-muted" style="font-size: inherit;"></span> ' + txt;
			}
			this.$title_area.find(".title-text").html(txt);
		},

		set_title_sub: function(txt) {
			// strip icon
			this.$sub_title_area.html(txt).toggleClass("hide", !!!txt);
		},

		get_main_icon: function(icon) {
			return this.$title_area.find(".title-icon")
				.html('<i class="'+icon+' fa-fw"></i> ')
				.toggle(true);
		},

		add_help_button: function(txt) {
			//
		},

		add_button: function(label, click, icon, is_title) {
			//
		},

		add_dropdown_button: function(parent, label, click, icon) {
			frappe.ui.toolbar.add_dropdown_button(parent, label, click, icon);
		},

		// page::form
		add_label: function(label) {
			this.show_form();
			return $("<label class='col-md-1 page-only-label'>"+label+" </label>")
				.appendTo(this.page_form);
		},
		add_select: function(label, options) {
			var field = this.add_field({label:label, fieldtype:"Select"});
			return field.$wrapper.find("select").empty().add_options(options);
		},
		add_data: function(label) {
			var field = this.add_field({label: label, fieldtype: "Data"});
			return field.$wrapper.find("input").attr("placeholder", label);
		},
		add_date: function(label, date) {
			var field = this.add_field({label: label, fieldtype: "Date", "default": date});
			return field.$wrapper.find("input").attr("placeholder", label);
		},
		add_check: function(label) {
			return $("<div class='checkbox'><label><input type='checkbox'>" + label + "</label></div>")
				.appendTo(this.page_form)
				.find("input");
		},
		add_break: function() {
			// add further fields in the next line
			this.page_form.append('<div class="clearfix invisible-xs"></div>');
		},
		add_field: function(df) {
			this.show_form();

			if (!df.placeholder) {
				df.placeholder = df.label;
			}

			var f = frappe.ui.form.make_control({
				df: df,
				parent: this.page_form,
				only_input: df.fieldtype=="Check" ? false : true,
			});
			f.refresh();
			$(f.wrapper)
				.addClass('col-md-2')
				.attr("title", __(df.label)).tooltip();

			// html fields in toolbar are only for display
			if (df.fieldtype=='HTML') {
				return;
			}

			// hidden fields dont have $input
			if (!f.$input) { f.make_input(); }

			f.$input.addClass("input-sm").attr("placeholder", __(df.label));

			if(df.fieldtype==="Check") {
				$(f.wrapper).find(":first-child")
					.removeClass("col-md-offset-4 col-md-8");
			}

			if(df.fieldtype=="Button") {
				$(f.wrapper).find(".page-control-label").html("&nbsp;");
				f.$input.addClass("btn-sm").css({"width": "100%", "margin-top": "-1px"});
			}

			if(df["default"])
				{ f.set_input(df["default"]); }
			this.fields_dict[df.fieldname || df.label] = f;
			return f;
		},
		clear_fields: function() {
			this.page_form.empty();
		},
		show_form: function() {
			this.page_form.removeClass("hide");
		},
		hide_form: function() {
			this.page_form.addClass("hide");
		},
		get_form_values: function() {
			var values = {};
			this.page_form.fields_dict.forEach(function(field, key) {
				values[key] = field.get_value();
			});
			return values;
		},
		add_view: function(name, html) {
			var element = html;
			if(typeof (html) === "string") {
				element = $(html);
			}
			this.views[name] = element.appendTo($(this.wrapper).find(".page-content"));
			if(!this.current_view) {
				this.current_view = this.views[name];
			} else {
				this.views[name].toggle(false);
			}
			return this.views[name];
		},
		set_view: function(name) {
			if(this.current_view_name===name)
				{ return; }
			this.current_view && this.current_view.toggle(false);
			this.current_view = this.views[name];

			this.previous_view_name = this.current_view_name;
			this.current_view_name = name;

			this.views[name].toggle(true);

			this.wrapper.trigger('view-change');
		},
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// License: GNU General Public License v3. See license.txt

	frappe.provide("frappe.ui");

	frappe.ui.Slide = class Slide {
		constructor(slide) {
		if ( slide === void 0 ) slide = null;

			$.extend(this, slide);
			this.setup();
		}

		setup() {
			this.$wrapper = $('<div class="slide-wrapper hidden"></div>')
				.attr({"data-slide-id": this.id, "data-slide-name": this.name})
				.appendTo(this.parent);
		}

		// Make has to be called manually, to account for on-demand use cases
		make() {
			if(this.before_load) { this.before_load(this); }

			this.$body = $(("<div class=\"slide-body\">\n\t\t\t<div class=\"content text-center\">\n\t\t\t\t<p class=\"title lead\">" + (this.title) + "</p>\n\t\t\t</div>\n\t\t\t<div class=\"form-wrapper\">\n\t\t\t\t<div class=\"form\"></div>\n\t\t\t\t<div class=\"add-more text-center\" style=\"margin-top: 5px;\">\n\t\t\t\t\t<a class=\"form-more-btn hide btn btn-default btn-xs\">\n\t\t\t\t\t\t<span>Add More</span>\n\t\t\t\t\t</a>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>")).appendTo(this.$wrapper);

			this.$content = this.$body.find(".content");
			this.$form = this.$body.find(".form");
			this.$primary_btn = this.slides_footer.find('.primary');
			this.$form_wrapper = this.$body.find(".form-wrapper");

			if(this.image_src) { this.$content.append(
				$(("<img src=\"" + (this.image_src) + "\" style=\"margin: 20px;\">"))); }
			if(this.help) { this.$content.append($(("<p class=\"slide-help\">" + (this.help) + "</p>"))); }

			this.reqd_fields = [];

			this.refresh();
			this.made = true;
		}

		refresh() {
			this.render_parent_dots();
			if(!this.done) {
				this.setup_form();
			} else {
				this.setup_done_state();
			}
		}

		setup_form() {
			this.form = new frappe.ui.FieldGroup({
				fields: this.get_atomic_fields(),
				body: this.$form[0],
				no_submit_on_enter: true
			});
			this.form.make();
			if(this.add_more) { this.bind_more_button(); }

			this.set_reqd_fields();

			if(this.onload) { this.onload(this); }
			this.set_reqd_fields();
		}

		setup_done_state() {}

		// Form methods
		get_atomic_fields() {
			var this$1 = this;

			var fields = JSON.parse(JSON.stringify(this.fields));
			if (this.add_more) {
				this.count = 1;
				fields = fields.map(function (field, i) {
					if (field.fieldname) {
						field.fieldname += '_1';
					}
					if (i === 1 && this$1.mandatory_entry) {
						field.reqd = 1;
					}
					if (!field.static) {
						if (field.label) { field.label; }
					}
					return field;
				});
			}
			return fields;
		}

		set_reqd_fields() {
			var this$1 = this;

			var dict = this.form.fields_dict;
			this.reqd_fields = [];
			Object.keys(dict).map(function (key) {
				if(dict[key].df.reqd) {
					this$1.reqd_fields.push(dict[key]);
				}
			});
		}

		set_values() {
			this.values = this.form.get_values();
			if (this.values===null) {
				return false;
			}
			if (this.validate && !this.validate()) {
				return false;
			}
			return true;
		}

		bind_more_button() {
			var this$1 = this;

			this.$more = this.$body.find('.form-more-btn');
			this.$more.removeClass('hide')
				.on('click', function () {
					this$1.count++;
					var fields = JSON.parse(JSON.stringify(this$1.fields));

					this$1.form.add_fields(fields.map(function (field) {
						if (field.fieldname) { field.fieldname += '_' + this$1.count; }
						if (!field.static) {
							if (field.label) { field.label; }
						}
						field.reqd = 0;
						return field;
					}));

					if(this$1.count === this$1.max_count) {
						this$1.$more.addClass('hide');
					}
				});
		}

		// Primary button (outside of slide)
		resetup_primary_button() {
			this.unbind_primary_action();
			this.bind_fields_to_action_btn();
			this.reset_action_button_state();
			this.bind_primary_action();
		}

		bind_fields_to_action_btn() {
			var me = this;
			this.reqd_fields.map(function (field) {
				field.$wrapper.on('change input click', function () {
					me.reset_action_button_state();
				});
				field.$wrapper.on('keydown', 'input', function (e) {
					if (e.key == 'Enter') {
						me.reset_action_button_state();
					}
				});
			});
		}

		reset_action_button_state() {
			var empty_fields = this.reqd_fields.filter(function (field) {
				return !field.get_value();
			});
			if (empty_fields.length) {
				this.slides_footer.find('.action').addClass('disabled');
			} else {
				this.slides_footer.find('.action').removeClass('disabled');
			}
		}

		unbind_primary_action() {
			this.slides_footer.find(".primary").off();
		}

		bind_primary_action() {
			var this$1 = this;

			this.slides_footer.find(".primary").on('click.primary_action', function () {
				this$1.primary_action();
			});
		}

		is_last_slide() {
			if (this.id === this.parent[0].children.length-1) {
				return true;
			}
			return false;
		}

		before_show() { }

		show_slide() {
			this.$wrapper.removeClass("hidden");
			this.before_show();
			this.resetup_primary_button();
			if(!this.done) {
				this.$body.find('.form-control').first().focus();
				this.$primary_btn.show();
			} else {
				this.$primary_btn.hide();
			}
		}

		hide_slide() {
			this.$wrapper.addClass("hidden");
		}

		get_input(fieldname) {
			return this.form.get_input(fieldname);
		}

		get_field(fieldname) {
			return this.form.get_field(fieldname);
		}

		get_value(fieldname) {
			return this.form.get_value(fieldname);
		}

		destroy() {
			this.$body.remove();
		}

		primary_action() { }
	};

	frappe.ui.Slides = class Slides {
		constructor(ref) {
		var parent = ref.parent; if ( parent === void 0 ) parent = null;
		var slides = ref.slides; if ( slides === void 0 ) slides = [];
		var slide_class = ref.slide_class; if ( slide_class === void 0 ) slide_class = null;
		var unidirectional = ref.unidirectional; if ( unidirectional === void 0 ) unidirectional = 0;
		var done_state = ref.done_state; if ( done_state === void 0 ) done_state = 0;
		var before_load = ref.before_load; if ( before_load === void 0 ) before_load = null;
		var on_update = ref.on_update; if ( on_update === void 0 ) on_update = null;

			this.parent = parent;
			this.slides = slides;
			this.slide_class = slide_class;
			this.unidirectional = unidirectional;
			this.done_state = done_state;
			this.before_load = before_load;
			this.on_update = on_update;

			this.slide_dict = {};

			//In case of refreshing
			this.made_slide_ids = [];
			this.values = {};
			this.make();
		}

		make() {
			this.container = $('<div>').addClass("slides-wrapper").attr({"tabindex": -1})
				.appendTo(this.parent);
			this.$slide_progress = $("<div>").addClass("slides-progress text-center text-extra-muted")
				.appendTo(this.container);
			this.$body = $("<div>").addClass("slide-container")
				.appendTo(this.container);
			this.$footer = $("<div>").addClass("slide-footer")
				.appendTo(this.container);

			this.render_progress_dots();
			this.make_prev_next_buttons();
			if(this.before_load) { this.before_load(this.$footer); }

			// can be on demand
			this.setup();

			// can be on demand
			this.show_slide(0);
		}

		setup() {
			var this$1 = this;

			this.slides.map(function (slide, id) {
				if(!this$1.slide_dict[id]) {
					this$1.slide_dict[id] = new (this$1.slide_class)(
						$.extend(this$1.slides[id], {
							parent: this$1.$body,
							slides_footer: this$1.$footer,
							render_parent_dots: this$1.render_progress_dots.bind(this$1),
							id: id,
						})
					);
					if(!this$1.unidirectional) {
						this$1.slide_dict[id].make();
					}
				} else {
					if(this$1.made_slide_ids.includes(id+"")) {
						this$1.slide_dict[id].destroy();
						this$1.slide_dict[id].make();
					}
				}
			});
		}

		refresh(id) {
			this.render_progress_dots();
			this.show_hide_prev_next(id);
			this.$body.find('.form-control').first().focus();
		}

		render_progress_dots() {
			var this$1 = this;

			// Depends on this.unidirectional and this.done_state
			// Can be called by a slide to update states
			this.$slide_progress.empty();

			this.slides.map(function (slide, id) {
				var $dot = $("<i class=\"fa fa-fw fa-circle\"> </i> ")
					.attr({'data-step-id': id});

				if(this$1.done_state && (this$1.slide_dict[id] &&
					this$1.slide_dict[id].done || slide.done)) {
					$dot.addClass('text-success');
				}
				if((this$1.unidirectional && id <= this$1.current_id) ||
					id === this$1.current_id) {
					$dot.addClass('active');
				}
				// Add pointer event for non-unidirectional
				this$1.$slide_progress.append($dot);
			});

			this.completed = 0;
			this.slides.map(function (slide, i) {
				if(this$1.slide_dict[i]) {
					if(this$1.slide_dict[i].done) { this$1.completed++; }
				} else {
					if(slide.done) { this$1.completed++; }
				}
			});
			if(this.on_update) {this.on_update(this.completed, this.slides.length);}

			if(!this.unidirectional) { this.bind_progress_dots(); }
		}

		make_prev_next_buttons() {
			var this$1 = this;

			$(("<div class=\"row\">\n\t\t\t<div class=\"col-sm-4 text-left prev-div\">\n\t\t\t\t<a class=\"prev-btn btn btn-default btn-sm\" tabindex=\"0\">" + (__("Previous")) + "</a>\n\t\t\t</div>\n\t\t\t<div class=\"col-sm-8 text-right next-div\">\n\t\t\t\t<a class=\"next-btn btn btn-default btn-sm\" tabindex=\"0\">" + (__("Next")) + "</a>\n\t\t\t</div>\n\t\t</div>")).appendTo(this.$footer);

			this.$prev_btn = this.$footer.find('.prev-btn').attr('tabIndex', 0)
				.on('click', function () { this$1.show_slide(this$1.current_id - 1); });

			this.$next_btn = this.$footer.find('.next-btn').attr('tabIndex', 0)
				.on('click', function () {
					if (!this$1.unidirectional || (this$1.unidirectional && this$1.current_slide.set_values())) {
						this$1.show_slide(this$1.current_id + 1);
					}
				});
		}

		bind_progress_dots() {
			var me = this;
			this.$slide_progress.find('.fa-circle').addClass('link').on('click', function() {
				var id = $(this).attr('data-step-id');
				me.show_slide(id);
			});
		}

		before_show_slide() {
			return true;
		}

		show_slide(id) {
			id = cint(id);
			if(!this.before_show_slide() ||
				(this.current_slide && this.current_id===id)) {
				return;
			}

			this.update_values();

			if(this.current_slide) { this.current_slide.hide_slide(); }
			if(this.unidirectional && !this.slide_dict[id].made) {
				this.slide_dict[id].make();
			}
			this.current_id = id;
			this.current_slide = this.slide_dict[id];
			this.current_slide.show_slide();
			this.refresh(id);
		}

		destroy_slide(id) {
			if(this.slide_dict[id]) { this.slide_dict[id].destroy(); }
			this.slide_dict[id] = null;
		}

		on_update(completed, total) {}

		show_hide_prev_next(id) {
			(id === 0) ?
				this.$prev_btn.hide() : this.$prev_btn.show();
			(id + 1 === this.slides.length) ?
				this.$next_btn.hide() : this.$next_btn.show();
		}

		get_values() {
			var values = {};
			$.each(this.slide_dict, function(id, slide) {
				if(slide.values) {
					$.extend(values, slide.values);
				}
			});
			return values;
		}

		update_values() {
			this.values = $.extend(this.values, this.get_values());
		}
	};

	frappe.find = {
		page_primary_action: function () {
			return $('.page-actions:visible .btn-primary');
		},
		field: function (fieldname, value) {
			return new Promise(function (resolve) {
				var input = $(("[data-fieldname=\"" + fieldname + "\"] :input"));
				if(value) {
					input.val(value).trigger('change');
					frappe.after_ajax(function () { resolve(input); });
				} else {
					resolve(input);
				}
			});
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.ui.IconBar = Class.extend({
		init: function(parent, n_groups) {
			this.parent = parent;
			this.buttons = {};
			this.make(n_groups);
		},
		make: function(n_groups) {
			this.$wrapper = $('<div class="iconbar-wrapper hide"></div>').appendTo(this.parent);
			for(var i=0; i<n_groups; i++) {
				this.get_group(i+1);
			}
		},
		get_group: function(group) {
			var $ul = this.$wrapper.find(".iconbar-"+group+" ul");
			
			if(!$ul.length)
				{ $ul = $('<div class="iconbar iconbar-'+group+' hide"><ul></ul></div>')
					.appendTo(this.$wrapper).find("ul"); }
			
			return $ul;
		},
		add_btn: function(group, icon, label, click) {
			var $ul = this.get_group(group);
			var $li = $('<li><i class="'+icon+'"></i></li>')
				.appendTo($ul)
				.on("click", function() {
					click.apply(this);
					return false;
				});
				
			$li.find("i").attr("title", label).tooltip();

				
			this.$wrapper.find(".iconbar-" + group).removeClass("hide");
			this.show();
			return $li;
		},
		hide: function(group) {
			if(group) {
				this.$wrapper.find(".iconbar-" + group).addClass("hide");
				this.check_if_all_hidden();
			} else {
				this.$wrapper.addClass("hide").trigger("hidden");
			}
		},
		show: function(group) {
			if(group) {
				this.$wrapper.find(".iconbar-" + group).removeClass("hide");
				this.show();
			} else {
				if(this.$wrapper.hasClass("hide"))
					{ this.$wrapper.removeClass("hide").trigger("shown"); }
			}
		},
		clear: function(group) {
			this.$wrapper.find(".iconbar-" + group).addClass("hide").find("ul").empty();
			this.check_if_all_hidden();
		},
		check_if_all_hidden: function() {
			if(!this.$wrapper.find(".iconbar:visible").length) {
				this.hide();
			}
		}
	});

	// Copyright (c) 2018, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.ui.form.LinkSelector = Class.extend({
		init: function (opts) {
			/* help: Options: doctype, get_query, target */
			$.extend(this, opts);

			var me = this;
			if (this.doctype != "[Select]") {
				frappe.model.with_doctype(this.doctype, function (r) {
					me.make();
				});
			} else {
				this.make();
			}
		},
		make: function () {
			var me = this;

			this.start = 0;
			this.dialog = new frappe.ui.Dialog({
				title: __("Select {0}", [(this.doctype == '[Select]') ? __("value") : __(this.doctype)]),
				fields: [
					{
						fieldtype: "Data", fieldname: "txt", label: __("Beginning with"),
						description: __("You can use wildcard %"),
					},
					{
						fieldtype: "HTML", fieldname: "results"
					},
					{
						fieldtype: "Button", fieldname: "more", label: __("More"), click: function () {
							me.start += 20;
							me.search();
						}
					}
				],
				primary_action_label: __("Search"),
				primary_action: function () {
					me.start = 0;
					me.search();
				}
			});

			if (this.txt)
				{ this.dialog.fields_dict.txt.set_input(this.txt); }

			this.dialog.get_input("txt").on("keypress", function (e) {
				if (e.which === 13) {
					me.start = 0;
					me.search();
				}
			});
			this.dialog.show();
			this.search();
		},
		search: function () {
			var args = {
				txt: this.dialog.fields_dict.txt.get_value(),
				searchfield: "name",
				start: this.start
			};
			var me = this;

			if (this.target.set_custom_query) {
				this.target.set_custom_query(args);
			}

			// load custom query from grid
			if (this.target.is_grid && this.target.fieldinfo[this.fieldname]
				&& this.target.fieldinfo[this.fieldname].get_query) {
				$.extend(args,
					this.target.fieldinfo[this.fieldname].get_query(cur_frm.doc));
			}

			frappe.link_search(this.doctype, args, function (r) {
				var parent = me.dialog.fields_dict.results.$wrapper;
				if (args.start === 0) {
					parent.empty();
				}

				if (r.values.length) {
					$.each(r.values, function (i, v) {
						var row = $(repl('<div class="row link-select-row">\
						<div class="col-xs-4">\
							<b><a href="#">%(name)s</a></b></div>\
						<div class="col-xs-8">\
							<span class="text-muted">%(values)s</span></div>\
						</div>', {
								name: v[0],
								values: v.splice(1).join(", ")
							})).appendTo(parent);

						row.find("a")
							.attr('data-value', v[0])
							.click(function () {
								var value = $(this).attr("data-value");
								if (me.target.is_grid) {
									// set in grid
									me.set_in_grid(value);
								} else {
									if (me.target.doctype)
										{ me.target.parse_validate_and_set_in_model(value); }
									else {
										me.target.set_input(value);
										me.target.$input.trigger("change");
									}
									me.dialog.hide();
								}
								return false;
							});
					});
				} else {
					$('<p><br><span class="text-muted">' + __("No Results") + '</span>'
						+ (frappe.model.can_create(me.doctype) ?
							('<br><br><a class="new-doc btn btn-default btn-sm">'
								+ __('Create a new {0}', [__(me.doctype)]) + "</a>") : '')
						+ '</p>').appendTo(parent).find(".new-doc").click(function () {
							frappe.new_doc(me.doctype);
						});
				}

				if (r.values.length < 20) {
					var more_btn = me.dialog.fields_dict.more.$wrapper;
					more_btn.hide();
				}

			}, this.dialog.get_primary_btn());

		},
		set_in_grid: function (value) {
			var me = this, updated = false;
			var d = null;
			if (this.qty_fieldname) {
				frappe.prompt({
					fieldname: "qty", fieldtype: "Float", label: "Qty",
					"default": 1, reqd: 1
				}, function (data) {
					$.each(me.target.frm.doc[me.target.df.fieldname] || [], function (i, d) {
						if (d[me.fieldname] === value) {
							frappe.model.set_value(d.doctype, d.name, me.qty_fieldname, data.qty);
							frappe.show_alert(__("Added {0} ({1})", [value, d[me.qty_fieldname]]));
							updated = true;
							return false;
						}
					});
					if (!updated) {
						frappe.run_serially([
							function () {
								d = me.target.add_new_row();
							},
							function () { return frappe.timeout(0.1); },
							function () { return frappe.model.set_value(d.doctype, d.name, me.fieldname, value); },
							function () { return frappe.timeout(0.5); },
							function () { return frappe.model.set_value(d.doctype, d.name, me.qty_fieldname, data.qty); },
							function () { return frappe.show_alert(__("Added {0} ({1})", [value, data.qty])); }
						]);
					}
				}, __("Set Quantity"), __("Set"));
			} else if (me.dynamic_link_field) {
				var d = me.target.add_new_row();
				frappe.model.set_value(d.doctype, d.name, me.dynamic_link_field, me.dynamic_link_reference);
				frappe.model.set_value(d.doctype, d.name, me.fieldname, value);
				frappe.show_alert(__("{0} {1} added", [me.dynamic_link_reference, value]));
			} else {
				var d = me.target.add_new_row();
				frappe.model.set_value(d.doctype, d.name, me.fieldname, value);
				frappe.show_alert(__("{0} added", [value]));
			}
		}
	});

	frappe.link_search = function (doctype, args, callback, btn) {
		if (!args) {
			args = {
				txt: ''
			};
		}
		args.doctype = doctype;
		if (!args.searchfield) {
			args.searchfield = 'name';
		}

		frappe.call({
			method: "frappe.desk.search.search_widget",
			type: "GET",
			args: args,
			callback: function (r) {
				callback && callback(r);
			},
			btn: btn
		});
	};

	frappe.ui.form.MultiSelectDialog = class MultiSelectDialog {
		constructor(opts) {
			/* Options: doctype, target, setters, get_query, action, add_filters_group, data_fields, primary_action_label */
			Object.assign(this, opts);
			var me = this;
			if (this.doctype != "[Select]") {
				frappe.model.with_doctype(this.doctype, function () {
					me.make();
				});
			} else {
				this.make();
			}
		}

		make() {
			var this$1 = this;

			var me = this;
			this.page_length = 20;
			this.start = 0;
			var fields = this.get_primary_filters();

			// Make results area
			fields = fields.concat([
				{ fieldtype: "HTML", fieldname: "results_area" },
				{
					fieldtype: "Button", fieldname: "more_btn", label: __("More"),
					click: function () {
						this$1.start += 20;
						this$1.get_results();
					}
				}
			]);

			// Custom Data Fields
			if (this.data_fields) {
				fields.push({ fieldtype: "Section Break" });
				fields = fields.concat(this.data_fields);
			}

			var doctype_plural = this.doctype.plural();

			this.dialog = new frappe.ui.Dialog({
				title: __("Select {0}", [(this.doctype == '[Select]') ? __("value") : __(doctype_plural)]),
				fields: fields,
				primary_action_label: this.primary_action_label || __("Get Items"),
				secondary_action_label: __("Make {0}", [me.doctype]),
				primary_action: function () {
					var filters_data = me.get_custom_filters();
					me.action(me.get_checked_values(), cur_dialog.get_values(), me.args, filters_data);
				},
				secondary_action: function (e) {
					// If user wants to close the modal
					if (e) {
						frappe.route_options = {};
						if (Array.isArray(me.setters)) {
							for (var i = 0, list = me.setters; i < list.length; i += 1) {
								var df = list[i];

								frappe.route_options[df.fieldname] = me.dialog.fields_dict[df.fieldname].get_value() || undefined;
							}
						} else {
							Object.keys(me.setters).forEach(function (setter) {
								frappe.route_options[setter] = me.dialog.fields_dict[setter].get_value() || undefined;
							});
						}

						frappe.new_doc(me.doctype, true);
					}
				}
			});

			if (this.add_filters_group) {
				this.make_filter_area();
			}

			this.$parent = $(this.dialog.body);
			this.$wrapper = this.dialog.fields_dict.results_area.$wrapper.append("<div class=\"results\"\n\t\t\tstyle=\"border: 1px solid #d1d8dd; border-radius: 3px; height: 300px; overflow: auto;\"></div>");

			this.$results = this.$wrapper.find('.results');
			this.$results.append(this.make_list_row());

			this.args = {};

			this.bind_events();
			this.get_results();
			this.dialog.show();
		}

		get_primary_filters() {
			var this$1 = this;

			var fields = [];

			var columns = new Array(3);

			// Hack for three column layout
			// To add column break
			columns[0] = [
				{
					fieldtype: "Data",
					label: __("Search"),
					fieldname: "search_term"
				}
			];
			columns[1] = [];
			columns[2] = [];

			if ($.isArray(this.setters)) {
				this.setters.forEach(function (setter, index) {
					columns[(index + 1) % 3].push(setter);
				});
			} else {
				Object.keys(this.setters).forEach(function (setter, index) {
					var df_prop = frappe.meta.docfield_map[this$1.doctype][setter];

					// Index + 1 to start filling from index 1
					// Since Search is a standrd field already pushed
					columns[(index + 1) % 3].push({
						fieldtype: df_prop.fieldtype,
						label: df_prop.label,
						fieldname: setter,
						options: df_prop.options,
						default: this$1.setters[setter]
					});
				});
			}

			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal
			if (Object.seal) {
				Object.seal(columns);
				// now a is a fixed-size array with mutable entries
			}

			fields = columns[0].concat( [{ fieldtype: "Column Break" }],
				columns[1],
				[{ fieldtype: "Column Break" }],
				columns[2],
				[{ fieldtype: "Section Break", fieldname: "primary_filters_sb" }]
			);

			if (this.add_filters_group) {
				fields.push(
					{
						fieldtype: 'HTML',
						fieldname: 'filter_area',
					}
				);
			}

			return fields;
		}

		make_filter_area() {
			var this$1 = this;

			this.filter_group = new frappe.ui.FilterGroup({
				parent: this.dialog.get_field('filter_area').$wrapper,
				doctype: this.doctype,
				on_change: function () {
					this$1.get_results();
				}
			});
		}

		get_custom_filters() {
			if (this.add_filters_group && this.filter_group) {
				return this.filter_group.get_filters().reduce(function (acc, filter) {
					var obj;

					return Object.assign(acc, ( obj = {}, obj[filter[1]] = [filter[2], filter[3]], obj ));
				}, {});
			} else {
				return [];
			}
		}

		bind_events() {
			var this$1 = this;

			var me = this;

			this.$results.on('click', '.list-item-container', function (e) {
				if (!$(e.target).is(':checkbox') && !$(e.target).is('a')) {
					$(this).find(':checkbox').trigger('click');
				}
			});

			this.$results.on('click', '.list-item--head :checkbox', function (e) {
				this$1.$results.find('.list-item-container .list-row-check')
					.prop("checked", ($(e.target).is(':checked')));
			});

			this.$parent.find('.input-with-feedback').on('change', function () {
				frappe.flags.auto_scroll = false;
				this$1.get_results();
			});

			this.$parent.find('[data-fieldtype="Data"]').on('input', function () {
				var $this = $(this$1);
				clearTimeout($this.data('timeout'));
				$this.data('timeout', setTimeout(function () {
					frappe.flags.auto_scroll = false;
					me.empty_list();
					me.get_results();
				}, 300));
			});
		}

		get_checked_values() {
			// Return name of checked value.
			return this.$results.find('.list-item-container').map(function () {
				if ($(this).find('.list-row-check:checkbox:checked').length > 0) {
					return $(this).attr('data-item-name');
				}
			}).get();
		}

		get_checked_items() {
			// Return checked items with all the column values.
			var checked_values = this.get_checked_values();
			return this.results.filter(function (res) { return checked_values.includes(res.name); });
		}

		make_list_row(result) {
			if ( result === void 0 ) result = {};

			var me = this;
			// Make a head row by default (if result not passed)
			var head = Object.keys(result).length === 0;

			var contents = "";
			var columns = ["name"];

			if ($.isArray(this.setters)) {
				for (var i = 0, list = this.setters; i < list.length; i += 1) {
					var df = list[i];

					columns.push(df.fieldname);
				}
			} else {
				columns = columns.concat(Object.keys(this.setters));
			}

			columns.forEach(function (column) {
				contents += "<div class=\"list-item__content ellipsis\">\n\t\t\t\t" + (head ? ("<span class=\"ellipsis text-muted\" title=\"" + (__(frappe.model.unscrub(column))) + "\">" + (__(frappe.model.unscrub(column))) + "</span>")
			: (column !== "name" ? ("<span class=\"ellipsis result-row\" title=\"" + (__(result[column] || '')) + "\">" + (__(result[column] || '')) + "</span>")
				: ("<a href=\"" + ("#Form/" + me.doctype + "/" + result[column] || '') + "\" class=\"list-id ellipsis\" title=\"" + (__(result[column] || '')) + "\">\n\t\t\t\t\t\t\t" + (__(result[column] || '')) + "</a>"))) + "\n\t\t\t</div>";
			});

			var $row = $(("<div class=\"list-item\">\n\t\t\t<div class=\"list-item__content\" style=\"flex: 0 0 10px;\">\n\t\t\t\t<input type=\"checkbox\" class=\"list-row-check\" data-item-name=\"" + (result.name) + "\" " + (result.checked ? 'checked' : '') + ">\n\t\t\t</div>\n\t\t\t" + contents + "\n\t\t</div>"));

			head ? $row.addClass('list-item--head')
				: $row = $(("<div class=\"list-item-container\" data-item-name=\"" + (result.name) + "\"></div>")).append($row);

			$(".modal-dialog .list-item--head").css("z-index", 0);
			return $row;
		}

		render_result_list(results, more, empty) {
			if ( more === void 0 ) more = 0;
			if ( empty === void 0 ) empty = true;

			var me = this;
			var more_btn = me.dialog.fields_dict.more_btn.$wrapper;

			// Make empty result set if filter is set
			if (!frappe.flags.auto_scroll && empty) {
				this.empty_list();
			}
			more_btn.hide();

			if (results.length === 0) { return; }
			if (more) { more_btn.show(); }

			var checked = this.get_checked_values();

			results
				.filter(function (result) { return !checked.includes(result.name); })
				.forEach(function (result) {
					me.$results.append(me.make_list_row(result));
				});

			if (frappe.flags.auto_scroll) {
				this.$results.animate({ scrollTop: me.$results.prop('scrollHeight') }, 500);
			}
		}

		empty_list() {
			// Store all checked items
			var checked = this.get_checked_items().map(function (item) {
				return Object.assign({}, item,
					{checked: true});
			});

			// Remove **all** items
			this.$results.find('.list-item-container').remove();

			// Rerender checked items
			this.render_result_list(checked, 0, false);
		}

		get_results() {
			var me = this;
			var filters = this.get_query ? this.get_query().filters : {} || {};
			var filter_fields = [];

			if ($.isArray(this.setters)) {
				for (var i = 0, list = this.setters; i < list.length; i += 1) {
					var df = list[i];

					filters[df.fieldname] = me.dialog.fields_dict[df.fieldname].get_value() || undefined;
					me.args[df.fieldname] = filters[df.fieldname];
					filter_fields.push(df.fieldname);
				}
			} else {
				Object.keys(this.setters).forEach(function (setter) {
					var value = me.dialog.fields_dict[setter].get_value();
					if (me.dialog.fields_dict[setter].df.fieldtype == "Data" && value) {
						filters[setter] = ["like", "%" + value + "%"];
					} else {
						filters[setter] = value || undefined;
						me.args[setter] = filters[setter];
						filter_fields.push(setter);
					}
				});
			}

			var filter_group = this.get_custom_filters();
			Object.assign(filters, filter_group);

			var args = {
				doctype: me.doctype,
				txt: me.dialog.fields_dict["search_term"].get_value(),
				filters: filters,
				filter_fields: filter_fields,
				start: this.start,
				page_length: this.page_length + 1,
				query: this.get_query ? this.get_query().query : '',
				as_dict: 1
			};
			frappe.call({
				type: "GET",
				method: 'frappe.desk.search.search_widget',
				no_spinner: true,
				args: args,
				callback: function (r) {
					var more = 0;
					me.results = [];
					if (r.values.length) {
						if (r.values.length > me.page_length) {
							r.values.pop();
							more = 1;
						}
						r.values.forEach(function (result) {
							result.checked = 0;
							me.results.push(result);
						});
					}
					me.render_result_list(me.results, more);
				}
			});
		}
	};

	// frappe.ui.Capture
	// Author - Achilles Rasquinha <achilles@frappe.io>

	/**
	 * @description Converts a canvas, image or a video to a data URL string.
	 *
	 * @param 	{HTMLElement} element - canvas, img or video.
	 * @returns {string} 			  - The data URL string.
	 *
	 * @example
	 * frappe._.get_data_uri(video)
	 * // returns "data:image/pngbase64,..."
	 */
	frappe._.get_data_uri = function (element) {
		var $element = $(element);
		var width = $element.width();
		var height = $element.height();

		var $canvas = $('<canvas/>');
		$canvas[0].width = width;
		$canvas[0].height = height;

		var context = $canvas[0].getContext('2d');
		context.drawImage($element[0], 0, 0, width, height);

		var data_uri = $canvas[0].toDataURL('image/png');

		return data_uri;
	};

	/**
	 * @description Frappe's Capture object.
	 *
	 * @example
	 * const capture = frappe.ui.Capture()
	 * capture.show()
	 *
	 * capture.click((data_uri) => {
	 * 	// do stuff
	 * })
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Taking_still_photos
	 */
	frappe.ui.Capture = class {
		constructor(options) {
		if ( options === void 0 ) options = {};

			this.options = frappe.ui.Capture.OPTIONS;
			this.set_options(options);
		}

		set_options(options) {
			this.options = Object.assign({}, frappe.ui.Capture.OPTIONS, options);

			return this;
		}

		render() {
			var this$1 = this;

			return navigator.mediaDevices.getUserMedia({ video: true }).then(function (stream) {
				this$1.dialog = new frappe.ui.Dialog({
					title: this$1.options.title,
					animate: this$1.options.animate,
					action: {
						secondary: {
							label: '<b>&times</b>'
						}
					}
				});

				var $e = $(frappe.ui.Capture.TEMPLATE);

				var video = $e.find('video')[0];
				video.srcObject = stream;
				video.play();

				var $container = $(this$1.dialog.body);
				$container.html($e);

				$e.find('.fc-btf').hide();

				$e.find('.fc-bcp').click(function () {
					var data_url = frappe._.get_data_uri(video);
					$e.find('.fc-p').attr('src', data_url);

					$e.find('.fc-s').hide();
					$e.find('.fc-p').show();

					$e.find('.fc-btu').hide();
					$e.find('.fc-btf').show();
				});

				$e.find('.fc-br').click(function () {
					$e.find('.fc-p').hide();
					$e.find('.fc-s').show();

					$e.find('.fc-btf').hide();
					$e.find('.fc-btu').show();
				});

				$e.find('.fc-bs').click(function () {
					var data_url = frappe._.get_data_uri(video);
					this$1.hide();

					if (this$1.callback) { this$1.callback(data_url); }
				});
			});
		}

		show() {
			var this$1 = this;

			this.render()
				.then(function () {
					this$1.dialog.show();
				})
				.catch(function (err) {
					if (this$1.options.error) {
						var alert = "<span class=\"indicator red\"/> " + (frappe.ui.Capture.ERR_MESSAGE);
						frappe.show_alert(alert, 3);
					}

					throw err;
				});
		}

		hide() {
			if (this.dialog) { this.dialog.hide(); }
		}

		submit(fn) {
			this.callback = fn;
		}
	};
	frappe.ui.Capture.OPTIONS = {
		title: __("Camera"),
		animate: false,
		error: false
	};
	frappe.ui.Capture.ERR_MESSAGE = __('Unable to load camera.');
	frappe.ui.Capture.TEMPLATE = "\n<div class=\"frappe-capture\">\n\t<div class=\"panel panel-default\">\n\t\t<img class=\"fc-p img-responsive\"/>\n\t\t<div class=\"fc-s  embed-responsive embed-responsive-16by9\">\n\t\t\t<video class=\"embed-responsive-item\">" + (frappe.ui.Capture.ERR_MESSAGE) + "</video>\n\t\t</div>\n\t</div>\n\t<div>\n\t\t<div class=\"fc-btf\">\n\t\t\t<div class=\"row\">\n\t\t\t\t<div class=\"col-md-6\">\n\t\t\t\t\t<div class=\"pull-left\">\n\t\t\t\t\t\t<button class=\"btn btn-default fc-br\">\n\t\t\t\t\t\t\t<small>" + (__('Retake')) + "</small>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"col-md-6\">\n\t\t\t\t\t<div class=\"pull-right\">\n\t\t\t\t\t\t<button class=\"btn btn-primary fc-bs\">\n\t\t\t\t\t\t\t<small>" + (__('Submit')) + "</small>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"fc-btu\">\n\t\t\t<div class=\"row\">\n\t\t\t\t<div class=\"col-md-6\">\n\t\t\t\t\t" + ('') + "\n\t\t\t\t</div>\n\t\t\t\t<div class=\"col-md-6\">\n\t\t\t\t\t<div class=\"pull-right\">\n\t\t\t\t\t\t<button class=\"btn btn-default fc-bcp\">\n\t\t\t\t\t\t\t<small>" + (__('Take Photo')) + "</small>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n";

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt


	frappe.provide("frappe.ui");
	frappe.ui.app_icon = {
		get_html: function(module, small) {
			var icon = module.icon;
			var color = module.color;
			if (icon
				&& icon.match(/([\uE000-\uF8FF]|\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDDFF])/g)) {
				module.emoji = module.icon;
			}
			var icon_style = "";
			if(module.reverse) {
				icon_style = "color: #36414C;";
			}

			if(!color) {
				color = '#4aa3df';
			}

			// first letter
			if(!icon || module.emoji) {
				icon = '<span class="inner" ' +
					(module.reverse ? ('style="' + icon_style + '"') : '')
					+ '>' + (module.emoji || module._label[0].toUpperCase()) + '</span>';
			} else if(icon.split(".").slice(-1)[0]==="svg") {
				$.ajax({
					url: frappe.urllib.get_full_url(icon),
					dataType: "text",
					async: false,
					success: function(data) {
						icon = data;
					}
				});
				icon = '<object class="app-icon-svg">'+ icon+'</object>';
			} else {
				icon = '<i class="'+ icon+'" title="' + module._label + '" style="'+ icon_style + '"></i>';
			}

			return '<div class="app-icon'+ (small ? " app-icon-small" : "")
				+'" style="background-color: '+ color +'" title="'+ module._label +'">'+icon+'</div>';
		}
	};

	// DropZone
	frappe.ui.DropZone = class 
	{
		constructor (selector, options) {
			this.options    = Object.assign({ }, frappe.ui.DropZone.OPTIONS, options);
			this.$container = $(selector);
			this.$wrapper   = $(frappe.ui.DropZone.TEMPLATE);

			this.make();
		}

		make ( ) {
			var me        = this;
			var $dropzone = this.$wrapper.find('.panel-body');
			var $title    = $dropzone.find('.dropzone-title');
			$title.html(this.options.title);

			$dropzone.on('dragover', function (e) {
				e.preventDefault();

				$title.html(__('Drop'));
			});
			$dropzone.on('dragleave', function (e) {
				e.preventDefault();

				$title.html(me.options.title);
			});
			$dropzone.on('drop', function (e) {
				e.preventDefault();

				var files = e.originalEvent.dataTransfer.files;
				me.options.drop(files);

				$title.html(me.options.title);
			});

			this.$container.html(this.$wrapper);
		}
	};
	frappe.ui.DropZone.TEMPLATE =
	"\n<div class=\"panel panel-default\"\n\tstyle=\"\n\t\tborder: none !important;\n\t\tbox-shadow: none !important;\n\t\tmargin-bottom: 0 !important\n\t\">\n\t<div class=\"panel-body\">\n\t\t<div class=\"dropzone-title text-muted text-center\">\n\t\t</div>\n\t</div>\n</div>\n";
	frappe.ui.DropZone.OPTIONS  = 
	{
		title: __('Drop Here')
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.model');

	$.extend(frappe.model, {
		no_value_type: ['Section Break', 'Column Break', 'HTML', 'Table', 'Table MultiSelect',
			'Button', 'Image', 'Fold', 'Heading'],

		layout_fields: ['Section Break', 'Column Break', 'Fold'],

		std_fields_list: ['name', 'owner', 'creation', 'modified', 'modified_by',
			'_user_tags', '_comments', '_assign', '_liked_by', 'docstatus',
			'parent', 'parenttype', 'parentfield', 'idx'],

		core_doctypes_list: ['DocType', 'DocField', 'DocPerm', 'User', 'Role', 'Has Role',
			'Page', 'Module Def', 'Print Format', 'Report', 'Customize Form',
			'Customize Form Field', 'Property Setter', 'Custom Field', 'Custom Script'],

		std_fields: [
			{fieldname:'name', fieldtype:'Link', label:__('ID')},
			{fieldname:'owner', fieldtype:'Link', label:__('Created By'), options: 'User'},
			{fieldname:'idx', fieldtype:'Int', label:__('Index')},
			{fieldname:'creation', fieldtype:'Date', label:__('Created On')},
			{fieldname:'modified', fieldtype:'Date', label:__('Last Updated On')},
			{fieldname:'modified_by', fieldtype:'Data', label:__('Last Updated By')},
			{fieldname:'_user_tags', fieldtype:'Data', label:__('Tags')},
			{fieldname:'_liked_by', fieldtype:'Data', label:__('Liked By')},
			{fieldname:'_comments', fieldtype:'Text', label:__('Comments')},
			{fieldname:'_assign', fieldtype:'Text', label:__('Assigned To')},
			{fieldname:'docstatus', fieldtype:'Int', label:__('Document Status')} ],

		numeric_fieldtypes: ["Int", "Float", "Currency", "Percent", "Duration"],

		std_fields_table: [
			{fieldname:'parent', fieldtype:'Data', label:__('Parent')} ],

		table_fields: ['Table', 'Table MultiSelect'],

		new_names: {},
		events: {},
		user_settings: {},

		init: function() {
			// setup refresh if the document is updated somewhere else
			frappe.realtime.on("doc_update", function(data) {
				// set list dirty
				frappe.views.ListView.trigger_list_update(data);
				var doc = locals[data.doctype] && locals[data.doctype][data.name];

				if(doc) {
					// current document is dirty, show message if its not me
					if(frappe.get_route()[0]==="Form" && cur_frm.doc.doctype===doc.doctype && cur_frm.doc.name===doc.name) {
						if(!frappe.ui.form.is_saving && data.modified!=cur_frm.doc.modified) {
							doc.__needs_refresh = true;
							cur_frm.check_doctype_conflict();
						}
					} else {
						if(!doc.__unsaved) {
							// no local changes, remove from locals
							frappe.model.remove_from_locals(doc.doctype, doc.name);
						} else {
							// show message when user navigates back
							doc.__needs_refresh = true;
						}
					}
				}
			});

			frappe.realtime.on("list_update", function(data) {
				frappe.views.ListView.trigger_list_update(data);
			});

		},

		is_value_type: function(fieldtype) {
			if (typeof fieldtype == 'object') {
				fieldtype = fieldtype.fieldtype;
			}
			// not in no-value type
			return frappe.model.no_value_type.indexOf(fieldtype)===-1;
		},

		is_non_std_field: function(fieldname) {
			return !frappe.model.std_fields_list.includes(fieldname);
		},

		get_std_field: function(fieldname, ignore) {
			if ( ignore === void 0 ) ignore=false;

			var docfield = $.map([].concat(frappe.model.std_fields).concat(frappe.model.std_fields_table),
				function(d) {
					if(d.fieldname==fieldname) { return d; }
				});
			if (!docfield.length) {
				//Standard fields are ignored in case of adding columns as a result of groupby
				if (ignore) {
					return {fieldname: fieldname};
				} else {
					frappe.msgprint(__("Unknown Column: {0}", [fieldname]));
				}
			}
			return docfield[0];
		},

		with_doctype: function(doctype, callback, async) {
			if(locals.DocType[doctype]) {
				callback && callback();
			} else {
				var cached_timestamp = null;
				var cached_doc = null;

				if(localStorage["_doctype:" + doctype]) {
					var cached_docs = JSON.parse(localStorage["_doctype:" + doctype]);
					cached_doc = cached_docs.filter(function (doc) { return doc.name === doctype; })[0];
					if(cached_doc) {
						cached_timestamp = cached_doc.modified;
					}
				}
				return frappe.call({
					method:'frappe.desk.form.load.getdoctype',
					type: "GET",
					args: {
						doctype: doctype,
						with_parent: 1,
						cached_timestamp: cached_timestamp
					},
					async: async,
					callback: function(r) {
						if(r.exc) {
							frappe.msgprint(__("Unable to load: {0}", [__(doctype)]));
							throw "No doctype";
						}
						if(r.message=="use_cache") {
							frappe.model.sync(cached_doc);
						} else {
							localStorage["_doctype:" + doctype] = JSON.stringify(r.docs);
						}
						frappe.model.init_doctype(doctype);

						if(r.user_settings) {
							// remember filters and other settings from last view
							frappe.model.user_settings[doctype] = JSON.parse(r.user_settings);
							frappe.model.user_settings[doctype].updated_on = moment().toString();
						}
						callback && callback(r);
					}
				});
			}
		},

		init_doctype: function(doctype) {
			var meta = locals.DocType[doctype];
			if(meta.__list_js) {
				eval(meta.__list_js);
			}
			if(meta.__calendar_js) {
				eval(meta.__calendar_js);
			}
			if(meta.__map_js) {
				eval(meta.__map_js);
			}
			if(meta.__tree_js) {
				eval(meta.__tree_js);
			}
			if(meta.__templates) {
				$.extend(frappe.templates, meta.__templates);
			}
		},

		with_doc: function(doctype, name, callback) {
			return new Promise(function (resolve) {
				if(!name) { name = doctype; } // single type
				if(locals[doctype] && locals[doctype][name] && frappe.model.get_docinfo(doctype, name)) {
					callback && callback(name);
					resolve(frappe.get_doc(doctype, name));
				} else {
					return frappe.call({
						method: 'frappe.desk.form.load.getdoc',
						type: "GET",
						args: {
							doctype: doctype,
							name: name
						},
						callback: function(r) {
							callback && callback(name, r);
							resolve(frappe.get_doc(doctype, name));
						}
					});
				}
			});
		},

		get_docinfo: function(doctype, name) {
			return frappe.model.docinfo[doctype] && frappe.model.docinfo[doctype][name] || null;
		},

		set_docinfo: function(doctype, name, key, value) {
			if (frappe.model.docinfo[doctype] && frappe.model.docinfo[doctype][name]) {
				frappe.model.docinfo[doctype][name][key] = value;
			}
		},

		get_shared: function(doctype, name) {
			return frappe.model.get_docinfo(doctype, name).shared;
		},

		get_server_module_name: function(doctype) {
			var dt = frappe.model.scrub(doctype);
			var module = frappe.model.scrub(locals.DocType[doctype].module);
			var app = frappe.boot.module_app[module];
			return app + "." + module + '.doctype.' + dt + '.' + dt;
		},

		scrub: function(txt) {
			return txt.replace(/ /g, "_").toLowerCase();  // use to slugify or create a slug, a "code-friendly" string
		},

		unscrub: function(txt) {
			return __(txt || '').replace(/-|_/g, " ").replace(/\w*/g,
	            function(keywords){return keywords.charAt(0).toUpperCase() + keywords.substr(1).toLowerCase();});
		},

		can_create: function(doctype) {
			return frappe.boot.user.can_create.indexOf(doctype)!==-1;
		},

		can_read: function(doctype) {
			return frappe.boot.user.can_read.indexOf(doctype)!==-1;
		},

		can_write: function(doctype) {
			return frappe.boot.user.can_write.indexOf(doctype)!==-1;
		},

		can_get_report: function(doctype) {
			return frappe.boot.user.can_get_report.indexOf(doctype)!==-1;
		},

		can_delete: function(doctype) {
			if(!doctype) { return false; }
			return frappe.boot.user.can_delete.indexOf(doctype)!==-1;
		},

		can_cancel: function(doctype) {
			if(!doctype) { return false; }
			return frappe.boot.user.can_cancel.indexOf(doctype)!==-1;
		},

		has_workflow: function(doctype) {
			return frappe.get_list('Workflow', {'document_type': doctype,
				'is_active': 1}).length;
		},

		is_submittable: function(doctype) {
			if(!doctype) { return false; }
			return locals.DocType[doctype]
				&& locals.DocType[doctype].is_submittable;
		},

		is_table: function(doctype) {
			if(!doctype) { return false; }
			return locals.DocType[doctype] && locals.DocType[doctype].istable;
		},

		is_single: function(doctype) {
			if(!doctype) { return false; }
			return frappe.boot.single_types.indexOf(doctype) != -1;
		},

		is_tree: function(doctype) {
			if (!doctype) { return false; }
			return frappe.boot.treeviews.indexOf(doctype) != -1;
		},

		can_import: function(doctype, frm) {
			// system manager can always import
			if(frappe.user_roles.includes("System Manager")) { return true; }

			if(frm) { return frm.perm[0].import===1; }
			return frappe.boot.user.can_import.indexOf(doctype)!==-1;
		},

		can_export: function(doctype, frm) {
			// system manager can always export
			if(frappe.user_roles.includes("System Manager")) { return true; }

			if(frm) { return frm.perm[0].export===1; }
			return frappe.boot.user.can_export.indexOf(doctype)!==-1;
		},

		can_print: function(doctype, frm) {
			if(frm) { return frm.perm[0].print===1; }
			return frappe.boot.user.can_print.indexOf(doctype)!==-1;
		},

		can_email: function(doctype, frm) {
			if(frm) { return frm.perm[0].email===1; }
			return frappe.boot.user.can_email.indexOf(doctype)!==-1;
		},

		can_share: function(doctype, frm) {
			if(frm) {
				return frm.perm[0].share===1;
			}
			return frappe.boot.user.can_share.indexOf(doctype)!==-1;
		},

		can_set_user_permissions: function(doctype, frm) {
			// system manager can always set user permissions
			if(frappe.user_roles.includes("System Manager")) { return true; }

			if(frm) { return frm.perm[0].set_user_permissions===1; }
			return frappe.boot.user.can_set_user_permissions.indexOf(doctype)!==-1;
		},

		has_value: function(dt, dn, fn) {
			// return true if property has value
			var val = locals[dt] && locals[dt][dn] && locals[dt][dn][fn];
			var df = frappe.meta.get_docfield(dt, fn, dn);

			if(frappe.model.table_fields.includes(df.fieldtype)) {
				var ret = false;
				$.each(locals[df.options] || {}, function(k,d) {
					if(d.parent==dn && d.parenttype==dt && d.parentfield==df.fieldname) {
						ret = true;
						return false;
					}
				});
			} else {
				var ret = !is_null(val);
			}
			return ret ? true : false;
		},

		get_list: function(doctype, filters) {
			var docsdict = locals[doctype] || locals[":" + doctype] || {};
			if($.isEmptyObject(docsdict))
				{ return []; }
			return frappe.utils.filter_dict(docsdict, filters);
		},

		get_value: function(doctype, filters, fieldname, callback) {
			if(callback) {
				frappe.call({
					method:"frappe.client.get_value",
					args: {
						doctype: doctype,
						fieldname: fieldname,
						filters: filters
					},
					callback: function(r) {
						if(!r.exc) {
							callback(r.message);
						}
					}
				});
			} else {
				if(typeof filters==="string" && locals[doctype] && locals[doctype][filters]) {
					return locals[doctype][filters][fieldname];
				} else {
					var l = frappe.get_list(doctype, filters);
					return (l.length && l[0]) ? l[0][fieldname] : null;
				}
			}
		},

		set_value: function(doctype, docname, fieldname, value, fieldtype) {
			/* help: Set a value locally (if changed) and execute triggers */

			var doc;
			if ($.isPlainObject(doctype)) {
				// first parameter is the doc, shift parameters to the left
				doc = doctype; fieldname = docname; value = fieldname;
			} else {
				doc = locals[doctype] && locals[doctype][docname];
			}

			var to_update = fieldname;
			var tasks = [];
			if(!$.isPlainObject(to_update)) {
				to_update = {};
				to_update[fieldname] = value;
			}

			$.each(to_update, function (key, value) {
				if (doc && doc[key] !== value) {
					if(doc.__unedited && !(!doc[key] && !value)) {
						// unset unedited flag for virgin rows
						doc.__unedited = false;
					}

					doc[key] = value;
					tasks.push(function () { return frappe.model.trigger(key, value, doc); });
				} else {
					// execute link triggers (want to reselect to execute triggers)
					if(in_list(["Link", "Dynamic Link"], fieldtype) && doc) {
						tasks.push(function () { return frappe.model.trigger(key, value, doc); });
					}
				}
			});

			return frappe.run_serially(tasks);
		},

		on: function(doctype, fieldname, fn) {
			/* help: Attach a trigger on change of a particular field.
			To trigger on any change in a particular doctype, use fieldname as "*"
			*/
			/* example: frappe.model.on("Customer", "age", function(fieldname, value, doc) {
			  if(doc.age < 16) {
			   	frappe.msgprint("Warning, Customer must atleast be 16 years old.");
			    raise "CustomerAgeError";
			  }
			}) */
			frappe.provide("frappe.model.events." + doctype);
			if(!frappe.model.events[doctype][fieldname]) {
				frappe.model.events[doctype][fieldname] = [];
			}
			frappe.model.events[doctype][fieldname].push(fn);
		},

		trigger: function(fieldname, value, doc) {
			var tasks = [];
			var runner = function(events, event_doc) {
				$.each(events || [], function(i, fn) {
					if(fn) {
						var _promise = fn(fieldname, value, event_doc || doc);

						// if the trigger returns a promise, return it,
						// or use the default promise frappe.after_ajax
						if (_promise && _promise.then) {
							return _promise;
						} else {
							return frappe.after_server_call();
						}
					}
				});
			};

			if(frappe.model.events[doc.doctype]) {
				tasks.push(function () {
					return runner(frappe.model.events[doc.doctype][fieldname]);
				});

				tasks.push(function () {
					return runner(frappe.model.events[doc.doctype]['*']);
				});
			}

			return frappe.run_serially(tasks);
		},

		get_doc: function(doctype, name) {
			if(!name) { name = doctype; }
			if($.isPlainObject(name)) {
				var doc = frappe.get_list(doctype, name);
				return doc && doc.length ? doc[0] : null;
			}
			return locals[doctype] ? locals[doctype][name] : null;
		},

		get_children: function(doctype, parent, parentfield, filters) {
			if($.isPlainObject(doctype)) {
				var doc = doctype;
				var filters = parentfield;
				var parentfield = parent;
			} else {
				var doc = frappe.get_doc(doctype, parent);
			}

			var children = doc[parentfield] || [];
			if(filters) {
				return frappe.utils.filter_dict(children, filters);
			} else {
				return children;
			}
		},

		clear_table: function(doc, parentfield) {
			for (var i=0, l=(doc[parentfield] || []).length; i<l; i++) {
				var d = doc[parentfield][i];
				delete locals[d.doctype][d.name];
			}
			doc[parentfield] = [];
		},

		remove_from_locals: function(doctype, name) {
			this.clear_doc(doctype, name);
			if(frappe.views.formview[doctype]) {
				delete frappe.views.formview[doctype].frm.opendocs[name];
			}
		},

		clear_doc: function(doctype, name) {
			var doc = locals[doctype] && locals[doctype][name];
			if(!doc) { return; }

			var parent = null;
			if(doc.parenttype) {
				var parent = doc.parent,
					parenttype = doc.parenttype,
					parentfield = doc.parentfield;
			}
			delete locals[doctype][name];
			if(parent) {
				var parent_doc = locals[parenttype][parent];
				var newlist = [], idx = 1;
				$.each(parent_doc[parentfield], function(i, d) {
					if(d.name!=name) {
						newlist.push(d);
						d.idx = idx;
						idx++;
					}
					parent_doc[parentfield] = newlist;
				});
			}
		},

		get_no_copy_list: function(doctype) {
			var no_copy_list = ['name','amended_from','amendment_date','cancel_reason'];

			var docfields = frappe.get_doc("DocType", doctype).fields || [];
			for(var i=0, j=docfields.length; i<j; i++) {
				var df = docfields[i];
				if(cint(df.no_copy)) { no_copy_list.push(df.fieldname); }
			}

			return no_copy_list;
		},

		delete_doc: function(doctype, docname, callback) {
			var title = docname;
			var title_field = frappe.get_meta(doctype).title_field;
			if (frappe.get_meta(doctype).autoname == "hash" && title_field) {
				var title = frappe.model.get_value(doctype, docname, title_field);
				title += " (" + docname + ")";
			}
			frappe.confirm(__("Permanently delete {0}?", [title]), function() {
				return frappe.call({
					method: 'frappe.client.delete',
					args: {
						doctype: doctype,
						name: docname
					},
					callback: function(r, rt) {
						if(!r.exc) {
							frappe.utils.play_sound("delete");
							frappe.model.clear_doc(doctype, docname);
							if(callback) { callback(r,rt); }
						}
					}
				})
			});
		},

		rename_doc: function(doctype, docname, callback) {
				var message = __("Merge with existing");
				var warning = __("This cannot be undone");
				var merge_label = message + " <b>(" + warning + ")</b>";

			var d = new frappe.ui.Dialog({
				title: __("Rename {0}", [__(docname)]),
				fields: [
					{label: __("New Name"), fieldname: "new_name", fieldtype: "Data", reqd: 1, "default": docname},
					{label: merge_label, fieldtype: "Check", fieldname: "merge"} ]
			});

			d.set_primary_action(__("Rename"), function() {
				var args = d.get_values();
				if(!args) { return; }
				return frappe.call({
					method:"frappe.rename_doc",
					args: {
						doctype: doctype,
						old: docname,
						new: args.new_name,
						merge: args.merge
					},
					btn: d.get_primary_btn(),
					callback: function(r,rt) {
						if(!r.exc) {
							$(document).trigger('rename', [doctype, docname,
								r.message || args.new_name]);
							if(locals[doctype] && locals[doctype][docname])
								{ delete locals[doctype][docname]; }
							d.hide();
							if(callback)
								{ callback(r.message); }
						}
					}
				});
			});
			d.show();
		},

		round_floats_in: function(doc, fieldnames) {
			if(!fieldnames) {
				fieldnames = frappe.meta.get_fieldnames(doc.doctype, doc.parent,
					{"fieldtype": ["in", ["Currency", "Float"]]});
			}
			for(var i=0, j=fieldnames.length; i < j; i++) {
				var fieldname = fieldnames[i];
				doc[fieldname] = flt(doc[fieldname], precision(fieldname, doc));
			}
		},

		validate_missing: function(doc, fieldname) {
			if(!doc[fieldname]) {
				frappe.throw(__("Please specify") + ": " +
					__(frappe.meta.get_label(doc.doctype, fieldname, doc.parent || doc.name)));
			}
		},

		get_all_docs: function(doc) {
			var all = [doc];
			for(var key in doc) {
				if($.isArray(doc[key])) {
					var children = doc[key];
					for (var i=0, l=children.length; i < l; i++) {
						all.push(children[i]);
					}
				}
			}
			return all;
		},

		get_full_column_name: function(fieldname, doctype) {
			if (fieldname.includes('`tab')) { return fieldname; }
			return '`tab' + doctype + '`.`' + fieldname + '`';
		},

		is_numeric_field: function(fieldtype) {
			if (!fieldtype) { return; }
			if (typeof fieldtype === 'object') {
				fieldtype = fieldtype.fieldtype;
			}
			return frappe.model.numeric_fieldtypes.includes(fieldtype);
		}
	});

	// legacy
	frappe.get_doc = frappe.model.get_doc;
	frappe.get_children = frappe.model.get_children;
	frappe.get_list = frappe.model.get_list;

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.db = {
		get_list: function(doctype, args) {
			if (!args) {
				args = {};
			}
			args.doctype = doctype;
			if (!args.fields) {
				args.fields = ['name'];
			}
			if (!args.limit) {
				args.limit = 20;
			}
			return new Promise (function (resolve) {
				frappe.call({
					method: 'frappe.model.db_query.get_list',
					args: args,
					type: 'GET',
					callback: function(r) {
						resolve(r.message);
					}
				});
			});
		},
		exists: function(doctype, name) {
			return new Promise (function (resolve) {
				frappe.db.get_value(doctype, {name: name}, 'name').then(function (r) {
					(r.message && r.message.name) ? resolve(true) : resolve(false);
				});
			});
		},
		get_value: function(doctype, filters, fieldname, callback, parent_doc) {
			return frappe.call({
				method: "frappe.client.get_value",
				type: 'GET',
				args: {
					doctype: doctype,
					fieldname: fieldname,
					filters: filters,
					parent: parent_doc
				},
				callback: function(r) {
					callback && callback(r.message);
				}
			});
		},
		get_single_value: function (doctype, field) {
			return new Promise(function (resolve) {
				frappe.call({
					method: 'frappe.client.get_single_value',
					args: { doctype: doctype, field: field },
					type: 'GET',
				}).then(function (r) { return resolve(r ? r.message : null); });
			});
		},
		set_value: function(doctype, docname, fieldname, value, callback) {
			return frappe.call({
				method: "frappe.client.set_value",
				args: {
					doctype: doctype,
					name: docname,
					fieldname: fieldname,
					value: value
				},
				callback: function(r) {
					callback && callback(r.message);
				}
			});
		},
		get_doc: function(doctype, name, filters) {
			if ( filters === void 0 ) filters = null;

			return new Promise(function (resolve, reject) {
				frappe.call({
					method: "frappe.client.get",
					type: 'GET',
					args: { doctype: doctype, name: name, filters: filters },
					callback: function (r) {
						frappe.model.sync(r.message);
						resolve(r.message);
					}
				}).fail(reject);
			});
		},
		insert: function(doc) {
			return frappe.xcall('frappe.client.insert', { doc: doc });
		},
		delete_doc: function(doctype, name) {
			return new Promise(function (resolve) {
				frappe.call('frappe.client.delete', { doctype: doctype, name: name }, function (r) { return resolve(r.message); });
			});
		},
		count: function(doctype, args) {
			if ( args === void 0 ) args={};

			var filters = args.filters || {};
			var with_child_table_filter = Array.isArray(filters) && filters.some(function (filter) {
				return filter[0] !== doctype;
			});

			var fields = [
				// cannot break this line as it adds extra \n's and \t's which breaks the query
				("count(" + (with_child_table_filter ? 'distinct': '') + " " + (frappe.model.get_full_column_name('name', doctype)) + ") AS total_count")
			];

			return frappe.call({
				type: 'GET',
				method: 'frappe.desk.reportview.get',
				args: {
					doctype: doctype,
					filters: filters,
					fields: fields,
				}
			}).then(function (r) {
				return r.message.values[0][0];
			});
		},
		get_link_options: function get_link_options(doctype, txt, filters) {
			if ( txt === void 0 ) txt = '';
			if ( filters === void 0 ) filters={};

			return new Promise(function (resolve) {
				frappe.call({
					type: 'GET',
					method: 'frappe.desk.search.search_link',
					args: {
						doctype: doctype,
						txt: txt,
						filters: filters
					},
					callback: function callback(r) {
						resolve(r.results);
					}
				});
			});
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.meta.docfield_map');
	frappe.provide('frappe.meta.docfield_copy');
	frappe.provide('frappe.meta.docfield_list');
	frappe.provide('frappe.meta.doctypes');
	frappe.provide("frappe.meta.precision_map");

	frappe.get_meta = function(doctype) {
		return locals['DocType'] ? locals['DocType'][doctype] : null;
	};

	$.extend(frappe.meta, {
		sync: function(doc) {
			$.each(doc.fields, function(i, df) {
				frappe.meta.add_field(df);
			});
			frappe.meta.sync_messages(doc);
			if(doc.__print_formats) { frappe.model.sync(doc.__print_formats); }
			if(doc.__workflow_docs) { frappe.model.sync(doc.__workflow_docs); }
		},

		// build docfield_map and docfield_list
		add_field: function(df) {
			frappe.provide('frappe.meta.docfield_map.' + df.parent);
			frappe.meta.docfield_map[df.parent][df.fieldname || df.label] = df;

			if(!frappe.meta.docfield_list[df.parent])
				{ frappe.meta.docfield_list[df.parent] = []; }

			// check for repeat
			for(var i in frappe.meta.docfield_list[df.parent]) {
				var d = frappe.meta.docfield_list[df.parent][i];
				if(df.fieldname==d.fieldname)
					{ return; } // no repeat
			}
			frappe.meta.docfield_list[df.parent].push(df);
		},

		make_docfield_copy_for: function(doctype, docname) {
			var c = frappe.meta.docfield_copy;
			if(!c[doctype])
				{ c[doctype] = {}; }
			if(!c[doctype][docname])
				{ c[doctype][docname] = {}; }

			var docfield_list = frappe.meta.docfield_list[doctype] || [];
			for(var i=0, j=docfield_list.length; i<j; i++) {
				var df = docfield_list[i];
				c[doctype][docname][df.fieldname || df.label] = copy_dict(df);
			}
		},

		get_field: function(doctype, fieldname, name) {
			var out = frappe.meta.get_docfield(doctype, fieldname, name);

			// search in standard fields
			if (!out) {
				frappe.model.std_fields.every(function(d) {
					if(d.fieldname===fieldname) {
						out = d;
						return false;
					} else {
						return true;
					}
				});
			}
			return out;
		},

		get_docfield: function(doctype, fieldname, name) {
			var fields_dict = frappe.meta.get_docfield_copy(doctype, name);
			return fields_dict ? fields_dict[fieldname] : null;
		},

		set_formatter: function(doctype, fieldname, name, formatter) {
			frappe.meta.get_docfield(doctype, fieldname, name).formatter = formatter;
		},

		set_indicator_formatter: function(doctype, fieldname, name, get_text, get_color) {
			frappe.meta.get_docfield(doctype, fieldname, name).formatter =
				function(value, df, options, doc) {
					return repl('<span class="indicator %(color)s">%(name)s</span>', {
						color: get_color(),
						name: get_text()
					});
				};
		},

		get_docfields: function(doctype, name, filters) {
			var docfield_map = frappe.meta.get_docfield_copy(doctype, name);

			var docfields = frappe.meta.sort_docfields(docfield_map);

			if(filters) {
				docfields = frappe.utils.filter_dict(docfields, filters);
			}

			return docfields;
		},

		get_linked_fields: function(doctype) {
			return $.map(frappe.get_meta(doctype).fields,
				function(d) { return d.fieldtype=="Link" ? d.options : null; });
		},

		get_fields_to_check_permissions: function(doctype) {
			var fields = $.map(frappe.meta.get_docfields(doctype, name), function(df) {
				return (df.fieldtype==="Link" && df.ignore_user_permissions!==1) ? df : null;
			});
			fields = fields.concat({label: "Name", fieldname: name, options: doctype});
			return fields;
		},

		sort_docfields: function(docs) {
			return $.map(docs, function(d) { return d; }).sort(function(a, b) { return a.idx - b.idx });
		},

		get_docfield_copy: function(doctype, name) {
			if(!name) { return frappe.meta.docfield_map[doctype]; }

			if(!(frappe.meta.docfield_copy[doctype] && frappe.meta.docfield_copy[doctype][name])) {
				frappe.meta.make_docfield_copy_for(doctype, name);
			}

			return frappe.meta.docfield_copy[doctype][name];
		},

		get_fieldnames: function(doctype, name, filters) {
			return $.map(frappe.utils.filter_dict(frappe.meta.docfield_map[doctype], filters),
				function(df) { return df.fieldname; });
		},

		has_field: function(dt, fn) {
			var docfield_map = frappe.meta.docfield_map[dt];
			return docfield_map && docfield_map[fn];
		},

		get_table_fields: function(dt) {
			return $.map(frappe.meta.docfield_list[dt], function(d) {
				return frappe.model.table_fields.includes(d.fieldtype) ? d : null});
		},

		get_doctype_for_field: function(doctype, key) {
			var out = null;
			if(in_list(frappe.model.std_fields_list, key)) {
				// standard
				out = doctype;
			} else if(frappe.meta.has_field(doctype, key)) {
				// found in parent
				out = doctype;
			} else {
				frappe.meta.get_table_fields(doctype).every(function(d) {
					if(frappe.meta.has_field(d.options, key)) {
						out = d.options;
						return false;
					}
					return true;
				});

				if(!out) {
					// eslint-disable-next-line
					console.log(__('Warning: Unable to find {0} in any table related to {1}', [key, __(doctype)]));
				}
			}
			return out;
		},

		get_parentfield: function(parent_dt, child_dt) {
			var df = (frappe.get_doc("DocType", parent_dt).fields || [])
				.filter(function (df) { return frappe.model.table_fields.includes(df.fieldtype) && df.options===child_dt; });
			if(!df.length)
				{ throw "parentfield not found for " + parent_dt + ", " + child_dt; }
			return df[0].fieldname;
		},

		get_label: function(dt, fn, dn) {
			var standard = {
				'owner': __('Owner'),
				'creation': __('Created On'),
				'modified': __('Last Modified On'),
				'idx': __('Idx'),
				'name': __('Name'),
				'modified_by': __('Last Modified By')
			};
			if(standard[fn]) {
				return standard[fn];
			} else {
				var df = this.get_docfield(dt, fn, dn);
				return (df ? df.label : "") || fn;
			}
		},

		get_print_formats: function(doctype) {
			var print_format_list = ["Standard"];
			var default_print_format = locals.DocType[doctype].default_print_format;
			var enable_raw_printing = frappe.model.get_doc(":Print Settings", "Print Settings").enable_raw_printing;
			var print_formats = frappe.get_list("Print Format", {doc_type: doctype})
				.sort(function(a, b) { return (a > b) ? 1 : -1; });
			$.each(print_formats, function(i, d) {
				if (
					!in_list(print_format_list, d.name)
					&& d.print_format_type !== 'JS'
					&& (cint(enable_raw_printing) || !d.raw_printing)
				) {
					print_format_list.push(d.name);
				}
			});

			if(default_print_format && default_print_format != "Standard") {
				var index = print_format_list.indexOf(default_print_format);
				print_format_list.splice(index, 1).sort();
				print_format_list.unshift(default_print_format);
			}

			return print_format_list;
		},

		sync_messages: function(doc) {
			if(doc.__messages) {
				$.extend(frappe._messages, doc.__messages);
			}
		},

		get_field_currency: function(df, doc) {
			var currency = frappe.boot.sysdefaults.currency;
			if(!doc && cur_frm)
				{ doc = cur_frm.doc; }

			if(df && df.options) {
				if(doc && df.options.indexOf(":")!=-1) {
					var options = df.options.split(":");
					if(options.length==3) {
						// get reference record e.g. Company
						var docname = doc[options[1]];
						if(!docname && cur_frm) {
							docname = cur_frm.doc[options[1]];
						}
						currency = frappe.model.get_value(options[0], docname, options[2]) ||
							frappe.model.get_value(":" + options[0], docname, options[2]) ||
							currency;
					}
				} else if(doc && doc[df.options]) {
					currency = doc[df.options];
				} else if(cur_frm && cur_frm.doc[df.options]) {
					currency = cur_frm.doc[df.options];
				}
			}
			return currency;
		},

		get_field_precision: function(df, doc) {
			var precision = null;
			if (df && df.precision) {
				precision = cint(df.precision);
			} else if(df && df.fieldtype === "Currency") {
				precision = cint(frappe.defaults.get_default("currency_precision"));
				if(!precision) {
					var number_format = get_number_format();
					var number_format_info = get_number_format_info(number_format);
					precision = number_format_info.precision;
				}
			} else {
				precision = cint(frappe.defaults.get_default("float_precision")) || 3;
			}
			return precision;
		}
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	$.extend(frappe.model, {
		docinfo: {},
		sync: function(r) {
			/* docs:
				extract docs, docinfo (attachments, comments, assignments)
				from incoming request and set in `locals` and `frappe.model.docinfo`
			*/
			var isPlain;
			if(!r.docs && !r.docinfo) { r = {docs:r}; }

			isPlain = $.isPlainObject(r.docs);
			if(isPlain) { r.docs = [r.docs]; }

			if(r.docs) {

				for(var i=0, l=r.docs.length; i<l; i++) {
					var d = r.docs[i];

					if (locals[d.doctype] && locals[d.doctype][d.name]) {
						// update values
						frappe.model.update_in_locals(d);
					} else {
						frappe.model.add_to_locals(d);
					}

					d.__last_sync_on = new Date();

					if(d.doctype==="DocType") {
						frappe.meta.sync(d);
					}

					if(d.localname) {
						frappe.model.new_names[d.localname] = d.name;
						$(document).trigger('rename', [d.doctype, d.localname, d.name]);
						delete locals[d.doctype][d.localname];

						// update docinfo to new dict keys
						if(i===0) {
							frappe.model.docinfo[d.doctype][d.name] = frappe.model.docinfo[d.doctype][d.localname];
							frappe.model.docinfo[d.doctype][d.localname] = undefined;
						}
					}
				}



			}

			// set docinfo (comments, assign, attachments)
			if(r.docinfo) {
				var doc;
				if(r.docs) {
					doc = r.docs[0];
				} else {
					if(cur_frm) { doc = cur_frm.doc; }
				}
				if(doc) {
					if(!frappe.model.docinfo[doc.doctype])
						{ frappe.model.docinfo[doc.doctype] = {}; }
					frappe.model.docinfo[doc.doctype][doc.name] = r.docinfo;
				}
			}

			return r.docs;
		},
		add_to_locals: function(doc) {
			if(!locals[doc.doctype])
				{ locals[doc.doctype] = {}; }

			if(!doc.name && doc.__islocal) { // get name (local if required)
				if(!doc.parentfield) { frappe.model.clear_doc(doc); }

				doc.name = frappe.model.get_new_name(doc.doctype);

				if(!doc.parentfield) { frappe.provide("frappe.model.docinfo." + doc.doctype + "." + doc.name); }
			}

			locals[doc.doctype][doc.name] = doc;

			var meta = frappe.get_meta(doc.doctype);
			var is_table = meta ? meta.istable : doc.parentfield;
			// add child docs to locals
			if (!is_table) {
				for(var i in doc) {
					var value = doc[i];

					if($.isArray(value)) {
						for (var x=0, y=value.length; x < y; x++) {
							var d = value[x];

							if(typeof d=='object' && !d.parent)
								{ d.parent = doc.name; }

							frappe.model.add_to_locals(d);
						}
					}
				}
			}
		},
		update_in_locals: function(doc) {
			// update values in the existing local doc instead of replacing
			var local_doc = locals[doc.doctype][doc.name];
			var clear_keys = function(source, target) {
				Object.keys(target).map(function (key) {
					if (source[key] == undefined) { delete target[key]; }
				});
			};

			for (var fieldname in doc) {
				var df = frappe.meta.get_field(doc.doctype, fieldname);
				if (df && frappe.model.table_fields.includes(df.fieldtype)) {
					// table
					if (!(doc[fieldname] instanceof Array)) {
						doc[fieldname] = [];
					}

					if (!(local_doc[fieldname] instanceof Array)) {
						local_doc[fieldname] = [];
					}

					// child table, override each row and append new rows if required
					for (var i=0; i < doc[fieldname].length; i++ ) {
						var d = doc[fieldname][i];
						var local_d = local_doc[fieldname][i];
						if (local_d) {
							// deleted and added again
							if (!locals[d.doctype]) { locals[d.doctype] = {}; }

							if (!d.name) {
								// incoming row is new, find a new name
								d.name = frappe.model.get_new_name(doc.doctype);
							}

							// if incoming row is not registered, register it
							if (!locals[d.doctype][d.name]) {
								// detach old key
								delete locals[d.doctype][local_d.name];

								// re-attach with new name
								locals[d.doctype][d.name] = local_d;
							}

							// row exists, just copy the values
							Object.assign(local_d, d);
							clear_keys(d, local_d);

						} else {
							local_doc[fieldname].push(d);
							if (!d.parent) { d.parent = doc.name; }
							frappe.model.add_to_locals(d);
						}
					}

					// remove extra rows
					if (local_doc[fieldname].length > doc[fieldname].length) {
						for (var i$1 = doc[fieldname].length; i$1 < local_doc[fieldname].length; i$1++) {

							// clear from local
							var d$1 = local_doc[fieldname][i$1];
							if (locals[d$1.doctype] && locals[d$1.doctype][d$1.name]) {
								delete locals[d$1.doctype][d$1.name];
							}
						}
						local_doc[fieldname].length = doc[fieldname].length;

					}
				} else {
					// literal
					local_doc[fieldname] = doc[fieldname];
				}
			}

			// clear keys on parent
			clear_keys(doc, local_doc);
		}

	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.model");

	$.extend(frappe.model, {
		new_names: {},
		new_name_count: {},

		get_new_doc: function(doctype, parent_doc, parentfield, with_mandatory_children) {
			frappe.provide("locals." + doctype);
			var doc = {
				docstatus: 0,
				doctype: doctype,
				name: frappe.model.get_new_name(doctype),
				__islocal: 1,
				__unsaved: 1,
				owner: frappe.session.user
			};
			frappe.model.set_default_values(doc, parent_doc);

			if(parent_doc) {
				$.extend(doc, {
					parent: parent_doc.name,
					parentfield: parentfield,
					parenttype: parent_doc.doctype,
				});
				if(!parent_doc[parentfield]) { parent_doc[parentfield] = []; }
				doc.idx = parent_doc[parentfield].length + 1;
				parent_doc[parentfield].push(doc);
			} else {
				frappe.provide("frappe.model.docinfo." + doctype + "." + doc.name);
			}

			frappe.model.add_to_locals(doc);

			if(with_mandatory_children) {
				frappe.model.create_mandatory_children(doc);
			}

			if (!parent_doc) {
				doc.__run_link_triggers = 1;
			}

			// set the name if called from a link field
			if(frappe.route_options && frappe.route_options.name_field) {

				var meta = frappe.get_meta(doctype);
				// set title field / name as name
				if(meta.autoname && meta.autoname.indexOf("field:")!==-1) {
					doc[meta.autoname.substr(6)] = frappe.route_options.name_field;
				} else if(meta.title_field) {
					doc[meta.title_field] = frappe.route_options.name_field;
				}


				delete frappe.route_options.name_field;
			}

			// set route options
			if(frappe.route_options && !doc.parent) {
				$.each(frappe.route_options, function(fieldname, value) {
					var df = frappe.meta.has_field(doctype, fieldname);
					if(df && in_list(['Link', 'Data', 'Select', 'Dynamic Link'], df.fieldtype) && !df.no_copy) {
						doc[fieldname]=value;
					}
				});
				frappe.route_options = null;
			}

			return doc;
		},

		make_new_doc_and_get_name: function(doctype, with_mandatory_children) {
			return frappe.model.get_new_doc(doctype, null, null, with_mandatory_children).name;
		},

		get_new_name: function(doctype) {
			var cnt = frappe.model.new_name_count;
			if(!cnt[doctype])
				{ cnt[doctype] = 0; }
			cnt[doctype]++;
			return __('New') + ' '+ __(doctype) + ' ' + cnt[doctype];
		},

		set_default_values: function(doc, parent_doc) {
			var doctype = doc.doctype;
			var docfields = frappe.meta.get_docfields(doctype);
			var updated = [];
			for(var fid=0;fid<docfields.length;fid++) {
				var f = docfields[fid];
				if(!in_list(frappe.model.no_value_type, f.fieldtype) && doc[f.fieldname]==null) {
					var v = frappe.model.get_default_value(f, doc, parent_doc);
					if(v) {
						if(in_list(["Int", "Check"], f.fieldtype))
							{ v = cint(v); }
						else if(in_list(["Currency", "Float"], f.fieldtype))
							{ v = flt(v); }

						doc[f.fieldname] = v;
						updated.push(f.fieldname);
					} else if(f.fieldtype == "Select" && f.options && typeof f.options === 'string'
						&& !in_list(["[Select]", "Loading..."], f.options)) {

						doc[f.fieldname] = f.options.split("\n")[0];
					}
				}
			}
			return updated;
		},

		create_mandatory_children: function(doc) {
			var meta = frappe.get_meta(doc.doctype);
			if(meta && meta.istable) { return; }

			// create empty rows for mandatory table fields
			frappe.meta.get_docfields(doc.doctype).forEach(function(df) {
				if(df.fieldtype==='Table' && df.reqd) {
					frappe.model.add_child(doc, df.fieldname);
				}
			});
		},

		get_default_value: function(df, doc, parent_doc) {
			var assign;

			var user_default = "";
			var user_permissions = frappe.defaults.get_user_permissions();
			var allowed_records = [];
			var default_doc = null;
			if(user_permissions) {
				((assign = frappe.perm.filter_allowed_docs_for_doctype(user_permissions[df.options], doc.doctype), allowed_records = assign.allowed_records, default_doc = assign.default_doc));
			}
			var meta = frappe.get_meta(doc.doctype);
			var has_user_permissions = (df.fieldtype==="Link"
				&& !$.isEmptyObject(user_permissions)
				&& df.ignore_user_permissions != 1
				&& allowed_records.length);

			// don't set defaults for "User" link field using User Permissions!
			if (df.fieldtype==="Link" && df.options!=="User") {
				// If user permission has Is Default enabled or single-user permission has found against respective doctype.
				if (has_user_permissions && default_doc) {
					return default_doc;
				}

				if(!df.ignore_user_permissions) {
					// 2 - look in user defaults
					var user_defaults = frappe.defaults.get_user_defaults(df.options);
					if (user_defaults && user_defaults.length===1) {
						// Use User Permission value when only when it has a single value
						user_default = user_defaults[0];
					}
				}

				if (!user_default) {
					user_default = frappe.defaults.get_user_default(df.fieldname);
				}

				if(!user_default && df.remember_last_selected_value && frappe.boot.user.last_selected_values) {
					user_default = frappe.boot.user.last_selected_values[df.options];
				}

				var is_allowed_user_default = user_default &&
					(!has_user_permissions || allowed_records.includes(user_default));

				// is this user default also allowed as per user permissions?
				if (is_allowed_user_default) {
					return user_default;
				}
			}

			// 3 - look in default of docfield
			if (df['default']) {

				if (df["default"] == "__user" || df["default"].toLowerCase() == "user") {
					return frappe.session.user;

				} else if (df["default"] == "user_fullname") {
					return frappe.session.user_fullname;

				} else if (df["default"] == "Today") {
					return frappe.datetime.get_today();

				} else if ((df["default"] || "").toLowerCase() === "now") {
					return frappe.datetime.now_datetime();

				} else if (df["default"][0]===":") {
					var boot_doc = frappe.model.get_default_from_boot_docs(df, doc, parent_doc);
					var is_allowed_boot_doc = !has_user_permissions || allowed_records.includes(boot_doc);

					if (is_allowed_boot_doc) {
						return boot_doc;
					}
				} else if (df.fieldname===meta.title_field) {
					// ignore defaults for title field
					return "";
				}

				// is this default value is also allowed as per user permissions?
				var is_allowed_default = !has_user_permissions || allowed_records.includes(df.default);
				if (df.fieldtype!=="Link" || df.options==="User" || is_allowed_default) {
					return df["default"];
				}

			} else if (df.fieldtype=="Time") {
				return frappe.datetime.now_time();
			}
		},

		get_default_from_boot_docs: function(df, doc, parent_doc) {
			// set default from partial docs passed during boot like ":User"
			if(frappe.get_list(df["default"]).length > 0) {
				var ref_fieldname = df["default"].slice(1).toLowerCase().replace(" ", "_");
				var ref_value = parent_doc ?
					parent_doc[ref_fieldname] :
					frappe.defaults.get_user_default(ref_fieldname);
				var ref_doc = ref_value ? frappe.get_doc(df["default"], ref_value) : null;

				if(ref_doc && ref_doc[df.fieldname]) {
					return ref_doc[df.fieldname];
				}
			}
		},

		add_child: function(parent_doc, doctype, parentfield, idx) {
			// if given doc, fieldname only
			if(arguments.length===2) {
				parentfield = doctype;
				doctype = frappe.meta.get_field(parent_doc.doctype, parentfield).options;
			}

			// create row doc
			idx = idx ? idx - 0.1 : (parent_doc[parentfield] || []).length + 1;

			var child = frappe.model.get_new_doc(doctype, parent_doc, parentfield);
			child.idx = idx;

			// renum for fraction
			if(idx !== cint(idx)) {
				var sorted = parent_doc[parentfield].sort(function(a, b) { return a.idx - b.idx; });
				for(var i=0, j=sorted.length; i<j; i++) {
					var d = sorted[i];
					d.idx = i + 1;
				}
			}

			if (cur_frm && cur_frm.doc == parent_doc) { cur_frm.dirty(); }

			return child;
		},

		copy_doc: function(doc, from_amend, parent_doc, parentfield) {
			var no_copy_list = ['name','amended_from','amendment_date','cancel_reason'];
			var newdoc = frappe.model.get_new_doc(doc.doctype, parent_doc, parentfield);

			for(var key in doc) {
				// dont copy name and blank fields
				var df = frappe.meta.get_docfield(doc.doctype, key);

				if (df && key.substr(0, 2) != '__'
					&& !in_list(no_copy_list, key)
					&& !(df && (!from_amend && cint(df.no_copy) == 1))) {

					var value = doc[key] || [];
					if (frappe.model.table_fields.includes(df.fieldtype)) {
						for (var i = 0, j = value.length; i < j; i++) {
							var d = value[i];
							frappe.model.copy_doc(d, from_amend, newdoc, df.fieldname);
						}
					} else {
						newdoc[key] = doc[key];
					}
				}
			}

			var user = frappe.session.user;

			newdoc.__islocal = 1;
			newdoc.docstatus = 0;
			newdoc.owner = user;
			newdoc.creation = '';
			newdoc.modified_by = user;
			newdoc.modified = '';

			return newdoc;
		},

		open_mapped_doc: function(opts) {
			if (opts.frm && opts.frm.doc.__unsaved) {
				frappe.throw(__("You have unsaved changes in this form. Please save before you continue."));

			} else if (!opts.source_name && opts.frm) {
				opts.source_name = opts.frm.doc.name;

			// Allow opening a mapped doc without a source document name
			} else if (!opts.frm) {
				opts.source_name = null;
			}

			return frappe.call({
				type: "POST",
				method: 'frappe.model.mapper.make_mapped_doc',
				args: {
					method: opts.method,
					source_name: opts.source_name,
					args: opts.args || null,
					selected_children: opts.frm ? opts.frm.get_selected() : null
				},
				freeze: true,
				callback: function(r) {
					if(!r.exc) {
						frappe.model.sync(r.message);
						if(opts.run_link_triggers) {
							frappe.get_doc(r.message.doctype, r.message.name).__run_link_triggers = true;
						}
						frappe.set_route("Form", r.message.doctype, r.message.name);
					}
				}
			})
		}
	});

	frappe.create_routes = {};
	frappe.new_doc = function (doctype, opts, init_callback) {
		if (doctype === 'File') {
			new frappe.ui.FileUploader({
				folder: opts ? opts.folder : 'Home'
			});
			return;
		}
		return new Promise(function (resolve) {
			if(opts && $.isPlainObject(opts)) {
				frappe.route_options = opts;
			}
			frappe.model.with_doctype(doctype, function() {
				if(frappe.create_routes[doctype]) {
					frappe.set_route(frappe.create_routes[doctype])
						.then(function () { return resolve(); });
				} else {
					frappe.ui.form.make_quick_entry(doctype, null, init_callback)
						.then(function () { return resolve(); });
				}
			});

		});
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.perm");

	// backward compatibilty
	Object.assign(window, {
		READ: "read",
		WRITE: "write",
		CREATE: "create",
		DELETE: "delete",
		SUBMIT: "submit",
		CANCEL: "cancel",
		AMEND: "amend",
	});

	$.extend(frappe.perm, {
		rights: ["read", "write", "create", "delete", "submit", "cancel", "amend",
			"report", "import", "export", "print", "email", "share", "set_user_permissions"],

		doctype_perm: {},

		has_perm: function (doctype, permlevel, ptype, doc) {
			if (!permlevel) { permlevel = 0; }
			if (!frappe.perm.doctype_perm[doctype]) {
				frappe.perm.doctype_perm[doctype] = frappe.perm.get_perm(doctype);
			}

			var perms = frappe.perm.doctype_perm[doctype];

			if (!perms || !perms[permlevel]) { return false; }

			var perm = !!perms[permlevel][ptype];

			if (permlevel === 0 && perm && doc) {
				var docinfo = frappe.model.get_docinfo(doctype, doc.name);
				if (docinfo && !docinfo.permissions[ptype])
					{ perm = false; }
			}

			return perm;
		},

		get_perm: function (doctype, doc) {
			var perm = [{ read: 0, permlevel: 0 }];

			var meta = frappe.get_doc("DocType", doctype);
			var user  = frappe.session.user;

			if (user === "Administrator" || frappe.user_roles.includes("Administrator")) {
				perm[0].read = 1;
			}

			if (!meta) { return perm; }

			perm = frappe.perm.get_role_permissions(meta);

			if (doc) {
				// apply user permissions via docinfo (which is processed server-side)
				var docinfo = frappe.model.get_docinfo(doctype, doc.name);
				if (docinfo && docinfo.permissions) {
					Object.keys(docinfo.permissions).forEach(function (ptype) {
						perm[0][ptype] = docinfo.permissions[ptype];
					});
				}

				// if owner
				if (!$.isEmptyObject(perm[0].if_owner)) {
					if (doc.owner === user) {
						$.extend(perm[0], perm[0].if_owner);
					} else {
						// not owner, remove permissions
						$.each(perm[0].if_owner, function (ptype) {
							if (perm[0].if_owner[ptype]) {
								perm[0][ptype] = 0;
							}
						});
					}
				}

				// apply permissions from shared
				if (docinfo && docinfo.shared) {
					for (var i = 0; i < docinfo.shared.length; i++) {
						var s = docinfo.shared[i];
						if (s.user === user) {
							perm[0]["read"] = perm[0]["read"] || s.read;
							perm[0]["write"] = perm[0]["write"] || s.write;
							perm[0]["share"] = perm[0]["share"] || s.share;

							if (s.read) {
								// also give print, email permissions if read
								// and these permissions exist at level [0]
								perm[0].email = frappe.boot.user.can_email.indexOf(doctype) !== -1 ? 1 : 0;
								perm[0].print = frappe.boot.user.can_print.indexOf(doctype) !== -1 ? 1 : 0;
							}
						}
					}
				}

			}

			if (frappe.model.can_read(doctype) && !perm[0].read) {
				// read via sharing
				perm[0].read = 1;
			}

			return perm;
		},

		get_role_permissions: function (meta) {
			var perm = [{ read: 0, permlevel: 0 }];
			// Returns a `dict` of evaluated Role Permissions
			(meta.permissions || []).forEach(function (p) {
				// if user has this role
				var permlevel = cint(p.permlevel);
				if (!perm[permlevel]) {
					perm[permlevel] = {};
					perm[permlevel]["permlevel"] = permlevel;
				}

				if (frappe.user_roles.includes(p.role)) {
					frappe.perm.rights.forEach(function (right) {
						var value = perm[permlevel][right] || (p[right] || 0);
						if (value) {
							perm[permlevel][right] = value;
						}
					});
				}
			});

			// fill gaps with empty object
			perm = perm.map(function (p) { return p || {}; });
			return perm;
		},

		get_match_rules: function (doctype, ptype) {
			var match_rules = [];

			if (!ptype) { ptype = "read"; }

			var perm = frappe.perm.get_perm(doctype);

			var user_permissions = frappe.defaults.get_user_permissions();

			if (user_permissions && !$.isEmptyObject(user_permissions)) {
				var rules = {};
				var fields_to_check = frappe.meta.get_fields_to_check_permissions(doctype);
				$.each(fields_to_check, function (i, df) {
					var user_permissions_for_doctype = user_permissions[df.options] || [];
					var allowed_records = frappe.perm.get_allowed_docs_for_doctype(user_permissions_for_doctype, doctype);
					if (allowed_records.length) {
						rules[df.label] = allowed_records;
					}
				});
				if (!$.isEmptyObject(rules)) {
					match_rules.push(rules);
				}
			}

			if (perm[0].if_owner && perm[0].read) {
				match_rules.push({ "Owner": frappe.session.user });
			}
			return match_rules;
		},

		get_field_display_status: function (df, doc, perm, explain) {
			// returns the display status of a particular field
			// returns one of "Read", "Write" or "None"
			if (!perm && doc) {
				perm = frappe.perm.get_perm(doc.doctype, doc);
			}

			if (!perm) {
				return (df && (cint(df.hidden) || cint(df.hidden_due_to_dependency))) ? "None" : "Write";
			}

			if (!df.permlevel) { df.permlevel = 0; }
			var p = perm[df.permlevel];
			var status = "None";

			// permission
			if (p) {
				if (p.write && !df.disabled) {
					status = "Write";
				} else if (p.read) {
					status = "Read";
				}
			}
			if (explain) { console.log("By Permission:" + status); }

			// hidden
			if (cint(df.hidden)) { status = "None"; }
			if (explain) { console.log("By Hidden:" + status); }

			// hidden due to dependency
			if (cint(df.hidden_due_to_dependency)) { status = "None"; }
			if (explain) { console.log("By Hidden Due To Dependency:" + status); }

			if (!doc) {
				return status;
			}

			// submit
			if (status === "Write" && cint(doc.docstatus) > 0) { status = "Read"; }
			if (explain) { console.log("By Submit:" + status); }

			// allow on submit
			// let allow_on_submit = df.fieldtype==="Table" ? 0 : cint(df.allow_on_submit);
			var allow_on_submit = cint(df.allow_on_submit);
			if (status === "Read" && allow_on_submit && cint(doc.docstatus) === 1 && p.write) {
				status = "Write";
			}
			if (explain) { console.log("By Allow on Submit:" + status); }

			// workflow state
			if (status === "Read" && cur_frm && cur_frm.state_fieldname) {
				// fields updated by workflow must be read-only
				if (cint(cur_frm.read_only) ||
					in_list(cur_frm.states.update_fields, df.fieldname) ||
					df.fieldname == cur_frm.state_fieldname) {
					status = "Read";
				}
			}
			if (explain) { console.log("By Workflow:" + status); }

			// read only field is checked
			if (status === "Write" && cint(df.read_only)) {
				status = "Read";
			}
			if (explain) { console.log("By Read Only:" + status); }

			if (status === "Write" && df.set_only_once && !doc.__islocal) {
				status = "Read";
			}
			if (explain) { console.log("By Set Only Once:" + status); }

			return status;
		},

		is_visible: function (df, doc, perm) {
			if (typeof df === 'string') {
				// df is fieldname
				df = frappe.meta.get_docfield(doc.doctype, df, doc.parent || doc.name);
			}

			var status = frappe.perm.get_field_display_status(df, doc, perm);

			return status === "None" ? false : true;
		},

		get_allowed_docs_for_doctype: function (user_permissions, doctype) {
			// returns docs from the list of user permissions that are allowed under provided doctype
			return frappe.perm.filter_allowed_docs_for_doctype(user_permissions, doctype, false);
		},

		filter_allowed_docs_for_doctype: function (user_permissions, doctype, with_default_doc) {
			if ( with_default_doc === void 0 ) with_default_doc=true;

			// returns docs from the list of user permissions that are allowed under provided doctype
			// also returns default doc when with_default_doc is set
			var filtered_perms = (user_permissions || []).filter(function (perm) {
				return (perm.applicable_for === doctype || !perm.applicable_for);
			});

			var allowed_docs = (filtered_perms).map(function (perm) { return perm.doc; });

			if (with_default_doc) {
				var default_doc = allowed_docs.length === 1 ? allowed_docs : filtered_perms
					.filter(function (perm) { return perm.is_default; })
					.map(function (record) { return record.doc; });

				return {
					allowed_records: allowed_docs,
					default_doc: default_doc[0]
				};
			} else {
				return allowed_docs;
			}
		}
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.workflow");

	frappe.workflow = {
		state_fields: {},
		workflows: {},
		setup: function(doctype) {
			var wf = frappe.get_list("Workflow", {document_type: doctype});
			if(wf.length) {
				frappe.workflow.workflows[doctype] = wf[0];
				frappe.workflow.state_fields[doctype] = wf[0].workflow_state_field;
			} else {
				frappe.workflow.state_fields[doctype] = null;
			}
		},
		get_state_fieldname: function(doctype) {
			if(frappe.workflow.state_fields[doctype]===undefined) {
				frappe.workflow.setup(doctype);
			}
			return frappe.workflow.state_fields[doctype];
		},
		get_default_state: function(doctype, docstatus) {
			frappe.workflow.setup(doctype);
			var value = null;
			$.each(frappe.workflow.workflows[doctype].states, function(i, workflow_state) {
				if(cint(workflow_state.doc_status)===cint(docstatus)) {
					value = workflow_state.state;
					return false;
				}
			});
			return value;
		},
		get_transitions: function(doc) {
			frappe.workflow.setup(doc.doctype);
			return frappe.xcall('frappe.model.workflow.get_transitions', {doc: doc});
		},
		get_document_state: function(doctype, state) {
			frappe.workflow.setup(doctype);
			return frappe.get_children(frappe.workflow.workflows[doctype], "states", {state:state})[0];
		},
		is_self_approval_enabled: function(doctype) {
			return frappe.workflow.workflows[doctype].allow_self_approval;
		},
		is_read_only: function(doctype, name) {
			var state_fieldname = frappe.workflow.get_state_fieldname(doctype);
			if(state_fieldname) {
				var doc = locals[doctype][name];
				if(!doc)
					{ return false; }
				if(doc.__islocal)
					{ return false; }

				var state = doc[state_fieldname] ||
					frappe.workflow.get_default_state(doctype, doc.docstatus);

				var allow_edit = state ? frappe.workflow.get_document_state(doctype, state) && frappe.workflow.get_document_state(doctype, state).allow_edit : null;

				if(!frappe.user_roles.includes(allow_edit)) {
					return true;
				}
			}
			return false;
		},
		get_update_fields: function(doctype) {
			var update_fields = $.unique($.map(frappe.workflow.workflows[doctype].states || [],
				function(d) {
					return d.update_field;
				}));
			return update_fields;
		},
		get_state: function get_state(doc) {
			var state_field = this.get_state_fieldname(doc.doctype);
			var state = doc[state_field];
			if (!state) {
				state = this.get_default_state(doc.doctype, doc.docstatus);
			}
			return state;
		},
		get_all_transitions: function get_all_transitions(doctype) {
			return frappe.workflow.workflows[doctype].transitions || [];
		},
		get_all_transition_actions: function get_all_transition_actions(doctype) {
			var transitions = this.get_all_transitions(doctype);
			return transitions.map(function (transition) {
				return transition.action;
			});
		},
	};

	frappe.provide('frappe.model.user_settings');

	$.extend(frappe.model.user_settings, {
		get: function(doctype) {
			return frappe.call('frappe.model.utils.user_settings.get', { doctype: doctype })
				.then(function (r) { return JSON.parse(r.message || '{}'); });
		},
		save: function(doctype, key, value) {
			var old_user_settings = frappe.model.user_settings[doctype] || {};
			var new_user_settings = $.extend(true, {}, old_user_settings); // deep copy

			if ($.isPlainObject(value)) {
				new_user_settings[key] = new_user_settings[key] || {};
				$.extend(new_user_settings[key], value);
			} else {
				new_user_settings[key] = value;
			}

			var a = JSON.stringify(old_user_settings);
			var b = JSON.stringify(new_user_settings);
			if (a !== b) {
				// update if changed
				return this.update(doctype, new_user_settings);
			}
			return Promise.resolve();
		},
		remove: function(doctype, key) {
			var user_settings = frappe.model.user_settings[doctype] || {};
			delete user_settings[key];

			return this.update(doctype, user_settings);
		},
		update: function(doctype, user_settings) {
			return frappe.call({
				method: 'frappe.model.utils.user_settings.save',
				args: {
					doctype: doctype,
					user_settings: user_settings
				},
				callback: function(r) {
					frappe.model.user_settings[doctype] = r.message;
				}
			});
		}
	});

	frappe.get_user_settings = function(doctype, key) {
		var settings = frappe.model.user_settings[doctype] || {};
		if(key) {
			settings = settings[key] || {};
		}
		return settings;
	};

	!function(a){function b(a,b){var c=(65535&a)+(65535&b),d=(a>>16)+(b>>16)+(c>>16);return d<<16|65535&c}function c(a,b){return a<<b|a>>>32-b}function d(a,d,e,f,g,h){return b(c(b(b(d,a),b(f,h)),g),e)}function e(a,b,c,e,f,g,h){return d(b&c|~b&e,a,b,f,g,h)}function f(a,b,c,e,f,g,h){return d(b&e|c&~e,a,b,f,g,h)}function g(a,b,c,e,f,g,h){return d(b^c^e,a,b,f,g,h)}function h(a,b,c,e,f,g,h){return d(c^(b|~e),a,b,f,g,h)}function i(a,c){a[c>>5]|=128<<c%32,a[(c+64>>>9<<4)+14]=c;var d,i,j,k,l,m=1732584193,n=-271733879,o=-1732584194,p=271733878;for(d=0;d<a.length;d+=16){ i=m,j=n,k=o,l=p,m=e(m,n,o,p,a[d],7,-680876936),p=e(p,m,n,o,a[d+1],12,-389564586),o=e(o,p,m,n,a[d+2],17,606105819),n=e(n,o,p,m,a[d+3],22,-1044525330),m=e(m,n,o,p,a[d+4],7,-176418897),p=e(p,m,n,o,a[d+5],12,1200080426),o=e(o,p,m,n,a[d+6],17,-1473231341),n=e(n,o,p,m,a[d+7],22,-45705983),m=e(m,n,o,p,a[d+8],7,1770035416),p=e(p,m,n,o,a[d+9],12,-1958414417),o=e(o,p,m,n,a[d+10],17,-42063),n=e(n,o,p,m,a[d+11],22,-1990404162),m=e(m,n,o,p,a[d+12],7,1804603682),p=e(p,m,n,o,a[d+13],12,-40341101),o=e(o,p,m,n,a[d+14],17,-1502002290),n=e(n,o,p,m,a[d+15],22,1236535329),m=f(m,n,o,p,a[d+1],5,-165796510),p=f(p,m,n,o,a[d+6],9,-1069501632),o=f(o,p,m,n,a[d+11],14,643717713),n=f(n,o,p,m,a[d],20,-373897302),m=f(m,n,o,p,a[d+5],5,-701558691),p=f(p,m,n,o,a[d+10],9,38016083),o=f(o,p,m,n,a[d+15],14,-660478335),n=f(n,o,p,m,a[d+4],20,-405537848),m=f(m,n,o,p,a[d+9],5,568446438),p=f(p,m,n,o,a[d+14],9,-1019803690),o=f(o,p,m,n,a[d+3],14,-187363961),n=f(n,o,p,m,a[d+8],20,1163531501),m=f(m,n,o,p,a[d+13],5,-1444681467),p=f(p,m,n,o,a[d+2],9,-51403784),o=f(o,p,m,n,a[d+7],14,1735328473),n=f(n,o,p,m,a[d+12],20,-1926607734),m=g(m,n,o,p,a[d+5],4,-378558),p=g(p,m,n,o,a[d+8],11,-2022574463),o=g(o,p,m,n,a[d+11],16,1839030562),n=g(n,o,p,m,a[d+14],23,-35309556),m=g(m,n,o,p,a[d+1],4,-1530992060),p=g(p,m,n,o,a[d+4],11,1272893353),o=g(o,p,m,n,a[d+7],16,-155497632),n=g(n,o,p,m,a[d+10],23,-1094730640),m=g(m,n,o,p,a[d+13],4,681279174),p=g(p,m,n,o,a[d],11,-358537222),o=g(o,p,m,n,a[d+3],16,-722521979),n=g(n,o,p,m,a[d+6],23,76029189),m=g(m,n,o,p,a[d+9],4,-640364487),p=g(p,m,n,o,a[d+12],11,-421815835),o=g(o,p,m,n,a[d+15],16,530742520),n=g(n,o,p,m,a[d+2],23,-995338651),m=h(m,n,o,p,a[d],6,-198630844),p=h(p,m,n,o,a[d+7],10,1126891415),o=h(o,p,m,n,a[d+14],15,-1416354905),n=h(n,o,p,m,a[d+5],21,-57434055),m=h(m,n,o,p,a[d+12],6,1700485571),p=h(p,m,n,o,a[d+3],10,-1894986606),o=h(o,p,m,n,a[d+10],15,-1051523),n=h(n,o,p,m,a[d+1],21,-2054922799),m=h(m,n,o,p,a[d+8],6,1873313359),p=h(p,m,n,o,a[d+15],10,-30611744),o=h(o,p,m,n,a[d+6],15,-1560198380),n=h(n,o,p,m,a[d+13],21,1309151649),m=h(m,n,o,p,a[d+4],6,-145523070),p=h(p,m,n,o,a[d+11],10,-1120210379),o=h(o,p,m,n,a[d+2],15,718787259),n=h(n,o,p,m,a[d+9],21,-343485551),m=b(m,i),n=b(n,j),o=b(o,k),p=b(p,l); }return [m,n,o,p]}function j(a){var b,c="";for(b=0;b<32*a.length;b+=8){ c+=String.fromCharCode(a[b>>5]>>>b%32&255); }return c}function k(a){var b,c=[];for(c[(a.length>>2)-1]=void 0,b=0;b<c.length;b+=1){ c[b]=0; }for(b=0;b<8*a.length;b+=8){ c[b>>5]|=(255&a.charCodeAt(b/8))<<b%32; }return c}function l(a){return j(i(k(a),8*a.length))}function m(a,b){var c,d,e=k(a),f=[],g=[];for(f[15]=g[15]=void 0,e.length>16&&(e=i(e,8*a.length)),c=0;16>c;c+=1){ f[c]=909522486^e[c],g[c]=1549556828^e[c]; }return d=i(f.concat(k(b)),512+8*b.length),j(i(g.concat(d),640))}function n(a){var b,c,d="0123456789abcdef",e="";for(c=0;c<a.length;c+=1){ b=a.charCodeAt(c),e+=d.charAt(b>>>4&15)+d.charAt(15&b); }return e}function o(a){return unescape(encodeURIComponent(a))}function p(a){return l(o(a))}function q(a){return n(p(a))}function r(a,b){return m(o(a),o(b))}function s(a,b){return n(r(a,b))}function t(a,b,c){return b?c?r(b,a):s(b,a):c?p(a):q(a)}"function"==typeof define&&define.amd?define(function(){return t}):a.md5=t;}(window);

	frappe.user_info = function(uid) {
		if(!uid)
			{ uid = frappe.session.user; }

		if(uid.toLowerCase()==="bot") {
			return {
				fullname: __("Bot"),
				image: "/assets/frappe/images/ui/bot.png",
				abbr: "B"
			};
		}

		if(!(frappe.boot.user_info && frappe.boot.user_info[uid])) {
			var user_info = {
				fullname: frappe.utils.capitalize(uid.split("@")[0]) || "Unknown"
			};
		} else {
			var user_info = frappe.boot.user_info[uid];
		}

		user_info.abbr = frappe.get_abbr(user_info.fullname);
		user_info.color = frappe.get_palette(user_info.fullname);

		return user_info;
	};

	frappe.ui.set_user_background = function(src, selector, style) {
		if(!selector) { selector = "#page-desktop"; }
		if(!style) { style = "Fill Screen"; }
		if(src) {
			if (window.cordova && src.indexOf("http") === -1) {
				src = frappe.base_url + src;
			}
			var background = repl('background: url("%(src)s") center center;', {src: src});
		} else {
			var background = "background-color: #4B4C9D;";
		}

		frappe.dom.set_style(repl('%(selector)s { \
		%(background)s \
		background-attachment: fixed; \
		%(style)s \
	}', {
			selector:selector,
			background:background,
			style: style==="Fill Screen" ? "background-size: cover;" : ""
		}));
	};

	frappe.provide('frappe.user');

	$.extend(frappe.user, {
		name: 'Guest',
		full_name: function(uid) {
			return uid === frappe.session.user ?
				__("You") :
				frappe.user_info(uid).fullname;
		},
		image: function(uid) {
			return frappe.user_info(uid).image;
		},
		abbr: function(uid) {
			return frappe.user_info(uid).abbr;
		},
		has_role: function(rl) {
			if(typeof rl=='string')
				{ rl = [rl]; }
			for(var i in rl) {
				if((frappe.boot ? frappe.boot.user.roles : ['Guest']).indexOf(rl[i])!=-1)
					{ return true; }
			}
		},
		get_desktop_items: function() {
			// hide based on permission
			var modules_list = $.map(frappe.boot.allowed_modules, function(icon) {
				var m = icon.module_name;
				var type = frappe.modules[m] && frappe.modules[m].type;

				if(frappe.boot.user.allow_modules.indexOf(m) === -1) { return null; }

				var ret = null;
				if (type === "module") {
					if(frappe.boot.user.allow_modules.indexOf(m)!=-1 || frappe.modules[m].is_help)
						{ ret = m; }
				} else if (type === "page") {
					if(frappe.boot.allowed_pages.indexOf(frappe.modules[m].link)!=-1)
						{ ret = m; }
				} else if (type === "list") {
					if(frappe.model.can_read(frappe.modules[m]._doctype))
						{ ret = m; }
				} else if (type === "view") {
					ret = m;
				} else if (type === "setup") {
					if(frappe.user.has_role("System Manager") || frappe.user.has_role("Administrator"))
						{ ret = m; }
				} else {
					ret = m;
				}

				return ret;
			});

			return modules_list;
		},

		is_report_manager: function() {
			return frappe.user.has_role(['Administrator', 'System Manager', 'Report Manager']);
		},

		get_formatted_email: function(email) {
			var fullname = frappe.user.full_name(email);

			if (!fullname) {
				return email;
			} else {
				// to quote or to not
				var quote = '';

				// only if these special characters are found
				// why? To make the output same as that in python!
				if (fullname.search(/[\[\]\\()<>@,:;".]/) !== -1) {
					quote = '"';
				}

				return repl('%(quote)s%(fullname)s%(quote)s <%(email)s>', {
					fullname: fullname,
					email: email,
					quote: quote
				});
			}
		},

		get_emails: function ( ) {
			return Object.keys(frappe.boot.user_info).map(function (key) { return frappe.boot.user_info[key].email; });
		},

		/* Normally frappe.user is an object
		 * having properties and methods.
		 * But in the following case
		 *
		 * if (frappe.user === 'Administrator')
		 *
		 * frappe.user will cast to a string
		 * returning frappe.user.name
		 */
		toString: function() {
			return this.name;
		}
	});

	frappe.session_alive = true;
	$(document).bind('mousemove', function() {
		if(frappe.session_alive===false) {
			$(document).trigger("session_alive");
		}
		frappe.session_alive = true;
		if(frappe.session_alive_timeout)
			{ clearTimeout(frappe.session_alive_timeout); }
		frappe.session_alive_timeout = setTimeout('frappe.session_alive=false;', 30000);
	});

	// common file between desk and website

	frappe.avatar = function (user, css_class, title, image_url) {
		if ( image_url === void 0 ) image_url = null;

		var user_info;
		if (user) {
			// desk
			user_info = frappe.user_info(user);
		} else {
			// website
			var full_name = title || frappe.get_cookie("full_name");
			user_info = {
				image: image_url === null ? frappe.get_cookie("user_image") : image_url,
				fullname: full_name,
				abbr: frappe.get_abbr(full_name),
				color: frappe.get_palette(full_name)
			};
		}

		if (!title) {
			title = user_info.fullname;
		}

		if (!css_class) {
			css_class = "avatar-small";
		}

		if (user_info.image || image_url) {
			image_url = image_url || user_info.image;

			var image = (window.cordova && image_url.indexOf('http') === -1) ? frappe.base_url + image_url : image_url;

			return ("<span class=\"avatar " + css_class + "\" title=\"" + title + "\">\n\t\t\t\t<span class=\"avatar-frame\" style='background-image: url(\"" + image + "\")'\n\t\t\t\t\ttitle=\"" + title + "\"></span>\n\t\t\t</span>");
		} else {
			var abbr = user_info.abbr;
			if (css_class === 'avatar-small' || css_class == 'avatar-xs') {
				abbr = abbr.substr(0, 1);
			}
			return ("<span class=\"avatar " + css_class + "\" title=\"" + title + "\">\n\t\t\t<div class=\"standard-image\" style=\"background-color: " + (user_info.color) + ";\">\n\t\t\t\t" + abbr + "</div>\n\t\t</span>");
		}
	};

	frappe.ui.scroll = function(element, animate, additional_offset) {
		var header_offset = $(".navbar").height() + $(".page-head").height();
		var top = $(element).offset().top - header_offset - cint(additional_offset);
		if (animate) {
			$("html, body").animate({ scrollTop: top });
		} else {
			$(window).scrollTop(top);
		}
	};

	frappe.get_palette = function(txt) {
		return '#fafbfc';
		// //return '#8D99A6';
		// if(txt==='Administrator') return '#36414C';
		// // get color palette selection from md5 hash
		// var idx = cint((parseInt(md5(txt).substr(4,2), 16) + 1) / 5.33);
		// if(idx > 47) idx = 47;
		// return frappe.palette[idx][0]
	};

	frappe.get_abbr = function(txt, max_length) {
		if (!txt) { return ""; }
		var abbr = "";
		$.each(txt.split(" "), function(i, w) {
			if (abbr.length >= (max_length || 2)) {
				// break
				return false;

			} else if (!w.trim().length) {
				// continue
				return true;
			}
			abbr += w.trim()[0];
		});

		return abbr || "?";
	};

	frappe.gravatars = {};
	frappe.get_gravatar = function(email_id, size) {
		if ( size === void 0 ) size = 0;

		var param = size ? ('s=' + size) : 'd=retro';
		if(!frappe.gravatars[email_id]) {
			// TODO: check if gravatar exists
			frappe.gravatars[email_id] = "https://secure.gravatar.com/avatar/" + md5(email_id) + "?" + param;
		}
		return frappe.gravatars[email_id];
	};

	// string commons

	window.repl =function repl(s, dict) {
		if(s==null){ return ''; }
		for(var key in dict) {
			s = s.split("%("+key+")s").join(dict[key]);
		}
		return s;
	};

	window.replace_all = function(s, t1, t2) {
		return s.split(t1).join(t2);
	};

	window.strip_html = function(txt) {
		return txt.replace(/<[^>]*>/g, "");
	};

	window.strip = function(s, chars) {
		if (s) {
			var s= lstrip(s, chars);
			s = rstrip(s, chars);
			return s;
		}
	};

	window.lstrip = function lstrip(s, chars) {
		if(!chars) { chars = ['\n', '\t', ' ']; }
		// strip left
		var first_char = s.substr(0,1);
		while(in_list(chars, first_char)) {
			var s = s.substr(1);
			first_char = s.substr(0,1);
		}
		return s;
	};

	window.rstrip = function(s, chars) {
		if(!chars) { chars = ['\n', '\t', ' ']; }
		var last_char = s.substr(s.length-1);
		while(in_list(chars, last_char)) {
			var s = s.substr(0, s.length-1);
			last_char = s.substr(s.length-1);
		}
		return s;
	};

	frappe.get_cookie = function getCookie(name) {
		return frappe.get_cookies()[name];
	};

	frappe.get_cookies = function getCookies() {
		var c = document.cookie, v = 0, cookies = {};
		if (document.cookie.match(/^\s*\$Version=(?:"1"|1);\s*(.*)/)) {
			c = RegExp.$1;
			v = 1;
		}
		if (v === 0) {
			c.split(/[,;]/).map(function(cookie) {
				var parts = cookie.split(/=/, 2),
					name = decodeURIComponent(parts[0].trimLeft()),
					value = parts.length > 1 ? decodeURIComponent(parts[1].trimRight()) : null;
				if(value && value.charAt(0)==='"') {
					value = value.substr(1, value.length-2);
				}
				cookies[name] = value;
			});
		} else {
			c.match(/(?:^|\s+)([!#$%&'*+\-.0-9A-Z^`a-z|~]+)=([!#$%&'*+\-.0-9A-Z^`a-z|~]*|"(?:[\x20-\x7E\x80\xFF]|\\[\x00-\x7F])*")(?=\s*[,;]|$)/g).map(function($0, $1) {
				var name = $0,
					value = $1.charAt(0) === '"'
							? $1.substr(1, -1).replace(/\\(.)/g, "$1")
							: $1;
				cookies[name] = value;
			});
		}
		return cookies;
	};

	frappe.palette = [
		['#FFC4C4', 0],
		['#FFE8CD', 0],
		['#FFD2C2', 0],
		['#FF8989', 0],
		['#FFD19C', 0],
		['#FFA685', 0],
		['#FF4D4D', 1],
		['#FFB868', 0],
		['#FF7846', 1],
		['#A83333', 1],
		['#A87945', 1],
		['#A84F2E', 1],
		['#D2D2FF', 0],
		['#F8D4F8', 0],
		['#DAC7FF', 0],
		['#A3A3FF', 0],
		['#F3AAF0', 0],
		['#B592FF', 0],
		['#7575FF', 0],
		['#EC7DEA', 0],
		['#8E58FF', 1],
		['#4D4DA8', 1],
		['#934F92', 1],
		['#5E3AA8', 1],
		['#EBF8CC', 0],
		['#FFD7D7', 0],
		['#D2F8ED', 0],
		['#D9F399', 0],
		['#FFB1B1', 0],
		['#A4F3DD', 0],
		['#C5EC63', 0],
		['#FF8989', 1],
		['#77ECCA', 0],
		['#7B933D', 1],
		['#A85B5B', 1],
		['#49937E', 1],
		['#FFFACD', 0],
		['#D2F1FF', 0],
		['#CEF6D1', 0],
		['#FFF69C', 0],
		['#A6E4FF', 0],
		['#9DECA2', 0],
		['#FFF168', 0],
		['#78D6FF', 0],
		['#6BE273', 0],
		['#A89F45', 1],
		['#4F8EA8', 1],
		['#428B46', 1]
	];

	frappe.is_mobile = function() {
		return $(document).width() < 768;
	};

	frappe.utils.xss_sanitise = function (string, options) {
		// Reference - https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet
		var sanitised = string; // un-sanitised string.
		var DEFAULT_OPTIONS = {
			strategies: ['html', 'js'] // use all strategies.
		};
		var HTML_ESCAPE_MAP = {
			'<': '&lt',
			'>': '&gt',
			'"': '&quot',
			"'": '&#x27',
			'/': '&#x2F'
		};
		var REGEX_SCRIPT     = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi; // used in jQuery 1.7.2 src/ajax.js Line 14
		options          	   = Object.assign({ }, DEFAULT_OPTIONS, options); // don't deep copy, immutable beauty.

		// Rule 1
		if ( options.strategies.includes('html') ) {
			for (var char in HTML_ESCAPE_MAP) {
				var escape = HTML_ESCAPE_MAP[char];
				var regex = new RegExp(char, "g");
				sanitised = sanitised.replace(regex, escape);
			}
		}

		// Rule 3 - TODO: Check event handlers?
		if ( options.strategies.includes('js') ) {
			sanitised = sanitised.replace(REGEX_SCRIPT, "");
		}

		return sanitised;
	};

	frappe.utils.sanitise_redirect = function (url) {
		var is_external = (function () {
			return function (url) {
				function domain(url) {
					var base_domain = /^(?:https?:\/\/)?(?:[^@\n]+@)?(?:www\.)?([^:/\n?]+)/img.exec(url);
					return base_domain == null ? "" : base_domain[1];
				}

				function is_absolute(url) {
					// returns true for url that have a defined scheme
					// anything else, eg. internal urls return false
					return /^(?:[a-z]+:)?\/\//i.test(url);
				}

				// check for base domain only if the url is absolute
				// return true for relative url (except protocol-relative urls)
				return is_absolute(url) ? domain(location.href) !== domain(url) : false;
			}
		})();

		var sanitise_javascript = (function (url) {
			// please do not ask how or why
			var REGEX_SCRIPT = /j[\s]*(&#x.{1,7})?a[\s]*(&#x.{1,7})?v[\s]*(&#x.{1,7})?a[\s]*(&#x.{1,7})?s[\s]*(&#x.{1,7})?c[\s]*(&#x.{1,7})?r[\s]*(&#x.{1,7})?i[\s]*(&#x.{1,7})?p[\s]*(&#x.{1,7})?t/gi;

			return url.replace(REGEX_SCRIPT, "");
		});

		url = frappe.utils.strip_url(url);

		return is_external(url) ? "" : sanitise_javascript(frappe.utils.xss_sanitise(url, {strategies: ["js"]}));
	};

	frappe.utils.strip_url = function (url) {
		// strips invalid characters from the beginning of the URL
		// in our case, the url can start with either a protocol, //, or even #
		// so anything except those characters can be considered invalid
		return url.replace(/^[^A-Za-z0-9(//)#]+/g, '');
	};

	frappe.utils.new_auto_repeat_prompt = function(frm) {
		var fields = [
			{
				'fieldname': 'frequency',
				'fieldtype': 'Select',
				'label': __('Frequency'),
				'reqd': 1,
				'options': [
					{'label': __('Daily'), 'value': 'Daily'},
					{'label': __('Weekly'), 'value': 'Weekly'},
					{'label': __('Monthly'), 'value': 'Monthly'},
					{'label': __('Quarterly'), 'value': 'Quarterly'},
					{'label': __('Half-yearly'), 'value': 'Half-yearly'},
					{'label': __('Yearly'), 'value': 'Yearly'}
				]
			},
			{
				'fieldname': 'start_date',
				'fieldtype': 'Date',
				'label': __('Start Date'),
				'reqd': 1,
				'default': frappe.datetime.nowdate()
			},
			{
				'fieldname': 'end_date',
				'fieldtype': 'Date',
				'label': __('End Date')
			}
		];
		frappe.prompt(fields, function(values) {
			frappe.call({
				method: "frappe.automation.doctype.auto_repeat.auto_repeat.make_auto_repeat",
				args: {
					'doctype': frm.doc.doctype,
					'docname': frm.doc.name,
					'frequency': values['frequency'],
					'start_date': values['start_date'],
					'end_date': values['end_date']
				},
				callback: function (r) {
					if (r.message) {
						frappe.show_alert({
							'message': __("Auto Repeat created for this document"),
							'indicator': 'green'
						});
						frm.reload_doc();
					}
				}
			});
		},
		__('Auto Repeat'),
		__('Save')
		);
	};

	frappe.utils.get_page_view_count = function(route) {
		return frappe.call("frappe.website.doctype.web_page_view.web_page_view.get_page_view_count", {
			path: route
		});
	};

	frappe.urllib = {
		// get argument from url
		get_arg: function(name) {
			name = name.replace(/[[]/, "\\[").replace(/[\]]/,"\\]");
			var regexS = "[\\?&]"+name+"=([^&#]*)";
			var regex = new RegExp( regexS );
			var results = regex.exec( window.location.href );
			if( results == null )
				{ return ""; }
			else
				{ return decodeURIComponent(results[1]); }
		},

		// returns url dictionary
		get_dict: function() {
			var d = {};
			var t = window.location.href.split('?')[1];
			if(!t) { return d; }

			if(t.indexOf('#')!=-1) { t = t.split('#')[0]; }
			if(!t) { return d; }

			t = t.split('&');
			for(var i=0; i<t.length; i++) {
				var a = t[i].split('=');
				d[decodeURIComponent(a[0])] = decodeURIComponent(a[1]);
			}
			return d;
		},

		// returns the base url with http + domain + path (-index.cgi or # or ?)
		get_base_url: function() {
			// var url= (frappe.base_url || window.location.href).split('#')[0].split('?')[0].split('desk')[0];
			var url = (frappe.base_url || window.location.origin);
			if(url.substr(url.length-1, 1)=='/') { url = url.substr(0, url.length-1); }
			return url;
		},

		// returns absolute url
		get_full_url: function(url) {
			if(url.indexOf("http://")===0 || url.indexOf("https://")===0) {
				return url;
			}
			return url.substr(0,1)==="/" ?
				(frappe.urllib.get_base_url() + url) :
				(frappe.urllib.get_base_url() + "/" + url);
		}
	};

	window.open_url_post = function open_url_post(URL, PARAMS, new_window) {
		if (window.cordova) {
			var url = URL + 'api/method/' + PARAMS.cmd + frappe.utils.make_query_string(PARAMS, false);
			window.location.href = url;
		} else {
			// call a url as POST
			var temp=document.createElement("form");
			temp.action=URL;
			temp.method="POST";
			temp.style.display="none";
			if(new_window){
				temp.target = '_blank';
			}
			PARAMS["csrf_token"] = frappe.csrf_token;
			for(var x in PARAMS) {
				var opt=document.createElement("textarea");
				opt.name=x;
				var val = PARAMS[x];
				if(typeof val!='string')
					{ val = JSON.stringify(val); }
				opt.value=val;
				temp.appendChild(opt);
			}
			document.body.appendChild(temp);
			temp.submit();
			return temp;
		}
	};

	window.get_url_arg = frappe.urllib.get_arg;
	window.get_url_dict = frappe.urllib.get_dict;

	function prettyDate(date, mini) {
		if (!date) { return ''; }

		if (typeof (date) == "string") {
			date = frappe.datetime.convert_to_user_tz(date);
			date = new Date((date || "").replace(/-/g, "/").replace(/[TZ]/g, " ").replace(/\.[0-9]*/, ""));
		}

		var diff = (((new Date()).getTime() - date.getTime()) / 1000);
		var day_diff = Math.floor(diff / 86400);

		if (isNaN(day_diff) || day_diff < 0) { return ''; }

		if (mini) {
			// Return short format of time difference
			if (day_diff == 0) {
				if (diff < 60) {
					return __("now");
				} else if (diff < 3600) {
					return __("{0} m", [Math.floor(diff / 60)]);
				} else if (diff < 86400) {
					return __("{0} h", [Math.floor(diff / 3600)]);
				}
			} else {
				if (day_diff < 7) {
					return __("{0} d", [day_diff]);
				} else if (day_diff < 31) {
					return __("{0} w", [Math.ceil(day_diff / 7)]);
				} else if (day_diff < 365) {
					return __("{0} M", [Math.ceil(day_diff / 30)]);
				} else {
					return __("{0} y", [Math.ceil(day_diff / 365)]);
				}
			}
		} else {
			// Return long format of time difference
			if (day_diff == 0) {
				if (diff < 60) {
					return __("just now");
				} else if (diff < 120) {
					return __("1 minute ago");
				} else if (diff < 3600) {
					return __("{0} minutes ago", [Math.floor(diff / 60)]);
				} else if (diff < 7200) {
					return __("1 hour ago");
				} else if (diff < 86400) {
					return __("{0} hours ago", [Math.floor(diff / 3600)]);
				}
			} else {
				if (day_diff == 1) {
					return __("yesterday");
				} else if (day_diff < 7) {
					return __("{0} days ago", [day_diff]);
				} else if (day_diff < 14) {
					return __("1 week ago");
				} else if (day_diff < 31) {
					return __("{0} weeks ago", [Math.ceil(day_diff / 7)]);
				} else if (day_diff < 62) {
					return __("1 month ago");
				} else if (day_diff < 365) {
					return __("{0} months ago", [Math.ceil(day_diff / 30)]);
				} else if (day_diff < 730) {
					return __("1 year ago");
				} else {
					return __("{0} years ago", [Math.ceil(day_diff / 365)]);
				}
			}
		}
	}

	frappe.provide("frappe.datetime");
	window.comment_when = function(datetime, mini) {
		var timestamp = frappe.datetime.str_to_user ?
			frappe.datetime.str_to_user(datetime) : datetime;
		return '<span class="frappe-timestamp '
			+ (mini ? " mini" : "") + '" data-timestamp="' + datetime
			+ '" title="' + timestamp + '">'
			+ prettyDate(datetime, mini) + '</span>';
	};
	frappe.datetime.comment_when = comment_when;
	frappe.datetime.prettyDate = prettyDate;

	frappe.datetime.refresh_when = function() {
		if (jQuery) {
			$(".frappe-timestamp").each(function() {
				$(this).html(prettyDate($(this).attr("data-timestamp"), $(this).hasClass("mini")));
			});
		}
	};

	setInterval(function() {
		frappe.datetime.refresh_when();
	}, 60000); // refresh every minute

	// for testing
	frappe.click_button = function(text, idx) {
		var container = '';
		if(typeof idx === 'string') {
			container = idx + ' ';
			idx = 0;
		}
		var element = $((container + ".btn:contains(\"" + text + "\"):visible"));
		if(!element.length) {
			throw ("did not find any button containing " + text);
		}
		element.get(idx || 0).click();
		return frappe.timeout(0.5);
	};

	frappe.click_link = function(text, idx) {
		var element = $(("a:contains(\"" + text + "\"):visible"));
		if(!element.length) {
			throw ("did not find any link containing " + text);
		}
		element.get(idx || 0).click();
		return frappe.timeout(0.5);
	};

	frappe.click_element = function(selector, idx) {
		// Selector by class name like $(`.cart-items`)
		var element = $(("" + selector));
		if(!element.length) {
			throw ("did not find any link containing " + selector);
		}
		element.get(idx || 0).click();
		return frappe.timeout(0.5);
	};

	frappe.set_control= function(fieldname, value) {
		var control = $((".form-control[data-fieldname=\"" + fieldname + "\"]:visible"));
		if(!control.length) {
			throw ("did not find any control with fieldname " + fieldname);
		}
		control.val(value).trigger('change');
		return frappe.timeout(0.5);
	};

	frappe.click_check = function(label, idx) {
		var check = $((".checkbox:contains(\"" + label + "\") input"));
		if(!check.length) {
			throw ("did not find any checkbox with label " + label);
		}
		check.get(idx || 0).click();
		return frappe.timeout(0.5);
	};

	var showdown = createCommonjsModule(function (module) {
	(function(){
	/**
	 * Created by Tivie on 13-07-2015.
	 */

	function getDefaultOpts (simple) {

	  var defaultOptions = {
	    omitExtraWLInCodeBlocks: {
	      defaultValue: false,
	      describe: 'Omit the default extra whiteline added to code blocks',
	      type: 'boolean'
	    },
	    noHeaderId: {
	      defaultValue: false,
	      describe: 'Turn on/off generated header id',
	      type: 'boolean'
	    },
	    prefixHeaderId: {
	      defaultValue: false,
	      describe: 'Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic \'section-\' prefix',
	      type: 'string'
	    },
	    rawPrefixHeaderId: {
	      defaultValue: false,
	      describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
	      type: 'boolean'
	    },
	    ghCompatibleHeaderId: {
	      defaultValue: false,
	      describe: 'Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)',
	      type: 'boolean'
	    },
	    rawHeaderId: {
	      defaultValue: false,
	      describe: 'Remove only spaces, \' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids',
	      type: 'boolean'
	    },
	    headerLevelStart: {
	      defaultValue: false,
	      describe: 'The header blocks level start',
	      type: 'integer'
	    },
	    parseImgDimensions: {
	      defaultValue: false,
	      describe: 'Turn on/off image dimension parsing',
	      type: 'boolean'
	    },
	    simplifiedAutoLink: {
	      defaultValue: false,
	      describe: 'Turn on/off GFM autolink style',
	      type: 'boolean'
	    },
	    excludeTrailingPunctuationFromURLs: {
	      defaultValue: false,
	      describe: 'Excludes trailing punctuation from links generated with autoLinking',
	      type: 'boolean'
	    },
	    literalMidWordUnderscores: {
	      defaultValue: false,
	      describe: 'Parse midword underscores as literal underscores',
	      type: 'boolean'
	    },
	    literalMidWordAsterisks: {
	      defaultValue: false,
	      describe: 'Parse midword asterisks as literal asterisks',
	      type: 'boolean'
	    },
	    strikethrough: {
	      defaultValue: false,
	      describe: 'Turn on/off strikethrough support',
	      type: 'boolean'
	    },
	    tables: {
	      defaultValue: false,
	      describe: 'Turn on/off tables support',
	      type: 'boolean'
	    },
	    tablesHeaderId: {
	      defaultValue: false,
	      describe: 'Add an id to table headers',
	      type: 'boolean'
	    },
	    ghCodeBlocks: {
	      defaultValue: true,
	      describe: 'Turn on/off GFM fenced code blocks support',
	      type: 'boolean'
	    },
	    tasklists: {
	      defaultValue: false,
	      describe: 'Turn on/off GFM tasklist support',
	      type: 'boolean'
	    },
	    smoothLivePreview: {
	      defaultValue: false,
	      describe: 'Prevents weird effects in live previews due to incomplete input',
	      type: 'boolean'
	    },
	    smartIndentationFix: {
	      defaultValue: false,
	      description: 'Tries to smartly fix indentation in es6 strings',
	      type: 'boolean'
	    },
	    disableForced4SpacesIndentedSublists: {
	      defaultValue: false,
	      description: 'Disables the requirement of indenting nested sublists by 4 spaces',
	      type: 'boolean'
	    },
	    simpleLineBreaks: {
	      defaultValue: false,
	      description: 'Parses simple line breaks as <br> (GFM Style)',
	      type: 'boolean'
	    },
	    requireSpaceBeforeHeadingText: {
	      defaultValue: false,
	      description: 'Makes adding a space between `#` and the header text mandatory (GFM Style)',
	      type: 'boolean'
	    },
	    ghMentions: {
	      defaultValue: false,
	      description: 'Enables github @mentions',
	      type: 'boolean'
	    },
	    ghMentionsLink: {
	      defaultValue: 'https://github.com/{u}',
	      description: 'Changes the link generated by @mentions. Only applies if ghMentions option is enabled.',
	      type: 'string'
	    },
	    encodeEmails: {
	      defaultValue: true,
	      description: 'Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities',
	      type: 'boolean'
	    },
	    openLinksInNewWindow: {
	      defaultValue: false,
	      description: 'Open all links in new windows',
	      type: 'boolean'
	    },
	    backslashEscapesHTMLTags: {
	      defaultValue: false,
	      description: 'Support for HTML Tag escaping. ex: \<div>foo\</div>',
	      type: 'boolean'
	    },
	    emoji: {
	      defaultValue: false,
	      description: 'Enable emoji support. Ex: `this is a :smile: emoji`',
	      type: 'boolean'
	    },
	    underline: {
	      defaultValue: false,
	      description: 'Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`',
	      type: 'boolean'
	    },
	    completeHTMLDocument: {
	      defaultValue: false,
	      description: 'Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags',
	      type: 'boolean'
	    },
	    metadata: {
	      defaultValue: false,
	      description: 'Enable support for document metadata (defined at the top of the document between `«««` and `»»»` or between `---` and `---`).',
	      type: 'boolean'
	    },
	    splitAdjacentBlockquotes: {
	      defaultValue: false,
	      description: 'Split adjacent blockquote blocks',
	      type: 'boolean'
	    }
	  };
	  if (simple === false) {
	    return JSON.parse(JSON.stringify(defaultOptions));
	  }
	  var ret = {};
	  for (var opt in defaultOptions) {
	    if (defaultOptions.hasOwnProperty(opt)) {
	      ret[opt] = defaultOptions[opt].defaultValue;
	    }
	  }
	  return ret;
	}

	function allOptionsOn () {
	  var options = getDefaultOpts(true),
	      ret = {};
	  for (var opt in options) {
	    if (options.hasOwnProperty(opt)) {
	      ret[opt] = true;
	    }
	  }
	  return ret;
	}

	/**
	 * Created by Tivie on 06-01-2015.
	 */

	// Private properties
	var showdown = {},
	    parsers = {},
	    extensions = {},
	    globalOptions = getDefaultOpts(true),
	    setFlavor = 'vanilla',
	    flavor = {
	      github: {
	        omitExtraWLInCodeBlocks:              true,
	        simplifiedAutoLink:                   true,
	        excludeTrailingPunctuationFromURLs:   true,
	        literalMidWordUnderscores:            true,
	        strikethrough:                        true,
	        tables:                               true,
	        tablesHeaderId:                       true,
	        ghCodeBlocks:                         true,
	        tasklists:                            true,
	        disableForced4SpacesIndentedSublists: true,
	        simpleLineBreaks:                     true,
	        requireSpaceBeforeHeadingText:        true,
	        ghCompatibleHeaderId:                 true,
	        ghMentions:                           true,
	        backslashEscapesHTMLTags:             true,
	        emoji:                                true,
	        splitAdjacentBlockquotes:             true
	      },
	      original: {
	        noHeaderId:                           true,
	        ghCodeBlocks:                         false
	      },
	      ghost: {
	        omitExtraWLInCodeBlocks:              true,
	        parseImgDimensions:                   true,
	        simplifiedAutoLink:                   true,
	        excludeTrailingPunctuationFromURLs:   true,
	        literalMidWordUnderscores:            true,
	        strikethrough:                        true,
	        tables:                               true,
	        tablesHeaderId:                       true,
	        ghCodeBlocks:                         true,
	        tasklists:                            true,
	        smoothLivePreview:                    true,
	        simpleLineBreaks:                     true,
	        requireSpaceBeforeHeadingText:        true,
	        ghMentions:                           false,
	        encodeEmails:                         true
	      },
	      vanilla: getDefaultOpts(true),
	      allOn: allOptionsOn()
	    };

	/**
	 * helper namespace
	 * @type {{}}
	 */
	showdown.helper = {};

	/**
	 * TODO LEGACY SUPPORT CODE
	 * @type {{}}
	 */
	showdown.extensions = {};

	/**
	 * Set a global option
	 * @static
	 * @param {string} key
	 * @param {*} value
	 * @returns {showdown}
	 */
	showdown.setOption = function (key, value) {
	  globalOptions[key] = value;
	  return this;
	};

	/**
	 * Get a global option
	 * @static
	 * @param {string} key
	 * @returns {*}
	 */
	showdown.getOption = function (key) {
	  return globalOptions[key];
	};

	/**
	 * Get the global options
	 * @static
	 * @returns {{}}
	 */
	showdown.getOptions = function () {
	  return globalOptions;
	};

	/**
	 * Reset global options to the default values
	 * @static
	 */
	showdown.resetOptions = function () {
	  globalOptions = getDefaultOpts(true);
	};

	/**
	 * Set the flavor showdown should use as default
	 * @param {string} name
	 */
	showdown.setFlavor = function (name) {
	  if (!flavor.hasOwnProperty(name)) {
	    throw Error(name + ' flavor was not found');
	  }
	  showdown.resetOptions();
	  var preset = flavor[name];
	  setFlavor = name;
	  for (var option in preset) {
	    if (preset.hasOwnProperty(option)) {
	      globalOptions[option] = preset[option];
	    }
	  }
	};

	/**
	 * Get the currently set flavor
	 * @returns {string}
	 */
	showdown.getFlavor = function () {
	  return setFlavor;
	};

	/**
	 * Get the options of a specified flavor. Returns undefined if the flavor was not found
	 * @param {string} name Name of the flavor
	 * @returns {{}|undefined}
	 */
	showdown.getFlavorOptions = function (name) {
	  if (flavor.hasOwnProperty(name)) {
	    return flavor[name];
	  }
	};

	/**
	 * Get the default options
	 * @static
	 * @param {boolean} [simple=true]
	 * @returns {{}}
	 */
	showdown.getDefaultOptions = function (simple) {
	  return getDefaultOpts(simple);
	};

	/**
	 * Get or set a subParser
	 *
	 * subParser(name)       - Get a registered subParser
	 * subParser(name, func) - Register a subParser
	 * @static
	 * @param {string} name
	 * @param {function} [func]
	 * @returns {*}
	 */
	showdown.subParser = function (name, func) {
	  if (showdown.helper.isString(name)) {
	    if (typeof func !== 'undefined') {
	      parsers[name] = func;
	    } else {
	      if (parsers.hasOwnProperty(name)) {
	        return parsers[name];
	      } else {
	        throw Error('SubParser named ' + name + ' not registered!');
	      }
	    }
	  }
	};

	/**
	 * Gets or registers an extension
	 * @static
	 * @param {string} name
	 * @param {object|function=} ext
	 * @returns {*}
	 */
	showdown.extension = function (name, ext) {

	  if (!showdown.helper.isString(name)) {
	    throw Error('Extension \'name\' must be a string');
	  }

	  name = showdown.helper.stdExtName(name);

	  // Getter
	  if (showdown.helper.isUndefined(ext)) {
	    if (!extensions.hasOwnProperty(name)) {
	      throw Error('Extension named ' + name + ' is not registered!');
	    }
	    return extensions[name];

	    // Setter
	  } else {
	    // Expand extension if it's wrapped in a function
	    if (typeof ext === 'function') {
	      ext = ext();
	    }

	    // Ensure extension is an array
	    if (!showdown.helper.isArray(ext)) {
	      ext = [ext];
	    }

	    var validExtension = validate(ext, name);

	    if (validExtension.valid) {
	      extensions[name] = ext;
	    } else {
	      throw Error(validExtension.error);
	    }
	  }
	};

	/**
	 * Gets all extensions registered
	 * @returns {{}}
	 */
	showdown.getAllExtensions = function () {
	  return extensions;
	};

	/**
	 * Remove an extension
	 * @param {string} name
	 */
	showdown.removeExtension = function (name) {
	  delete extensions[name];
	};

	/**
	 * Removes all extensions
	 */
	showdown.resetExtensions = function () {
	  extensions = {};
	};

	/**
	 * Validate extension
	 * @param {array} extension
	 * @param {string} name
	 * @returns {{valid: boolean, error: string}}
	 */
	function validate (extension, name) {

	  var errMsg = (name) ? 'Error in ' + name + ' extension->' : 'Error in unnamed extension',
	      ret = {
	        valid: true,
	        error: ''
	      };

	  if (!showdown.helper.isArray(extension)) {
	    extension = [extension];
	  }

	  for (var i = 0; i < extension.length; ++i) {
	    var baseMsg = errMsg + ' sub-extension ' + i + ': ',
	        ext = extension[i];
	    if (typeof ext !== 'object') {
	      ret.valid = false;
	      ret.error = baseMsg + 'must be an object, but ' + typeof ext + ' given';
	      return ret;
	    }

	    if (!showdown.helper.isString(ext.type)) {
	      ret.valid = false;
	      ret.error = baseMsg + 'property "type" must be a string, but ' + typeof ext.type + ' given';
	      return ret;
	    }

	    var type = ext.type = ext.type.toLowerCase();

	    // normalize extension type
	    if (type === 'language') {
	      type = ext.type = 'lang';
	    }

	    if (type === 'html') {
	      type = ext.type = 'output';
	    }

	    if (type !== 'lang' && type !== 'output' && type !== 'listener') {
	      ret.valid = false;
	      ret.error = baseMsg + 'type ' + type + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"';
	      return ret;
	    }

	    if (type === 'listener') {
	      if (showdown.helper.isUndefined(ext.listeners)) {
	        ret.valid = false;
	        ret.error = baseMsg + '. Extensions of type "listener" must have a property called "listeners"';
	        return ret;
	      }
	    } else {
	      if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {
	        ret.valid = false;
	        ret.error = baseMsg + type + ' extensions must define either a "regex" property or a "filter" method';
	        return ret;
	      }
	    }

	    if (ext.listeners) {
	      if (typeof ext.listeners !== 'object') {
	        ret.valid = false;
	        ret.error = baseMsg + '"listeners" property must be an object but ' + typeof ext.listeners + ' given';
	        return ret;
	      }
	      for (var ln in ext.listeners) {
	        if (ext.listeners.hasOwnProperty(ln)) {
	          if (typeof ext.listeners[ln] !== 'function') {
	            ret.valid = false;
	            ret.error = baseMsg + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + ln +
	              ' must be a function but ' + typeof ext.listeners[ln] + ' given';
	            return ret;
	          }
	        }
	      }
	    }

	    if (ext.filter) {
	      if (typeof ext.filter !== 'function') {
	        ret.valid = false;
	        ret.error = baseMsg + '"filter" must be a function, but ' + typeof ext.filter + ' given';
	        return ret;
	      }
	    } else if (ext.regex) {
	      if (showdown.helper.isString(ext.regex)) {
	        ext.regex = new RegExp(ext.regex, 'g');
	      }
	      if (!(ext.regex instanceof RegExp)) {
	        ret.valid = false;
	        ret.error = baseMsg + '"regex" property must either be a string or a RegExp object, but ' + typeof ext.regex + ' given';
	        return ret;
	      }
	      if (showdown.helper.isUndefined(ext.replace)) {
	        ret.valid = false;
	        ret.error = baseMsg + '"regex" extensions must implement a replace string or function';
	        return ret;
	      }
	    }
	  }
	  return ret;
	}

	/**
	 * Validate extension
	 * @param {object} ext
	 * @returns {boolean}
	 */
	showdown.validateExtension = function (ext) {

	  var validateExtension = validate(ext, null);
	  if (!validateExtension.valid) {
	    console.warn(validateExtension.error);
	    return false;
	  }
	  return true;
	};

	/**
	 * showdownjs helper functions
	 */

	if (!showdown.hasOwnProperty('helper')) {
	  showdown.helper = {};
	}

	/**
	 * Check if var is string
	 * @static
	 * @param {string} a
	 * @returns {boolean}
	 */
	showdown.helper.isString = function (a) {
	  return (typeof a === 'string' || a instanceof String);
	};

	/**
	 * Check if var is a function
	 * @static
	 * @param {*} a
	 * @returns {boolean}
	 */
	showdown.helper.isFunction = function (a) {
	  var getType = {};
	  return a && getType.toString.call(a) === '[object Function]';
	};

	/**
	 * isArray helper function
	 * @static
	 * @param {*} a
	 * @returns {boolean}
	 */
	showdown.helper.isArray = function (a) {
	  return Array.isArray(a);
	};

	/**
	 * Check if value is undefined
	 * @static
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	 */
	showdown.helper.isUndefined = function (value) {
	  return typeof value === 'undefined';
	};

	/**
	 * ForEach helper function
	 * Iterates over Arrays and Objects (own properties only)
	 * @static
	 * @param {*} obj
	 * @param {function} callback Accepts 3 params: 1. value, 2. key, 3. the original array/object
	 */
	showdown.helper.forEach = function (obj, callback) {
	  // check if obj is defined
	  if (showdown.helper.isUndefined(obj)) {
	    throw new Error('obj param is required');
	  }

	  if (showdown.helper.isUndefined(callback)) {
	    throw new Error('callback param is required');
	  }

	  if (!showdown.helper.isFunction(callback)) {
	    throw new Error('callback param must be a function/closure');
	  }

	  if (typeof obj.forEach === 'function') {
	    obj.forEach(callback);
	  } else if (showdown.helper.isArray(obj)) {
	    for (var i = 0; i < obj.length; i++) {
	      callback(obj[i], i, obj);
	    }
	  } else if (typeof (obj) === 'object') {
	    for (var prop in obj) {
	      if (obj.hasOwnProperty(prop)) {
	        callback(obj[prop], prop, obj);
	      }
	    }
	  } else {
	    throw new Error('obj does not seem to be an array or an iterable object');
	  }
	};

	/**
	 * Standardidize extension name
	 * @static
	 * @param {string} s extension name
	 * @returns {string}
	 */
	showdown.helper.stdExtName = function (s) {
	  return s.replace(/[_?*+\/\\.^-]/g, '').replace(/\s/g, '').toLowerCase();
	};

	function escapeCharactersCallback (wholeMatch, m1) {
	  var charCodeToEscape = m1.charCodeAt(0);
	  return '¨E' + charCodeToEscape + 'E';
	}

	/**
	 * Callback used to escape characters when passing through String.replace
	 * @static
	 * @param {string} wholeMatch
	 * @param {string} m1
	 * @returns {string}
	 */
	showdown.helper.escapeCharactersCallback = escapeCharactersCallback;

	/**
	 * Escape characters in a string
	 * @static
	 * @param {string} text
	 * @param {string} charsToEscape
	 * @param {boolean} afterBackslash
	 * @returns {XML|string|void|*}
	 */
	showdown.helper.escapeCharacters = function (text, charsToEscape, afterBackslash) {
	  // First we have to escape the escape characters so that
	  // we can build a character class out of them
	  var regexString = '([' + charsToEscape.replace(/([\[\]\\])/g, '\\$1') + '])';

	  if (afterBackslash) {
	    regexString = '\\\\' + regexString;
	  }

	  var regex = new RegExp(regexString, 'g');
	  text = text.replace(regex, escapeCharactersCallback);

	  return text;
	};

	/**
	 * Unescape HTML entities
	 * @param txt
	 * @returns {string}
	 */
	showdown.helper.unescapeHTMLEntities = function (txt) {

	  return txt
	    .replace(/&quot;/g, '"')
	    .replace(/&lt;/g, '<')
	    .replace(/&gt;/g, '>')
	    .replace(/&amp;/g, '&');
	};

	var rgxFindMatchPos = function (str, left, right, flags) {
	  var f = flags || '',
	      g = f.indexOf('g') > -1,
	      x = new RegExp(left + '|' + right, 'g' + f.replace(/g/g, '')),
	      l = new RegExp(left, f.replace(/g/g, '')),
	      pos = [],
	      t, s, m, start, end;

	  do {
	    t = 0;
	    while ((m = x.exec(str))) {
	      if (l.test(m[0])) {
	        if (!(t++)) {
	          s = x.lastIndex;
	          start = s - m[0].length;
	        }
	      } else if (t) {
	        if (!--t) {
	          end = m.index + m[0].length;
	          var obj = {
	            left: {start: start, end: s},
	            match: {start: s, end: m.index},
	            right: {start: m.index, end: end},
	            wholeMatch: {start: start, end: end}
	          };
	          pos.push(obj);
	          if (!g) {
	            return pos;
	          }
	        }
	      }
	    }
	  } while (t && (x.lastIndex = s));

	  return pos;
	};

	/**
	 * matchRecursiveRegExp
	 *
	 * (c) 2007 Steven Levithan <stevenlevithan.com>
	 * MIT License
	 *
	 * Accepts a string to search, a left and right format delimiter
	 * as regex patterns, and optional regex flags. Returns an array
	 * of matches, allowing nested instances of left/right delimiters.
	 * Use the "g" flag to return all matches, otherwise only the
	 * first is returned. Be careful to ensure that the left and
	 * right format delimiters produce mutually exclusive matches.
	 * Backreferences are not supported within the right delimiter
	 * due to how it is internally combined with the left delimiter.
	 * When matching strings whose format delimiters are unbalanced
	 * to the left or right, the output is intentionally as a
	 * conventional regex library with recursion support would
	 * produce, e.g. "<<x>" and "<x>>" both produce ["x"] when using
	 * "<" and ">" as the delimiters (both strings contain a single,
	 * balanced instance of "<x>").
	 *
	 * examples:
	 * matchRecursiveRegExp("test", "\\(", "\\)")
	 * returns: []
	 * matchRecursiveRegExp("<t<<e>><s>>t<>", "<", ">", "g")
	 * returns: ["t<<e>><s>", ""]
	 * matchRecursiveRegExp("<div id=\"x\">test</div>", "<div\\b[^>]*>", "</div>", "gi")
	 * returns: ["test"]
	 */
	showdown.helper.matchRecursiveRegExp = function (str, left, right, flags) {

	  var matchPos = rgxFindMatchPos (str, left, right, flags),
	      results = [];

	  for (var i = 0; i < matchPos.length; ++i) {
	    results.push([
	      str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
	      str.slice(matchPos[i].match.start, matchPos[i].match.end),
	      str.slice(matchPos[i].left.start, matchPos[i].left.end),
	      str.slice(matchPos[i].right.start, matchPos[i].right.end)
	    ]);
	  }
	  return results;
	};

	/**
	 *
	 * @param {string} str
	 * @param {string|function} replacement
	 * @param {string} left
	 * @param {string} right
	 * @param {string} flags
	 * @returns {string}
	 */
	showdown.helper.replaceRecursiveRegExp = function (str, replacement, left, right, flags) {

	  if (!showdown.helper.isFunction(replacement)) {
	    var repStr = replacement;
	    replacement = function () {
	      return repStr;
	    };
	  }

	  var matchPos = rgxFindMatchPos(str, left, right, flags),
	      finalStr = str,
	      lng = matchPos.length;

	  if (lng > 0) {
	    var bits = [];
	    if (matchPos[0].wholeMatch.start !== 0) {
	      bits.push(str.slice(0, matchPos[0].wholeMatch.start));
	    }
	    for (var i = 0; i < lng; ++i) {
	      bits.push(
	        replacement(
	          str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
	          str.slice(matchPos[i].match.start, matchPos[i].match.end),
	          str.slice(matchPos[i].left.start, matchPos[i].left.end),
	          str.slice(matchPos[i].right.start, matchPos[i].right.end)
	        )
	      );
	      if (i < lng - 1) {
	        bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));
	      }
	    }
	    if (matchPos[lng - 1].wholeMatch.end < str.length) {
	      bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));
	    }
	    finalStr = bits.join('');
	  }
	  return finalStr;
	};

	/**
	 * Returns the index within the passed String object of the first occurrence of the specified regex,
	 * starting the search at fromIndex. Returns -1 if the value is not found.
	 *
	 * @param {string} str string to search
	 * @param {RegExp} regex Regular expression to search
	 * @param {int} [fromIndex = 0] Index to start the search
	 * @returns {Number}
	 * @throws InvalidArgumentError
	 */
	showdown.helper.regexIndexOf = function (str, regex, fromIndex) {
	  if (!showdown.helper.isString(str)) {
	    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
	  }
	  if (regex instanceof RegExp === false) {
	    throw 'InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp';
	  }
	  var indexOf = str.substring(fromIndex || 0).search(regex);
	  return (indexOf >= 0) ? (indexOf + (fromIndex || 0)) : indexOf;
	};

	/**
	 * Splits the passed string object at the defined index, and returns an array composed of the two substrings
	 * @param {string} str string to split
	 * @param {int} index index to split string at
	 * @returns {[string,string]}
	 * @throws InvalidArgumentError
	 */
	showdown.helper.splitAtIndex = function (str, index) {
	  if (!showdown.helper.isString(str)) {
	    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
	  }
	  return [str.substring(0, index), str.substring(index)];
	};

	/**
	 * Obfuscate an e-mail address through the use of Character Entities,
	 * transforming ASCII characters into their equivalent decimal or hex entities.
	 *
	 * Since it has a random component, subsequent calls to this function produce different results
	 *
	 * @param {string} mail
	 * @returns {string}
	 */
	showdown.helper.encodeEmailAddress = function (mail) {
	  var encode = [
	    function (ch) {
	      return '&#' + ch.charCodeAt(0) + ';';
	    },
	    function (ch) {
	      return '&#x' + ch.charCodeAt(0).toString(16) + ';';
	    },
	    function (ch) {
	      return ch;
	    }
	  ];

	  mail = mail.replace(/./g, function (ch) {
	    if (ch === '@') {
	      // this *must* be encoded. I insist.
	      ch = encode[Math.floor(Math.random() * 2)](ch);
	    } else {
	      var r = Math.random();
	      // roughly 10% raw, 45% hex, 45% dec
	      ch = (
	        r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch)
	      );
	    }
	    return ch;
	  });

	  return mail;
	};

	/**
	 *
	 * @param str
	 * @param targetLength
	 * @param padString
	 * @returns {string}
	 */
	showdown.helper.padEnd = function padEnd (str, targetLength, padString) {
	  /*jshint bitwise: false*/
	  // eslint-disable-next-line space-infix-ops
	  targetLength = targetLength>>0; //floor if number or convert non-number to 0;
	  /*jshint bitwise: true*/
	  padString = String(padString || ' ');
	  if (str.length > targetLength) {
	    return String(str);
	  } else {
	    targetLength = targetLength - str.length;
	    if (targetLength > padString.length) {
	      padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
	    }
	    return String(str) + padString.slice(0,targetLength);
	  }
	};

	/**
	 * POLYFILLS
	 */
	// use this instead of builtin is undefined for IE8 compatibility
	if (typeof console === 'undefined') {
	  console = {
	    warn: function (msg) {
	      alert(msg);
	    },
	    log: function (msg) {
	      alert(msg);
	    },
	    error: function (msg) {
	      throw msg;
	    }
	  };
	}

	/**
	 * Common regexes.
	 * We declare some common regexes to improve performance
	 */
	showdown.helper.regexes = {
	  asteriskDashAndColon: /([*_:~])/g
	};

	/**
	 * EMOJIS LIST
	 */
	showdown.helper.emojis = {
	  '+1':'\ud83d\udc4d',
	  '-1':'\ud83d\udc4e',
	  '100':'\ud83d\udcaf',
	  '1234':'\ud83d\udd22',
	  '1st_place_medal':'\ud83e\udd47',
	  '2nd_place_medal':'\ud83e\udd48',
	  '3rd_place_medal':'\ud83e\udd49',
	  '8ball':'\ud83c\udfb1',
	  'a':'\ud83c\udd70\ufe0f',
	  'ab':'\ud83c\udd8e',
	  'abc':'\ud83d\udd24',
	  'abcd':'\ud83d\udd21',
	  'accept':'\ud83c\ude51',
	  'aerial_tramway':'\ud83d\udea1',
	  'airplane':'\u2708\ufe0f',
	  'alarm_clock':'\u23f0',
	  'alembic':'\u2697\ufe0f',
	  'alien':'\ud83d\udc7d',
	  'ambulance':'\ud83d\ude91',
	  'amphora':'\ud83c\udffa',
	  'anchor':'\u2693\ufe0f',
	  'angel':'\ud83d\udc7c',
	  'anger':'\ud83d\udca2',
	  'angry':'\ud83d\ude20',
	  'anguished':'\ud83d\ude27',
	  'ant':'\ud83d\udc1c',
	  'apple':'\ud83c\udf4e',
	  'aquarius':'\u2652\ufe0f',
	  'aries':'\u2648\ufe0f',
	  'arrow_backward':'\u25c0\ufe0f',
	  'arrow_double_down':'\u23ec',
	  'arrow_double_up':'\u23eb',
	  'arrow_down':'\u2b07\ufe0f',
	  'arrow_down_small':'\ud83d\udd3d',
	  'arrow_forward':'\u25b6\ufe0f',
	  'arrow_heading_down':'\u2935\ufe0f',
	  'arrow_heading_up':'\u2934\ufe0f',
	  'arrow_left':'\u2b05\ufe0f',
	  'arrow_lower_left':'\u2199\ufe0f',
	  'arrow_lower_right':'\u2198\ufe0f',
	  'arrow_right':'\u27a1\ufe0f',
	  'arrow_right_hook':'\u21aa\ufe0f',
	  'arrow_up':'\u2b06\ufe0f',
	  'arrow_up_down':'\u2195\ufe0f',
	  'arrow_up_small':'\ud83d\udd3c',
	  'arrow_upper_left':'\u2196\ufe0f',
	  'arrow_upper_right':'\u2197\ufe0f',
	  'arrows_clockwise':'\ud83d\udd03',
	  'arrows_counterclockwise':'\ud83d\udd04',
	  'art':'\ud83c\udfa8',
	  'articulated_lorry':'\ud83d\ude9b',
	  'artificial_satellite':'\ud83d\udef0',
	  'astonished':'\ud83d\ude32',
	  'athletic_shoe':'\ud83d\udc5f',
	  'atm':'\ud83c\udfe7',
	  'atom_symbol':'\u269b\ufe0f',
	  'avocado':'\ud83e\udd51',
	  'b':'\ud83c\udd71\ufe0f',
	  'baby':'\ud83d\udc76',
	  'baby_bottle':'\ud83c\udf7c',
	  'baby_chick':'\ud83d\udc24',
	  'baby_symbol':'\ud83d\udebc',
	  'back':'\ud83d\udd19',
	  'bacon':'\ud83e\udd53',
	  'badminton':'\ud83c\udff8',
	  'baggage_claim':'\ud83d\udec4',
	  'baguette_bread':'\ud83e\udd56',
	  'balance_scale':'\u2696\ufe0f',
	  'balloon':'\ud83c\udf88',
	  'ballot_box':'\ud83d\uddf3',
	  'ballot_box_with_check':'\u2611\ufe0f',
	  'bamboo':'\ud83c\udf8d',
	  'banana':'\ud83c\udf4c',
	  'bangbang':'\u203c\ufe0f',
	  'bank':'\ud83c\udfe6',
	  'bar_chart':'\ud83d\udcca',
	  'barber':'\ud83d\udc88',
	  'baseball':'\u26be\ufe0f',
	  'basketball':'\ud83c\udfc0',
	  'basketball_man':'\u26f9\ufe0f',
	  'basketball_woman':'\u26f9\ufe0f&zwj;\u2640\ufe0f',
	  'bat':'\ud83e\udd87',
	  'bath':'\ud83d\udec0',
	  'bathtub':'\ud83d\udec1',
	  'battery':'\ud83d\udd0b',
	  'beach_umbrella':'\ud83c\udfd6',
	  'bear':'\ud83d\udc3b',
	  'bed':'\ud83d\udecf',
	  'bee':'\ud83d\udc1d',
	  'beer':'\ud83c\udf7a',
	  'beers':'\ud83c\udf7b',
	  'beetle':'\ud83d\udc1e',
	  'beginner':'\ud83d\udd30',
	  'bell':'\ud83d\udd14',
	  'bellhop_bell':'\ud83d\udece',
	  'bento':'\ud83c\udf71',
	  'biking_man':'\ud83d\udeb4',
	  'bike':'\ud83d\udeb2',
	  'biking_woman':'\ud83d\udeb4&zwj;\u2640\ufe0f',
	  'bikini':'\ud83d\udc59',
	  'biohazard':'\u2623\ufe0f',
	  'bird':'\ud83d\udc26',
	  'birthday':'\ud83c\udf82',
	  'black_circle':'\u26ab\ufe0f',
	  'black_flag':'\ud83c\udff4',
	  'black_heart':'\ud83d\udda4',
	  'black_joker':'\ud83c\udccf',
	  'black_large_square':'\u2b1b\ufe0f',
	  'black_medium_small_square':'\u25fe\ufe0f',
	  'black_medium_square':'\u25fc\ufe0f',
	  'black_nib':'\u2712\ufe0f',
	  'black_small_square':'\u25aa\ufe0f',
	  'black_square_button':'\ud83d\udd32',
	  'blonde_man':'\ud83d\udc71',
	  'blonde_woman':'\ud83d\udc71&zwj;\u2640\ufe0f',
	  'blossom':'\ud83c\udf3c',
	  'blowfish':'\ud83d\udc21',
	  'blue_book':'\ud83d\udcd8',
	  'blue_car':'\ud83d\ude99',
	  'blue_heart':'\ud83d\udc99',
	  'blush':'\ud83d\ude0a',
	  'boar':'\ud83d\udc17',
	  'boat':'\u26f5\ufe0f',
	  'bomb':'\ud83d\udca3',
	  'book':'\ud83d\udcd6',
	  'bookmark':'\ud83d\udd16',
	  'bookmark_tabs':'\ud83d\udcd1',
	  'books':'\ud83d\udcda',
	  'boom':'\ud83d\udca5',
	  'boot':'\ud83d\udc62',
	  'bouquet':'\ud83d\udc90',
	  'bowing_man':'\ud83d\ude47',
	  'bow_and_arrow':'\ud83c\udff9',
	  'bowing_woman':'\ud83d\ude47&zwj;\u2640\ufe0f',
	  'bowling':'\ud83c\udfb3',
	  'boxing_glove':'\ud83e\udd4a',
	  'boy':'\ud83d\udc66',
	  'bread':'\ud83c\udf5e',
	  'bride_with_veil':'\ud83d\udc70',
	  'bridge_at_night':'\ud83c\udf09',
	  'briefcase':'\ud83d\udcbc',
	  'broken_heart':'\ud83d\udc94',
	  'bug':'\ud83d\udc1b',
	  'building_construction':'\ud83c\udfd7',
	  'bulb':'\ud83d\udca1',
	  'bullettrain_front':'\ud83d\ude85',
	  'bullettrain_side':'\ud83d\ude84',
	  'burrito':'\ud83c\udf2f',
	  'bus':'\ud83d\ude8c',
	  'business_suit_levitating':'\ud83d\udd74',
	  'busstop':'\ud83d\ude8f',
	  'bust_in_silhouette':'\ud83d\udc64',
	  'busts_in_silhouette':'\ud83d\udc65',
	  'butterfly':'\ud83e\udd8b',
	  'cactus':'\ud83c\udf35',
	  'cake':'\ud83c\udf70',
	  'calendar':'\ud83d\udcc6',
	  'call_me_hand':'\ud83e\udd19',
	  'calling':'\ud83d\udcf2',
	  'camel':'\ud83d\udc2b',
	  'camera':'\ud83d\udcf7',
	  'camera_flash':'\ud83d\udcf8',
	  'camping':'\ud83c\udfd5',
	  'cancer':'\u264b\ufe0f',
	  'candle':'\ud83d\udd6f',
	  'candy':'\ud83c\udf6c',
	  'canoe':'\ud83d\udef6',
	  'capital_abcd':'\ud83d\udd20',
	  'capricorn':'\u2651\ufe0f',
	  'car':'\ud83d\ude97',
	  'card_file_box':'\ud83d\uddc3',
	  'card_index':'\ud83d\udcc7',
	  'card_index_dividers':'\ud83d\uddc2',
	  'carousel_horse':'\ud83c\udfa0',
	  'carrot':'\ud83e\udd55',
	  'cat':'\ud83d\udc31',
	  'cat2':'\ud83d\udc08',
	  'cd':'\ud83d\udcbf',
	  'chains':'\u26d3',
	  'champagne':'\ud83c\udf7e',
	  'chart':'\ud83d\udcb9',
	  'chart_with_downwards_trend':'\ud83d\udcc9',
	  'chart_with_upwards_trend':'\ud83d\udcc8',
	  'checkered_flag':'\ud83c\udfc1',
	  'cheese':'\ud83e\uddc0',
	  'cherries':'\ud83c\udf52',
	  'cherry_blossom':'\ud83c\udf38',
	  'chestnut':'\ud83c\udf30',
	  'chicken':'\ud83d\udc14',
	  'children_crossing':'\ud83d\udeb8',
	  'chipmunk':'\ud83d\udc3f',
	  'chocolate_bar':'\ud83c\udf6b',
	  'christmas_tree':'\ud83c\udf84',
	  'church':'\u26ea\ufe0f',
	  'cinema':'\ud83c\udfa6',
	  'circus_tent':'\ud83c\udfaa',
	  'city_sunrise':'\ud83c\udf07',
	  'city_sunset':'\ud83c\udf06',
	  'cityscape':'\ud83c\udfd9',
	  'cl':'\ud83c\udd91',
	  'clamp':'\ud83d\udddc',
	  'clap':'\ud83d\udc4f',
	  'clapper':'\ud83c\udfac',
	  'classical_building':'\ud83c\udfdb',
	  'clinking_glasses':'\ud83e\udd42',
	  'clipboard':'\ud83d\udccb',
	  'clock1':'\ud83d\udd50',
	  'clock10':'\ud83d\udd59',
	  'clock1030':'\ud83d\udd65',
	  'clock11':'\ud83d\udd5a',
	  'clock1130':'\ud83d\udd66',
	  'clock12':'\ud83d\udd5b',
	  'clock1230':'\ud83d\udd67',
	  'clock130':'\ud83d\udd5c',
	  'clock2':'\ud83d\udd51',
	  'clock230':'\ud83d\udd5d',
	  'clock3':'\ud83d\udd52',
	  'clock330':'\ud83d\udd5e',
	  'clock4':'\ud83d\udd53',
	  'clock430':'\ud83d\udd5f',
	  'clock5':'\ud83d\udd54',
	  'clock530':'\ud83d\udd60',
	  'clock6':'\ud83d\udd55',
	  'clock630':'\ud83d\udd61',
	  'clock7':'\ud83d\udd56',
	  'clock730':'\ud83d\udd62',
	  'clock8':'\ud83d\udd57',
	  'clock830':'\ud83d\udd63',
	  'clock9':'\ud83d\udd58',
	  'clock930':'\ud83d\udd64',
	  'closed_book':'\ud83d\udcd5',
	  'closed_lock_with_key':'\ud83d\udd10',
	  'closed_umbrella':'\ud83c\udf02',
	  'cloud':'\u2601\ufe0f',
	  'cloud_with_lightning':'\ud83c\udf29',
	  'cloud_with_lightning_and_rain':'\u26c8',
	  'cloud_with_rain':'\ud83c\udf27',
	  'cloud_with_snow':'\ud83c\udf28',
	  'clown_face':'\ud83e\udd21',
	  'clubs':'\u2663\ufe0f',
	  'cocktail':'\ud83c\udf78',
	  'coffee':'\u2615\ufe0f',
	  'coffin':'\u26b0\ufe0f',
	  'cold_sweat':'\ud83d\ude30',
	  'comet':'\u2604\ufe0f',
	  'computer':'\ud83d\udcbb',
	  'computer_mouse':'\ud83d\uddb1',
	  'confetti_ball':'\ud83c\udf8a',
	  'confounded':'\ud83d\ude16',
	  'confused':'\ud83d\ude15',
	  'congratulations':'\u3297\ufe0f',
	  'construction':'\ud83d\udea7',
	  'construction_worker_man':'\ud83d\udc77',
	  'construction_worker_woman':'\ud83d\udc77&zwj;\u2640\ufe0f',
	  'control_knobs':'\ud83c\udf9b',
	  'convenience_store':'\ud83c\udfea',
	  'cookie':'\ud83c\udf6a',
	  'cool':'\ud83c\udd92',
	  'policeman':'\ud83d\udc6e',
	  'copyright':'\u00a9\ufe0f',
	  'corn':'\ud83c\udf3d',
	  'couch_and_lamp':'\ud83d\udecb',
	  'couple':'\ud83d\udc6b',
	  'couple_with_heart_woman_man':'\ud83d\udc91',
	  'couple_with_heart_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc68',
	  'couple_with_heart_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc69',
	  'couplekiss_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc68',
	  'couplekiss_man_woman':'\ud83d\udc8f',
	  'couplekiss_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc69',
	  'cow':'\ud83d\udc2e',
	  'cow2':'\ud83d\udc04',
	  'cowboy_hat_face':'\ud83e\udd20',
	  'crab':'\ud83e\udd80',
	  'crayon':'\ud83d\udd8d',
	  'credit_card':'\ud83d\udcb3',
	  'crescent_moon':'\ud83c\udf19',
	  'cricket':'\ud83c\udfcf',
	  'crocodile':'\ud83d\udc0a',
	  'croissant':'\ud83e\udd50',
	  'crossed_fingers':'\ud83e\udd1e',
	  'crossed_flags':'\ud83c\udf8c',
	  'crossed_swords':'\u2694\ufe0f',
	  'crown':'\ud83d\udc51',
	  'cry':'\ud83d\ude22',
	  'crying_cat_face':'\ud83d\ude3f',
	  'crystal_ball':'\ud83d\udd2e',
	  'cucumber':'\ud83e\udd52',
	  'cupid':'\ud83d\udc98',
	  'curly_loop':'\u27b0',
	  'currency_exchange':'\ud83d\udcb1',
	  'curry':'\ud83c\udf5b',
	  'custard':'\ud83c\udf6e',
	  'customs':'\ud83d\udec3',
	  'cyclone':'\ud83c\udf00',
	  'dagger':'\ud83d\udde1',
	  'dancer':'\ud83d\udc83',
	  'dancing_women':'\ud83d\udc6f',
	  'dancing_men':'\ud83d\udc6f&zwj;\u2642\ufe0f',
	  'dango':'\ud83c\udf61',
	  'dark_sunglasses':'\ud83d\udd76',
	  'dart':'\ud83c\udfaf',
	  'dash':'\ud83d\udca8',
	  'date':'\ud83d\udcc5',
	  'deciduous_tree':'\ud83c\udf33',
	  'deer':'\ud83e\udd8c',
	  'department_store':'\ud83c\udfec',
	  'derelict_house':'\ud83c\udfda',
	  'desert':'\ud83c\udfdc',
	  'desert_island':'\ud83c\udfdd',
	  'desktop_computer':'\ud83d\udda5',
	  'male_detective':'\ud83d\udd75\ufe0f',
	  'diamond_shape_with_a_dot_inside':'\ud83d\udca0',
	  'diamonds':'\u2666\ufe0f',
	  'disappointed':'\ud83d\ude1e',
	  'disappointed_relieved':'\ud83d\ude25',
	  'dizzy':'\ud83d\udcab',
	  'dizzy_face':'\ud83d\ude35',
	  'do_not_litter':'\ud83d\udeaf',
	  'dog':'\ud83d\udc36',
	  'dog2':'\ud83d\udc15',
	  'dollar':'\ud83d\udcb5',
	  'dolls':'\ud83c\udf8e',
	  'dolphin':'\ud83d\udc2c',
	  'door':'\ud83d\udeaa',
	  'doughnut':'\ud83c\udf69',
	  'dove':'\ud83d\udd4a',
	  'dragon':'\ud83d\udc09',
	  'dragon_face':'\ud83d\udc32',
	  'dress':'\ud83d\udc57',
	  'dromedary_camel':'\ud83d\udc2a',
	  'drooling_face':'\ud83e\udd24',
	  'droplet':'\ud83d\udca7',
	  'drum':'\ud83e\udd41',
	  'duck':'\ud83e\udd86',
	  'dvd':'\ud83d\udcc0',
	  'e-mail':'\ud83d\udce7',
	  'eagle':'\ud83e\udd85',
	  'ear':'\ud83d\udc42',
	  'ear_of_rice':'\ud83c\udf3e',
	  'earth_africa':'\ud83c\udf0d',
	  'earth_americas':'\ud83c\udf0e',
	  'earth_asia':'\ud83c\udf0f',
	  'egg':'\ud83e\udd5a',
	  'eggplant':'\ud83c\udf46',
	  'eight_pointed_black_star':'\u2734\ufe0f',
	  'eight_spoked_asterisk':'\u2733\ufe0f',
	  'electric_plug':'\ud83d\udd0c',
	  'elephant':'\ud83d\udc18',
	  'email':'\u2709\ufe0f',
	  'end':'\ud83d\udd1a',
	  'envelope_with_arrow':'\ud83d\udce9',
	  'euro':'\ud83d\udcb6',
	  'european_castle':'\ud83c\udff0',
	  'european_post_office':'\ud83c\udfe4',
	  'evergreen_tree':'\ud83c\udf32',
	  'exclamation':'\u2757\ufe0f',
	  'expressionless':'\ud83d\ude11',
	  'eye':'\ud83d\udc41',
	  'eye_speech_bubble':'\ud83d\udc41&zwj;\ud83d\udde8',
	  'eyeglasses':'\ud83d\udc53',
	  'eyes':'\ud83d\udc40',
	  'face_with_head_bandage':'\ud83e\udd15',
	  'face_with_thermometer':'\ud83e\udd12',
	  'fist_oncoming':'\ud83d\udc4a',
	  'factory':'\ud83c\udfed',
	  'fallen_leaf':'\ud83c\udf42',
	  'family_man_woman_boy':'\ud83d\udc6a',
	  'family_man_boy':'\ud83d\udc68&zwj;\ud83d\udc66',
	  'family_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_man_girl':'\ud83d\udc68&zwj;\ud83d\udc67',
	  'family_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_man_man_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66',
	  'family_man_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_man_man_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67',
	  'family_man_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_man_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_man_woman_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_man_woman_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
	  'family_man_woman_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_man_woman_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc66',
	  'family_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc67',
	  'family_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_woman_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66',
	  'family_woman_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_woman_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
	  'family_woman_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_woman_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'fast_forward':'\u23e9',
	  'fax':'\ud83d\udce0',
	  'fearful':'\ud83d\ude28',
	  'feet':'\ud83d\udc3e',
	  'female_detective':'\ud83d\udd75\ufe0f&zwj;\u2640\ufe0f',
	  'ferris_wheel':'\ud83c\udfa1',
	  'ferry':'\u26f4',
	  'field_hockey':'\ud83c\udfd1',
	  'file_cabinet':'\ud83d\uddc4',
	  'file_folder':'\ud83d\udcc1',
	  'film_projector':'\ud83d\udcfd',
	  'film_strip':'\ud83c\udf9e',
	  'fire':'\ud83d\udd25',
	  'fire_engine':'\ud83d\ude92',
	  'fireworks':'\ud83c\udf86',
	  'first_quarter_moon':'\ud83c\udf13',
	  'first_quarter_moon_with_face':'\ud83c\udf1b',
	  'fish':'\ud83d\udc1f',
	  'fish_cake':'\ud83c\udf65',
	  'fishing_pole_and_fish':'\ud83c\udfa3',
	  'fist_raised':'\u270a',
	  'fist_left':'\ud83e\udd1b',
	  'fist_right':'\ud83e\udd1c',
	  'flags':'\ud83c\udf8f',
	  'flashlight':'\ud83d\udd26',
	  'fleur_de_lis':'\u269c\ufe0f',
	  'flight_arrival':'\ud83d\udeec',
	  'flight_departure':'\ud83d\udeeb',
	  'floppy_disk':'\ud83d\udcbe',
	  'flower_playing_cards':'\ud83c\udfb4',
	  'flushed':'\ud83d\ude33',
	  'fog':'\ud83c\udf2b',
	  'foggy':'\ud83c\udf01',
	  'football':'\ud83c\udfc8',
	  'footprints':'\ud83d\udc63',
	  'fork_and_knife':'\ud83c\udf74',
	  'fountain':'\u26f2\ufe0f',
	  'fountain_pen':'\ud83d\udd8b',
	  'four_leaf_clover':'\ud83c\udf40',
	  'fox_face':'\ud83e\udd8a',
	  'framed_picture':'\ud83d\uddbc',
	  'free':'\ud83c\udd93',
	  'fried_egg':'\ud83c\udf73',
	  'fried_shrimp':'\ud83c\udf64',
	  'fries':'\ud83c\udf5f',
	  'frog':'\ud83d\udc38',
	  'frowning':'\ud83d\ude26',
	  'frowning_face':'\u2639\ufe0f',
	  'frowning_man':'\ud83d\ude4d&zwj;\u2642\ufe0f',
	  'frowning_woman':'\ud83d\ude4d',
	  'middle_finger':'\ud83d\udd95',
	  'fuelpump':'\u26fd\ufe0f',
	  'full_moon':'\ud83c\udf15',
	  'full_moon_with_face':'\ud83c\udf1d',
	  'funeral_urn':'\u26b1\ufe0f',
	  'game_die':'\ud83c\udfb2',
	  'gear':'\u2699\ufe0f',
	  'gem':'\ud83d\udc8e',
	  'gemini':'\u264a\ufe0f',
	  'ghost':'\ud83d\udc7b',
	  'gift':'\ud83c\udf81',
	  'gift_heart':'\ud83d\udc9d',
	  'girl':'\ud83d\udc67',
	  'globe_with_meridians':'\ud83c\udf10',
	  'goal_net':'\ud83e\udd45',
	  'goat':'\ud83d\udc10',
	  'golf':'\u26f3\ufe0f',
	  'golfing_man':'\ud83c\udfcc\ufe0f',
	  'golfing_woman':'\ud83c\udfcc\ufe0f&zwj;\u2640\ufe0f',
	  'gorilla':'\ud83e\udd8d',
	  'grapes':'\ud83c\udf47',
	  'green_apple':'\ud83c\udf4f',
	  'green_book':'\ud83d\udcd7',
	  'green_heart':'\ud83d\udc9a',
	  'green_salad':'\ud83e\udd57',
	  'grey_exclamation':'\u2755',
	  'grey_question':'\u2754',
	  'grimacing':'\ud83d\ude2c',
	  'grin':'\ud83d\ude01',
	  'grinning':'\ud83d\ude00',
	  'guardsman':'\ud83d\udc82',
	  'guardswoman':'\ud83d\udc82&zwj;\u2640\ufe0f',
	  'guitar':'\ud83c\udfb8',
	  'gun':'\ud83d\udd2b',
	  'haircut_woman':'\ud83d\udc87',
	  'haircut_man':'\ud83d\udc87&zwj;\u2642\ufe0f',
	  'hamburger':'\ud83c\udf54',
	  'hammer':'\ud83d\udd28',
	  'hammer_and_pick':'\u2692',
	  'hammer_and_wrench':'\ud83d\udee0',
	  'hamster':'\ud83d\udc39',
	  'hand':'\u270b',
	  'handbag':'\ud83d\udc5c',
	  'handshake':'\ud83e\udd1d',
	  'hankey':'\ud83d\udca9',
	  'hatched_chick':'\ud83d\udc25',
	  'hatching_chick':'\ud83d\udc23',
	  'headphones':'\ud83c\udfa7',
	  'hear_no_evil':'\ud83d\ude49',
	  'heart':'\u2764\ufe0f',
	  'heart_decoration':'\ud83d\udc9f',
	  'heart_eyes':'\ud83d\ude0d',
	  'heart_eyes_cat':'\ud83d\ude3b',
	  'heartbeat':'\ud83d\udc93',
	  'heartpulse':'\ud83d\udc97',
	  'hearts':'\u2665\ufe0f',
	  'heavy_check_mark':'\u2714\ufe0f',
	  'heavy_division_sign':'\u2797',
	  'heavy_dollar_sign':'\ud83d\udcb2',
	  'heavy_heart_exclamation':'\u2763\ufe0f',
	  'heavy_minus_sign':'\u2796',
	  'heavy_multiplication_x':'\u2716\ufe0f',
	  'heavy_plus_sign':'\u2795',
	  'helicopter':'\ud83d\ude81',
	  'herb':'\ud83c\udf3f',
	  'hibiscus':'\ud83c\udf3a',
	  'high_brightness':'\ud83d\udd06',
	  'high_heel':'\ud83d\udc60',
	  'hocho':'\ud83d\udd2a',
	  'hole':'\ud83d\udd73',
	  'honey_pot':'\ud83c\udf6f',
	  'horse':'\ud83d\udc34',
	  'horse_racing':'\ud83c\udfc7',
	  'hospital':'\ud83c\udfe5',
	  'hot_pepper':'\ud83c\udf36',
	  'hotdog':'\ud83c\udf2d',
	  'hotel':'\ud83c\udfe8',
	  'hotsprings':'\u2668\ufe0f',
	  'hourglass':'\u231b\ufe0f',
	  'hourglass_flowing_sand':'\u23f3',
	  'house':'\ud83c\udfe0',
	  'house_with_garden':'\ud83c\udfe1',
	  'houses':'\ud83c\udfd8',
	  'hugs':'\ud83e\udd17',
	  'hushed':'\ud83d\ude2f',
	  'ice_cream':'\ud83c\udf68',
	  'ice_hockey':'\ud83c\udfd2',
	  'ice_skate':'\u26f8',
	  'icecream':'\ud83c\udf66',
	  'id':'\ud83c\udd94',
	  'ideograph_advantage':'\ud83c\ude50',
	  'imp':'\ud83d\udc7f',
	  'inbox_tray':'\ud83d\udce5',
	  'incoming_envelope':'\ud83d\udce8',
	  'tipping_hand_woman':'\ud83d\udc81',
	  'information_source':'\u2139\ufe0f',
	  'innocent':'\ud83d\ude07',
	  'interrobang':'\u2049\ufe0f',
	  'iphone':'\ud83d\udcf1',
	  'izakaya_lantern':'\ud83c\udfee',
	  'jack_o_lantern':'\ud83c\udf83',
	  'japan':'\ud83d\uddfe',
	  'japanese_castle':'\ud83c\udfef',
	  'japanese_goblin':'\ud83d\udc7a',
	  'japanese_ogre':'\ud83d\udc79',
	  'jeans':'\ud83d\udc56',
	  'joy':'\ud83d\ude02',
	  'joy_cat':'\ud83d\ude39',
	  'joystick':'\ud83d\udd79',
	  'kaaba':'\ud83d\udd4b',
	  'key':'\ud83d\udd11',
	  'keyboard':'\u2328\ufe0f',
	  'keycap_ten':'\ud83d\udd1f',
	  'kick_scooter':'\ud83d\udef4',
	  'kimono':'\ud83d\udc58',
	  'kiss':'\ud83d\udc8b',
	  'kissing':'\ud83d\ude17',
	  'kissing_cat':'\ud83d\ude3d',
	  'kissing_closed_eyes':'\ud83d\ude1a',
	  'kissing_heart':'\ud83d\ude18',
	  'kissing_smiling_eyes':'\ud83d\ude19',
	  'kiwi_fruit':'\ud83e\udd5d',
	  'koala':'\ud83d\udc28',
	  'koko':'\ud83c\ude01',
	  'label':'\ud83c\udff7',
	  'large_blue_circle':'\ud83d\udd35',
	  'large_blue_diamond':'\ud83d\udd37',
	  'large_orange_diamond':'\ud83d\udd36',
	  'last_quarter_moon':'\ud83c\udf17',
	  'last_quarter_moon_with_face':'\ud83c\udf1c',
	  'latin_cross':'\u271d\ufe0f',
	  'laughing':'\ud83d\ude06',
	  'leaves':'\ud83c\udf43',
	  'ledger':'\ud83d\udcd2',
	  'left_luggage':'\ud83d\udec5',
	  'left_right_arrow':'\u2194\ufe0f',
	  'leftwards_arrow_with_hook':'\u21a9\ufe0f',
	  'lemon':'\ud83c\udf4b',
	  'leo':'\u264c\ufe0f',
	  'leopard':'\ud83d\udc06',
	  'level_slider':'\ud83c\udf9a',
	  'libra':'\u264e\ufe0f',
	  'light_rail':'\ud83d\ude88',
	  'link':'\ud83d\udd17',
	  'lion':'\ud83e\udd81',
	  'lips':'\ud83d\udc44',
	  'lipstick':'\ud83d\udc84',
	  'lizard':'\ud83e\udd8e',
	  'lock':'\ud83d\udd12',
	  'lock_with_ink_pen':'\ud83d\udd0f',
	  'lollipop':'\ud83c\udf6d',
	  'loop':'\u27bf',
	  'loud_sound':'\ud83d\udd0a',
	  'loudspeaker':'\ud83d\udce2',
	  'love_hotel':'\ud83c\udfe9',
	  'love_letter':'\ud83d\udc8c',
	  'low_brightness':'\ud83d\udd05',
	  'lying_face':'\ud83e\udd25',
	  'm':'\u24c2\ufe0f',
	  'mag':'\ud83d\udd0d',
	  'mag_right':'\ud83d\udd0e',
	  'mahjong':'\ud83c\udc04\ufe0f',
	  'mailbox':'\ud83d\udceb',
	  'mailbox_closed':'\ud83d\udcea',
	  'mailbox_with_mail':'\ud83d\udcec',
	  'mailbox_with_no_mail':'\ud83d\udced',
	  'man':'\ud83d\udc68',
	  'man_artist':'\ud83d\udc68&zwj;\ud83c\udfa8',
	  'man_astronaut':'\ud83d\udc68&zwj;\ud83d\ude80',
	  'man_cartwheeling':'\ud83e\udd38&zwj;\u2642\ufe0f',
	  'man_cook':'\ud83d\udc68&zwj;\ud83c\udf73',
	  'man_dancing':'\ud83d\udd7a',
	  'man_facepalming':'\ud83e\udd26&zwj;\u2642\ufe0f',
	  'man_factory_worker':'\ud83d\udc68&zwj;\ud83c\udfed',
	  'man_farmer':'\ud83d\udc68&zwj;\ud83c\udf3e',
	  'man_firefighter':'\ud83d\udc68&zwj;\ud83d\ude92',
	  'man_health_worker':'\ud83d\udc68&zwj;\u2695\ufe0f',
	  'man_in_tuxedo':'\ud83e\udd35',
	  'man_judge':'\ud83d\udc68&zwj;\u2696\ufe0f',
	  'man_juggling':'\ud83e\udd39&zwj;\u2642\ufe0f',
	  'man_mechanic':'\ud83d\udc68&zwj;\ud83d\udd27',
	  'man_office_worker':'\ud83d\udc68&zwj;\ud83d\udcbc',
	  'man_pilot':'\ud83d\udc68&zwj;\u2708\ufe0f',
	  'man_playing_handball':'\ud83e\udd3e&zwj;\u2642\ufe0f',
	  'man_playing_water_polo':'\ud83e\udd3d&zwj;\u2642\ufe0f',
	  'man_scientist':'\ud83d\udc68&zwj;\ud83d\udd2c',
	  'man_shrugging':'\ud83e\udd37&zwj;\u2642\ufe0f',
	  'man_singer':'\ud83d\udc68&zwj;\ud83c\udfa4',
	  'man_student':'\ud83d\udc68&zwj;\ud83c\udf93',
	  'man_teacher':'\ud83d\udc68&zwj;\ud83c\udfeb',
	  'man_technologist':'\ud83d\udc68&zwj;\ud83d\udcbb',
	  'man_with_gua_pi_mao':'\ud83d\udc72',
	  'man_with_turban':'\ud83d\udc73',
	  'tangerine':'\ud83c\udf4a',
	  'mans_shoe':'\ud83d\udc5e',
	  'mantelpiece_clock':'\ud83d\udd70',
	  'maple_leaf':'\ud83c\udf41',
	  'martial_arts_uniform':'\ud83e\udd4b',
	  'mask':'\ud83d\ude37',
	  'massage_woman':'\ud83d\udc86',
	  'massage_man':'\ud83d\udc86&zwj;\u2642\ufe0f',
	  'meat_on_bone':'\ud83c\udf56',
	  'medal_military':'\ud83c\udf96',
	  'medal_sports':'\ud83c\udfc5',
	  'mega':'\ud83d\udce3',
	  'melon':'\ud83c\udf48',
	  'memo':'\ud83d\udcdd',
	  'men_wrestling':'\ud83e\udd3c&zwj;\u2642\ufe0f',
	  'menorah':'\ud83d\udd4e',
	  'mens':'\ud83d\udeb9',
	  'metal':'\ud83e\udd18',
	  'metro':'\ud83d\ude87',
	  'microphone':'\ud83c\udfa4',
	  'microscope':'\ud83d\udd2c',
	  'milk_glass':'\ud83e\udd5b',
	  'milky_way':'\ud83c\udf0c',
	  'minibus':'\ud83d\ude90',
	  'minidisc':'\ud83d\udcbd',
	  'mobile_phone_off':'\ud83d\udcf4',
	  'money_mouth_face':'\ud83e\udd11',
	  'money_with_wings':'\ud83d\udcb8',
	  'moneybag':'\ud83d\udcb0',
	  'monkey':'\ud83d\udc12',
	  'monkey_face':'\ud83d\udc35',
	  'monorail':'\ud83d\ude9d',
	  'moon':'\ud83c\udf14',
	  'mortar_board':'\ud83c\udf93',
	  'mosque':'\ud83d\udd4c',
	  'motor_boat':'\ud83d\udee5',
	  'motor_scooter':'\ud83d\udef5',
	  'motorcycle':'\ud83c\udfcd',
	  'motorway':'\ud83d\udee3',
	  'mount_fuji':'\ud83d\uddfb',
	  'mountain':'\u26f0',
	  'mountain_biking_man':'\ud83d\udeb5',
	  'mountain_biking_woman':'\ud83d\udeb5&zwj;\u2640\ufe0f',
	  'mountain_cableway':'\ud83d\udea0',
	  'mountain_railway':'\ud83d\ude9e',
	  'mountain_snow':'\ud83c\udfd4',
	  'mouse':'\ud83d\udc2d',
	  'mouse2':'\ud83d\udc01',
	  'movie_camera':'\ud83c\udfa5',
	  'moyai':'\ud83d\uddff',
	  'mrs_claus':'\ud83e\udd36',
	  'muscle':'\ud83d\udcaa',
	  'mushroom':'\ud83c\udf44',
	  'musical_keyboard':'\ud83c\udfb9',
	  'musical_note':'\ud83c\udfb5',
	  'musical_score':'\ud83c\udfbc',
	  'mute':'\ud83d\udd07',
	  'nail_care':'\ud83d\udc85',
	  'name_badge':'\ud83d\udcdb',
	  'national_park':'\ud83c\udfde',
	  'nauseated_face':'\ud83e\udd22',
	  'necktie':'\ud83d\udc54',
	  'negative_squared_cross_mark':'\u274e',
	  'nerd_face':'\ud83e\udd13',
	  'neutral_face':'\ud83d\ude10',
	  'new':'\ud83c\udd95',
	  'new_moon':'\ud83c\udf11',
	  'new_moon_with_face':'\ud83c\udf1a',
	  'newspaper':'\ud83d\udcf0',
	  'newspaper_roll':'\ud83d\uddde',
	  'next_track_button':'\u23ed',
	  'ng':'\ud83c\udd96',
	  'no_good_man':'\ud83d\ude45&zwj;\u2642\ufe0f',
	  'no_good_woman':'\ud83d\ude45',
	  'night_with_stars':'\ud83c\udf03',
	  'no_bell':'\ud83d\udd15',
	  'no_bicycles':'\ud83d\udeb3',
	  'no_entry':'\u26d4\ufe0f',
	  'no_entry_sign':'\ud83d\udeab',
	  'no_mobile_phones':'\ud83d\udcf5',
	  'no_mouth':'\ud83d\ude36',
	  'no_pedestrians':'\ud83d\udeb7',
	  'no_smoking':'\ud83d\udead',
	  'non-potable_water':'\ud83d\udeb1',
	  'nose':'\ud83d\udc43',
	  'notebook':'\ud83d\udcd3',
	  'notebook_with_decorative_cover':'\ud83d\udcd4',
	  'notes':'\ud83c\udfb6',
	  'nut_and_bolt':'\ud83d\udd29',
	  'o':'\u2b55\ufe0f',
	  'o2':'\ud83c\udd7e\ufe0f',
	  'ocean':'\ud83c\udf0a',
	  'octopus':'\ud83d\udc19',
	  'oden':'\ud83c\udf62',
	  'office':'\ud83c\udfe2',
	  'oil_drum':'\ud83d\udee2',
	  'ok':'\ud83c\udd97',
	  'ok_hand':'\ud83d\udc4c',
	  'ok_man':'\ud83d\ude46&zwj;\u2642\ufe0f',
	  'ok_woman':'\ud83d\ude46',
	  'old_key':'\ud83d\udddd',
	  'older_man':'\ud83d\udc74',
	  'older_woman':'\ud83d\udc75',
	  'om':'\ud83d\udd49',
	  'on':'\ud83d\udd1b',
	  'oncoming_automobile':'\ud83d\ude98',
	  'oncoming_bus':'\ud83d\ude8d',
	  'oncoming_police_car':'\ud83d\ude94',
	  'oncoming_taxi':'\ud83d\ude96',
	  'open_file_folder':'\ud83d\udcc2',
	  'open_hands':'\ud83d\udc50',
	  'open_mouth':'\ud83d\ude2e',
	  'open_umbrella':'\u2602\ufe0f',
	  'ophiuchus':'\u26ce',
	  'orange_book':'\ud83d\udcd9',
	  'orthodox_cross':'\u2626\ufe0f',
	  'outbox_tray':'\ud83d\udce4',
	  'owl':'\ud83e\udd89',
	  'ox':'\ud83d\udc02',
	  'package':'\ud83d\udce6',
	  'page_facing_up':'\ud83d\udcc4',
	  'page_with_curl':'\ud83d\udcc3',
	  'pager':'\ud83d\udcdf',
	  'paintbrush':'\ud83d\udd8c',
	  'palm_tree':'\ud83c\udf34',
	  'pancakes':'\ud83e\udd5e',
	  'panda_face':'\ud83d\udc3c',
	  'paperclip':'\ud83d\udcce',
	  'paperclips':'\ud83d\udd87',
	  'parasol_on_ground':'\u26f1',
	  'parking':'\ud83c\udd7f\ufe0f',
	  'part_alternation_mark':'\u303d\ufe0f',
	  'partly_sunny':'\u26c5\ufe0f',
	  'passenger_ship':'\ud83d\udef3',
	  'passport_control':'\ud83d\udec2',
	  'pause_button':'\u23f8',
	  'peace_symbol':'\u262e\ufe0f',
	  'peach':'\ud83c\udf51',
	  'peanuts':'\ud83e\udd5c',
	  'pear':'\ud83c\udf50',
	  'pen':'\ud83d\udd8a',
	  'pencil2':'\u270f\ufe0f',
	  'penguin':'\ud83d\udc27',
	  'pensive':'\ud83d\ude14',
	  'performing_arts':'\ud83c\udfad',
	  'persevere':'\ud83d\ude23',
	  'person_fencing':'\ud83e\udd3a',
	  'pouting_woman':'\ud83d\ude4e',
	  'phone':'\u260e\ufe0f',
	  'pick':'\u26cf',
	  'pig':'\ud83d\udc37',
	  'pig2':'\ud83d\udc16',
	  'pig_nose':'\ud83d\udc3d',
	  'pill':'\ud83d\udc8a',
	  'pineapple':'\ud83c\udf4d',
	  'ping_pong':'\ud83c\udfd3',
	  'pisces':'\u2653\ufe0f',
	  'pizza':'\ud83c\udf55',
	  'place_of_worship':'\ud83d\uded0',
	  'plate_with_cutlery':'\ud83c\udf7d',
	  'play_or_pause_button':'\u23ef',
	  'point_down':'\ud83d\udc47',
	  'point_left':'\ud83d\udc48',
	  'point_right':'\ud83d\udc49',
	  'point_up':'\u261d\ufe0f',
	  'point_up_2':'\ud83d\udc46',
	  'police_car':'\ud83d\ude93',
	  'policewoman':'\ud83d\udc6e&zwj;\u2640\ufe0f',
	  'poodle':'\ud83d\udc29',
	  'popcorn':'\ud83c\udf7f',
	  'post_office':'\ud83c\udfe3',
	  'postal_horn':'\ud83d\udcef',
	  'postbox':'\ud83d\udcee',
	  'potable_water':'\ud83d\udeb0',
	  'potato':'\ud83e\udd54',
	  'pouch':'\ud83d\udc5d',
	  'poultry_leg':'\ud83c\udf57',
	  'pound':'\ud83d\udcb7',
	  'rage':'\ud83d\ude21',
	  'pouting_cat':'\ud83d\ude3e',
	  'pouting_man':'\ud83d\ude4e&zwj;\u2642\ufe0f',
	  'pray':'\ud83d\ude4f',
	  'prayer_beads':'\ud83d\udcff',
	  'pregnant_woman':'\ud83e\udd30',
	  'previous_track_button':'\u23ee',
	  'prince':'\ud83e\udd34',
	  'princess':'\ud83d\udc78',
	  'printer':'\ud83d\udda8',
	  'purple_heart':'\ud83d\udc9c',
	  'purse':'\ud83d\udc5b',
	  'pushpin':'\ud83d\udccc',
	  'put_litter_in_its_place':'\ud83d\udeae',
	  'question':'\u2753',
	  'rabbit':'\ud83d\udc30',
	  'rabbit2':'\ud83d\udc07',
	  'racehorse':'\ud83d\udc0e',
	  'racing_car':'\ud83c\udfce',
	  'radio':'\ud83d\udcfb',
	  'radio_button':'\ud83d\udd18',
	  'radioactive':'\u2622\ufe0f',
	  'railway_car':'\ud83d\ude83',
	  'railway_track':'\ud83d\udee4',
	  'rainbow':'\ud83c\udf08',
	  'rainbow_flag':'\ud83c\udff3\ufe0f&zwj;\ud83c\udf08',
	  'raised_back_of_hand':'\ud83e\udd1a',
	  'raised_hand_with_fingers_splayed':'\ud83d\udd90',
	  'raised_hands':'\ud83d\ude4c',
	  'raising_hand_woman':'\ud83d\ude4b',
	  'raising_hand_man':'\ud83d\ude4b&zwj;\u2642\ufe0f',
	  'ram':'\ud83d\udc0f',
	  'ramen':'\ud83c\udf5c',
	  'rat':'\ud83d\udc00',
	  'record_button':'\u23fa',
	  'recycle':'\u267b\ufe0f',
	  'red_circle':'\ud83d\udd34',
	  'registered':'\u00ae\ufe0f',
	  'relaxed':'\u263a\ufe0f',
	  'relieved':'\ud83d\ude0c',
	  'reminder_ribbon':'\ud83c\udf97',
	  'repeat':'\ud83d\udd01',
	  'repeat_one':'\ud83d\udd02',
	  'rescue_worker_helmet':'\u26d1',
	  'restroom':'\ud83d\udebb',
	  'revolving_hearts':'\ud83d\udc9e',
	  'rewind':'\u23ea',
	  'rhinoceros':'\ud83e\udd8f',
	  'ribbon':'\ud83c\udf80',
	  'rice':'\ud83c\udf5a',
	  'rice_ball':'\ud83c\udf59',
	  'rice_cracker':'\ud83c\udf58',
	  'rice_scene':'\ud83c\udf91',
	  'right_anger_bubble':'\ud83d\uddef',
	  'ring':'\ud83d\udc8d',
	  'robot':'\ud83e\udd16',
	  'rocket':'\ud83d\ude80',
	  'rofl':'\ud83e\udd23',
	  'roll_eyes':'\ud83d\ude44',
	  'roller_coaster':'\ud83c\udfa2',
	  'rooster':'\ud83d\udc13',
	  'rose':'\ud83c\udf39',
	  'rosette':'\ud83c\udff5',
	  'rotating_light':'\ud83d\udea8',
	  'round_pushpin':'\ud83d\udccd',
	  'rowing_man':'\ud83d\udea3',
	  'rowing_woman':'\ud83d\udea3&zwj;\u2640\ufe0f',
	  'rugby_football':'\ud83c\udfc9',
	  'running_man':'\ud83c\udfc3',
	  'running_shirt_with_sash':'\ud83c\udfbd',
	  'running_woman':'\ud83c\udfc3&zwj;\u2640\ufe0f',
	  'sa':'\ud83c\ude02\ufe0f',
	  'sagittarius':'\u2650\ufe0f',
	  'sake':'\ud83c\udf76',
	  'sandal':'\ud83d\udc61',
	  'santa':'\ud83c\udf85',
	  'satellite':'\ud83d\udce1',
	  'saxophone':'\ud83c\udfb7',
	  'school':'\ud83c\udfeb',
	  'school_satchel':'\ud83c\udf92',
	  'scissors':'\u2702\ufe0f',
	  'scorpion':'\ud83e\udd82',
	  'scorpius':'\u264f\ufe0f',
	  'scream':'\ud83d\ude31',
	  'scream_cat':'\ud83d\ude40',
	  'scroll':'\ud83d\udcdc',
	  'seat':'\ud83d\udcba',
	  'secret':'\u3299\ufe0f',
	  'see_no_evil':'\ud83d\ude48',
	  'seedling':'\ud83c\udf31',
	  'selfie':'\ud83e\udd33',
	  'shallow_pan_of_food':'\ud83e\udd58',
	  'shamrock':'\u2618\ufe0f',
	  'shark':'\ud83e\udd88',
	  'shaved_ice':'\ud83c\udf67',
	  'sheep':'\ud83d\udc11',
	  'shell':'\ud83d\udc1a',
	  'shield':'\ud83d\udee1',
	  'shinto_shrine':'\u26e9',
	  'ship':'\ud83d\udea2',
	  'shirt':'\ud83d\udc55',
	  'shopping':'\ud83d\udecd',
	  'shopping_cart':'\ud83d\uded2',
	  'shower':'\ud83d\udebf',
	  'shrimp':'\ud83e\udd90',
	  'signal_strength':'\ud83d\udcf6',
	  'six_pointed_star':'\ud83d\udd2f',
	  'ski':'\ud83c\udfbf',
	  'skier':'\u26f7',
	  'skull':'\ud83d\udc80',
	  'skull_and_crossbones':'\u2620\ufe0f',
	  'sleeping':'\ud83d\ude34',
	  'sleeping_bed':'\ud83d\udecc',
	  'sleepy':'\ud83d\ude2a',
	  'slightly_frowning_face':'\ud83d\ude41',
	  'slightly_smiling_face':'\ud83d\ude42',
	  'slot_machine':'\ud83c\udfb0',
	  'small_airplane':'\ud83d\udee9',
	  'small_blue_diamond':'\ud83d\udd39',
	  'small_orange_diamond':'\ud83d\udd38',
	  'small_red_triangle':'\ud83d\udd3a',
	  'small_red_triangle_down':'\ud83d\udd3b',
	  'smile':'\ud83d\ude04',
	  'smile_cat':'\ud83d\ude38',
	  'smiley':'\ud83d\ude03',
	  'smiley_cat':'\ud83d\ude3a',
	  'smiling_imp':'\ud83d\ude08',
	  'smirk':'\ud83d\ude0f',
	  'smirk_cat':'\ud83d\ude3c',
	  'smoking':'\ud83d\udeac',
	  'snail':'\ud83d\udc0c',
	  'snake':'\ud83d\udc0d',
	  'sneezing_face':'\ud83e\udd27',
	  'snowboarder':'\ud83c\udfc2',
	  'snowflake':'\u2744\ufe0f',
	  'snowman':'\u26c4\ufe0f',
	  'snowman_with_snow':'\u2603\ufe0f',
	  'sob':'\ud83d\ude2d',
	  'soccer':'\u26bd\ufe0f',
	  'soon':'\ud83d\udd1c',
	  'sos':'\ud83c\udd98',
	  'sound':'\ud83d\udd09',
	  'space_invader':'\ud83d\udc7e',
	  'spades':'\u2660\ufe0f',
	  'spaghetti':'\ud83c\udf5d',
	  'sparkle':'\u2747\ufe0f',
	  'sparkler':'\ud83c\udf87',
	  'sparkles':'\u2728',
	  'sparkling_heart':'\ud83d\udc96',
	  'speak_no_evil':'\ud83d\ude4a',
	  'speaker':'\ud83d\udd08',
	  'speaking_head':'\ud83d\udde3',
	  'speech_balloon':'\ud83d\udcac',
	  'speedboat':'\ud83d\udea4',
	  'spider':'\ud83d\udd77',
	  'spider_web':'\ud83d\udd78',
	  'spiral_calendar':'\ud83d\uddd3',
	  'spiral_notepad':'\ud83d\uddd2',
	  'spoon':'\ud83e\udd44',
	  'squid':'\ud83e\udd91',
	  'stadium':'\ud83c\udfdf',
	  'star':'\u2b50\ufe0f',
	  'star2':'\ud83c\udf1f',
	  'star_and_crescent':'\u262a\ufe0f',
	  'star_of_david':'\u2721\ufe0f',
	  'stars':'\ud83c\udf20',
	  'station':'\ud83d\ude89',
	  'statue_of_liberty':'\ud83d\uddfd',
	  'steam_locomotive':'\ud83d\ude82',
	  'stew':'\ud83c\udf72',
	  'stop_button':'\u23f9',
	  'stop_sign':'\ud83d\uded1',
	  'stopwatch':'\u23f1',
	  'straight_ruler':'\ud83d\udccf',
	  'strawberry':'\ud83c\udf53',
	  'stuck_out_tongue':'\ud83d\ude1b',
	  'stuck_out_tongue_closed_eyes':'\ud83d\ude1d',
	  'stuck_out_tongue_winking_eye':'\ud83d\ude1c',
	  'studio_microphone':'\ud83c\udf99',
	  'stuffed_flatbread':'\ud83e\udd59',
	  'sun_behind_large_cloud':'\ud83c\udf25',
	  'sun_behind_rain_cloud':'\ud83c\udf26',
	  'sun_behind_small_cloud':'\ud83c\udf24',
	  'sun_with_face':'\ud83c\udf1e',
	  'sunflower':'\ud83c\udf3b',
	  'sunglasses':'\ud83d\ude0e',
	  'sunny':'\u2600\ufe0f',
	  'sunrise':'\ud83c\udf05',
	  'sunrise_over_mountains':'\ud83c\udf04',
	  'surfing_man':'\ud83c\udfc4',
	  'surfing_woman':'\ud83c\udfc4&zwj;\u2640\ufe0f',
	  'sushi':'\ud83c\udf63',
	  'suspension_railway':'\ud83d\ude9f',
	  'sweat':'\ud83d\ude13',
	  'sweat_drops':'\ud83d\udca6',
	  'sweat_smile':'\ud83d\ude05',
	  'sweet_potato':'\ud83c\udf60',
	  'swimming_man':'\ud83c\udfca',
	  'swimming_woman':'\ud83c\udfca&zwj;\u2640\ufe0f',
	  'symbols':'\ud83d\udd23',
	  'synagogue':'\ud83d\udd4d',
	  'syringe':'\ud83d\udc89',
	  'taco':'\ud83c\udf2e',
	  'tada':'\ud83c\udf89',
	  'tanabata_tree':'\ud83c\udf8b',
	  'taurus':'\u2649\ufe0f',
	  'taxi':'\ud83d\ude95',
	  'tea':'\ud83c\udf75',
	  'telephone_receiver':'\ud83d\udcde',
	  'telescope':'\ud83d\udd2d',
	  'tennis':'\ud83c\udfbe',
	  'tent':'\u26fa\ufe0f',
	  'thermometer':'\ud83c\udf21',
	  'thinking':'\ud83e\udd14',
	  'thought_balloon':'\ud83d\udcad',
	  'ticket':'\ud83c\udfab',
	  'tickets':'\ud83c\udf9f',
	  'tiger':'\ud83d\udc2f',
	  'tiger2':'\ud83d\udc05',
	  'timer_clock':'\u23f2',
	  'tipping_hand_man':'\ud83d\udc81&zwj;\u2642\ufe0f',
	  'tired_face':'\ud83d\ude2b',
	  'tm':'\u2122\ufe0f',
	  'toilet':'\ud83d\udebd',
	  'tokyo_tower':'\ud83d\uddfc',
	  'tomato':'\ud83c\udf45',
	  'tongue':'\ud83d\udc45',
	  'top':'\ud83d\udd1d',
	  'tophat':'\ud83c\udfa9',
	  'tornado':'\ud83c\udf2a',
	  'trackball':'\ud83d\uddb2',
	  'tractor':'\ud83d\ude9c',
	  'traffic_light':'\ud83d\udea5',
	  'train':'\ud83d\ude8b',
	  'train2':'\ud83d\ude86',
	  'tram':'\ud83d\ude8a',
	  'triangular_flag_on_post':'\ud83d\udea9',
	  'triangular_ruler':'\ud83d\udcd0',
	  'trident':'\ud83d\udd31',
	  'triumph':'\ud83d\ude24',
	  'trolleybus':'\ud83d\ude8e',
	  'trophy':'\ud83c\udfc6',
	  'tropical_drink':'\ud83c\udf79',
	  'tropical_fish':'\ud83d\udc20',
	  'truck':'\ud83d\ude9a',
	  'trumpet':'\ud83c\udfba',
	  'tulip':'\ud83c\udf37',
	  'tumbler_glass':'\ud83e\udd43',
	  'turkey':'\ud83e\udd83',
	  'turtle':'\ud83d\udc22',
	  'tv':'\ud83d\udcfa',
	  'twisted_rightwards_arrows':'\ud83d\udd00',
	  'two_hearts':'\ud83d\udc95',
	  'two_men_holding_hands':'\ud83d\udc6c',
	  'two_women_holding_hands':'\ud83d\udc6d',
	  'u5272':'\ud83c\ude39',
	  'u5408':'\ud83c\ude34',
	  'u55b6':'\ud83c\ude3a',
	  'u6307':'\ud83c\ude2f\ufe0f',
	  'u6708':'\ud83c\ude37\ufe0f',
	  'u6709':'\ud83c\ude36',
	  'u6e80':'\ud83c\ude35',
	  'u7121':'\ud83c\ude1a\ufe0f',
	  'u7533':'\ud83c\ude38',
	  'u7981':'\ud83c\ude32',
	  'u7a7a':'\ud83c\ude33',
	  'umbrella':'\u2614\ufe0f',
	  'unamused':'\ud83d\ude12',
	  'underage':'\ud83d\udd1e',
	  'unicorn':'\ud83e\udd84',
	  'unlock':'\ud83d\udd13',
	  'up':'\ud83c\udd99',
	  'upside_down_face':'\ud83d\ude43',
	  'v':'\u270c\ufe0f',
	  'vertical_traffic_light':'\ud83d\udea6',
	  'vhs':'\ud83d\udcfc',
	  'vibration_mode':'\ud83d\udcf3',
	  'video_camera':'\ud83d\udcf9',
	  'video_game':'\ud83c\udfae',
	  'violin':'\ud83c\udfbb',
	  'virgo':'\u264d\ufe0f',
	  'volcano':'\ud83c\udf0b',
	  'volleyball':'\ud83c\udfd0',
	  'vs':'\ud83c\udd9a',
	  'vulcan_salute':'\ud83d\udd96',
	  'walking_man':'\ud83d\udeb6',
	  'walking_woman':'\ud83d\udeb6&zwj;\u2640\ufe0f',
	  'waning_crescent_moon':'\ud83c\udf18',
	  'waning_gibbous_moon':'\ud83c\udf16',
	  'warning':'\u26a0\ufe0f',
	  'wastebasket':'\ud83d\uddd1',
	  'watch':'\u231a\ufe0f',
	  'water_buffalo':'\ud83d\udc03',
	  'watermelon':'\ud83c\udf49',
	  'wave':'\ud83d\udc4b',
	  'wavy_dash':'\u3030\ufe0f',
	  'waxing_crescent_moon':'\ud83c\udf12',
	  'wc':'\ud83d\udebe',
	  'weary':'\ud83d\ude29',
	  'wedding':'\ud83d\udc92',
	  'weight_lifting_man':'\ud83c\udfcb\ufe0f',
	  'weight_lifting_woman':'\ud83c\udfcb\ufe0f&zwj;\u2640\ufe0f',
	  'whale':'\ud83d\udc33',
	  'whale2':'\ud83d\udc0b',
	  'wheel_of_dharma':'\u2638\ufe0f',
	  'wheelchair':'\u267f\ufe0f',
	  'white_check_mark':'\u2705',
	  'white_circle':'\u26aa\ufe0f',
	  'white_flag':'\ud83c\udff3\ufe0f',
	  'white_flower':'\ud83d\udcae',
	  'white_large_square':'\u2b1c\ufe0f',
	  'white_medium_small_square':'\u25fd\ufe0f',
	  'white_medium_square':'\u25fb\ufe0f',
	  'white_small_square':'\u25ab\ufe0f',
	  'white_square_button':'\ud83d\udd33',
	  'wilted_flower':'\ud83e\udd40',
	  'wind_chime':'\ud83c\udf90',
	  'wind_face':'\ud83c\udf2c',
	  'wine_glass':'\ud83c\udf77',
	  'wink':'\ud83d\ude09',
	  'wolf':'\ud83d\udc3a',
	  'woman':'\ud83d\udc69',
	  'woman_artist':'\ud83d\udc69&zwj;\ud83c\udfa8',
	  'woman_astronaut':'\ud83d\udc69&zwj;\ud83d\ude80',
	  'woman_cartwheeling':'\ud83e\udd38&zwj;\u2640\ufe0f',
	  'woman_cook':'\ud83d\udc69&zwj;\ud83c\udf73',
	  'woman_facepalming':'\ud83e\udd26&zwj;\u2640\ufe0f',
	  'woman_factory_worker':'\ud83d\udc69&zwj;\ud83c\udfed',
	  'woman_farmer':'\ud83d\udc69&zwj;\ud83c\udf3e',
	  'woman_firefighter':'\ud83d\udc69&zwj;\ud83d\ude92',
	  'woman_health_worker':'\ud83d\udc69&zwj;\u2695\ufe0f',
	  'woman_judge':'\ud83d\udc69&zwj;\u2696\ufe0f',
	  'woman_juggling':'\ud83e\udd39&zwj;\u2640\ufe0f',
	  'woman_mechanic':'\ud83d\udc69&zwj;\ud83d\udd27',
	  'woman_office_worker':'\ud83d\udc69&zwj;\ud83d\udcbc',
	  'woman_pilot':'\ud83d\udc69&zwj;\u2708\ufe0f',
	  'woman_playing_handball':'\ud83e\udd3e&zwj;\u2640\ufe0f',
	  'woman_playing_water_polo':'\ud83e\udd3d&zwj;\u2640\ufe0f',
	  'woman_scientist':'\ud83d\udc69&zwj;\ud83d\udd2c',
	  'woman_shrugging':'\ud83e\udd37&zwj;\u2640\ufe0f',
	  'woman_singer':'\ud83d\udc69&zwj;\ud83c\udfa4',
	  'woman_student':'\ud83d\udc69&zwj;\ud83c\udf93',
	  'woman_teacher':'\ud83d\udc69&zwj;\ud83c\udfeb',
	  'woman_technologist':'\ud83d\udc69&zwj;\ud83d\udcbb',
	  'woman_with_turban':'\ud83d\udc73&zwj;\u2640\ufe0f',
	  'womans_clothes':'\ud83d\udc5a',
	  'womans_hat':'\ud83d\udc52',
	  'women_wrestling':'\ud83e\udd3c&zwj;\u2640\ufe0f',
	  'womens':'\ud83d\udeba',
	  'world_map':'\ud83d\uddfa',
	  'worried':'\ud83d\ude1f',
	  'wrench':'\ud83d\udd27',
	  'writing_hand':'\u270d\ufe0f',
	  'x':'\u274c',
	  'yellow_heart':'\ud83d\udc9b',
	  'yen':'\ud83d\udcb4',
	  'yin_yang':'\u262f\ufe0f',
	  'yum':'\ud83d\ude0b',
	  'zap':'\u26a1\ufe0f',
	  'zipper_mouth_face':'\ud83e\udd10',
	  'zzz':'\ud83d\udca4',

	  /* special emojis :P */
	  'octocat':  '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
	  'showdown': '<span style="font-family: \'Anonymous Pro\', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>'
	};

	/**
	 * Created by Estevao on 31-05-2015.
	 */

	/**
	 * Showdown Converter class
	 * @class
	 * @param {object} [converterOptions]
	 * @returns {Converter}
	 */
	showdown.Converter = function (converterOptions) {

	  var
	      /**
	       * Options used by this converter
	       * @private
	       * @type {{}}
	       */
	      options = {},

	      /**
	       * Language extensions used by this converter
	       * @private
	       * @type {Array}
	       */
	      langExtensions = [],

	      /**
	       * Output modifiers extensions used by this converter
	       * @private
	       * @type {Array}
	       */
	      outputModifiers = [],

	      /**
	       * Event listeners
	       * @private
	       * @type {{}}
	       */
	      listeners = {},

	      /**
	       * The flavor set in this converter
	       */
	      setConvFlavor = setFlavor,

	      /**
	       * Metadata of the document
	       * @type {{parsed: {}, raw: string, format: string}}
	       */
	      metadata = {
	        parsed: {},
	        raw: '',
	        format: ''
	      };

	  _constructor();

	  /**
	   * Converter constructor
	   * @private
	   */
	  function _constructor () {
	    converterOptions = converterOptions || {};

	    for (var gOpt in globalOptions) {
	      if (globalOptions.hasOwnProperty(gOpt)) {
	        options[gOpt] = globalOptions[gOpt];
	      }
	    }

	    // Merge options
	    if (typeof converterOptions === 'object') {
	      for (var opt in converterOptions) {
	        if (converterOptions.hasOwnProperty(opt)) {
	          options[opt] = converterOptions[opt];
	        }
	      }
	    } else {
	      throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +
	      ' was passed instead.');
	    }

	    if (options.extensions) {
	      showdown.helper.forEach(options.extensions, _parseExtension);
	    }
	  }

	  /**
	   * Parse extension
	   * @param {*} ext
	   * @param {string} [name='']
	   * @private
	   */
	  function _parseExtension (ext, name) {

	    name = name || null;
	    // If it's a string, the extension was previously loaded
	    if (showdown.helper.isString(ext)) {
	      ext = showdown.helper.stdExtName(ext);
	      name = ext;

	      // LEGACY_SUPPORT CODE
	      if (showdown.extensions[ext]) {
	        console.warn('DEPRECATION WARNING: ' + ext + ' is an old extension that uses a deprecated loading method.' +
	          'Please inform the developer that the extension should be updated!');
	        legacyExtensionLoading(showdown.extensions[ext], ext);
	        return;
	        // END LEGACY SUPPORT CODE

	      } else if (!showdown.helper.isUndefined(extensions[ext])) {
	        ext = extensions[ext];

	      } else {
	        throw Error('Extension "' + ext + '" could not be loaded. It was either not found or is not a valid extension.');
	      }
	    }

	    if (typeof ext === 'function') {
	      ext = ext();
	    }

	    if (!showdown.helper.isArray(ext)) {
	      ext = [ext];
	    }

	    var validExt = validate(ext, name);
	    if (!validExt.valid) {
	      throw Error(validExt.error);
	    }

	    for (var i = 0; i < ext.length; ++i) {
	      switch (ext[i].type) {

	        case 'lang':
	          langExtensions.push(ext[i]);
	          break;

	        case 'output':
	          outputModifiers.push(ext[i]);
	          break;
	      }
	      if (ext[i].hasOwnProperty('listeners')) {
	        for (var ln in ext[i].listeners) {
	          if (ext[i].listeners.hasOwnProperty(ln)) {
	            listen(ln, ext[i].listeners[ln]);
	          }
	        }
	      }
	    }

	  }

	  /**
	   * LEGACY_SUPPORT
	   * @param {*} ext
	   * @param {string} name
	   */
	  function legacyExtensionLoading (ext, name) {
	    if (typeof ext === 'function') {
	      ext = ext(new showdown.Converter());
	    }
	    if (!showdown.helper.isArray(ext)) {
	      ext = [ext];
	    }
	    var valid = validate(ext, name);

	    if (!valid.valid) {
	      throw Error(valid.error);
	    }

	    for (var i = 0; i < ext.length; ++i) {
	      switch (ext[i].type) {
	        case 'lang':
	          langExtensions.push(ext[i]);
	          break;
	        case 'output':
	          outputModifiers.push(ext[i]);
	          break;
	        default:// should never reach here
	          throw Error('Extension loader error: Type unrecognized!!!');
	      }
	    }
	  }

	  /**
	   * Listen to an event
	   * @param {string} name
	   * @param {function} callback
	   */
	  function listen (name, callback) {
	    if (!showdown.helper.isString(name)) {
	      throw Error('Invalid argument in converter.listen() method: name must be a string, but ' + typeof name + ' given');
	    }

	    if (typeof callback !== 'function') {
	      throw Error('Invalid argument in converter.listen() method: callback must be a function, but ' + typeof callback + ' given');
	    }

	    if (!listeners.hasOwnProperty(name)) {
	      listeners[name] = [];
	    }
	    listeners[name].push(callback);
	  }

	  function rTrimInputText (text) {
	    var rsp = text.match(/^\s*/)[0].length,
	        rgx = new RegExp('^\\s{0,' + rsp + '}', 'gm');
	    return text.replace(rgx, '');
	  }

	  /**
	   * Dispatch an event
	   * @private
	   * @param {string} evtName Event name
	   * @param {string} text Text
	   * @param {{}} options Converter Options
	   * @param {{}} globals
	   * @returns {string}
	   */
	  this._dispatch = function dispatch (evtName, text, options, globals) {
	    if (listeners.hasOwnProperty(evtName)) {
	      for (var ei = 0; ei < listeners[evtName].length; ++ei) {
	        var nText = listeners[evtName][ei](evtName, text, this, options, globals);
	        if (nText && typeof nText !== 'undefined') {
	          text = nText;
	        }
	      }
	    }
	    return text;
	  };

	  /**
	   * Listen to an event
	   * @param {string} name
	   * @param {function} callback
	   * @returns {showdown.Converter}
	   */
	  this.listen = function (name, callback) {
	    listen(name, callback);
	    return this;
	  };

	  /**
	   * Converts a markdown string into HTML
	   * @param {string} text
	   * @returns {*}
	   */
	  this.makeHtml = function (text) {
	    //check if text is not falsy
	    if (!text) {
	      return text;
	    }

	    var globals = {
	      gHtmlBlocks:     [],
	      gHtmlMdBlocks:   [],
	      gHtmlSpans:      [],
	      gUrls:           {},
	      gTitles:         {},
	      gDimensions:     {},
	      gListLevel:      0,
	      hashLinkCounts:  {},
	      langExtensions:  langExtensions,
	      outputModifiers: outputModifiers,
	      converter:       this,
	      ghCodeBlocks:    [],
	      metadata: {
	        parsed: {},
	        raw: '',
	        format: ''
	      }
	    };

	    // This lets us use ¨ trema as an escape char to avoid md5 hashes
	    // The choice of character is arbitrary; anything that isn't
	    // magic in Markdown will work.
	    text = text.replace(/¨/g, '¨T');

	    // Replace $ with ¨D
	    // RegExp interprets $ as a special character
	    // when it's in a replacement string
	    text = text.replace(/\$/g, '¨D');

	    // Standardize line endings
	    text = text.replace(/\r\n/g, '\n'); // DOS to Unix
	    text = text.replace(/\r/g, '\n'); // Mac to Unix

	    // Stardardize line spaces
	    text = text.replace(/\u00A0/g, '&nbsp;');

	    if (options.smartIndentationFix) {
	      text = rTrimInputText(text);
	    }

	    // Make sure text begins and ends with a couple of newlines:
	    text = '\n\n' + text + '\n\n';

	    // detab
	    text = showdown.subParser('detab')(text, options, globals);

	    /**
	     * Strip any lines consisting only of spaces and tabs.
	     * This makes subsequent regexs easier to write, because we can
	     * match consecutive blank lines with /\n+/ instead of something
	     * contorted like /[ \t]*\n+/
	     */
	    text = text.replace(/^[ \t]+$/mg, '');

	    //run languageExtensions
	    showdown.helper.forEach(langExtensions, function (ext) {
	      text = showdown.subParser('runExtension')(ext, text, options, globals);
	    });

	    // run the sub parsers
	    text = showdown.subParser('metadata')(text, options, globals);
	    text = showdown.subParser('hashPreCodeTags')(text, options, globals);
	    text = showdown.subParser('githubCodeBlocks')(text, options, globals);
	    text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
	    text = showdown.subParser('hashCodeTags')(text, options, globals);
	    text = showdown.subParser('stripLinkDefinitions')(text, options, globals);
	    text = showdown.subParser('blockGamut')(text, options, globals);
	    text = showdown.subParser('unhashHTMLSpans')(text, options, globals);
	    text = showdown.subParser('unescapeSpecialChars')(text, options, globals);

	    // attacklab: Restore dollar signs
	    text = text.replace(/¨D/g, '$$');

	    // attacklab: Restore tremas
	    text = text.replace(/¨T/g, '¨');

	    // render a complete html document instead of a partial if the option is enabled
	    text = showdown.subParser('completeHTMLDocument')(text, options, globals);

	    // Run output modifiers
	    showdown.helper.forEach(outputModifiers, function (ext) {
	      text = showdown.subParser('runExtension')(ext, text, options, globals);
	    });

	    // update metadata
	    metadata = globals.metadata;
	    return text;
	  };

	  /**
	   * Converts an HTML string into a markdown string
	   * @param src
	   * @param [HTMLParser] A WHATWG DOM and HTML parser, such as JSDOM. If none is supplied, window.document will be used.
	   * @returns {string}
	   */
	  this.makeMarkdown = this.makeMd = function (src, HTMLParser) {

	    // replace \r\n with \n
	    src = src.replace(/\r\n/g, '\n');
	    src = src.replace(/\r/g, '\n'); // old macs

	    // due to an edge case, we need to find this: > <
	    // to prevent removing of non silent white spaces
	    // ex: <em>this is</em> <strong>sparta</strong>
	    src = src.replace(/>[ \t]+</, '>¨NBSP;<');

	    if (!HTMLParser) {
	      if (window && window.document) {
	        HTMLParser = window.document;
	      } else {
	        throw new Error('HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM');
	      }
	    }

	    var doc = HTMLParser.createElement('div');
	    doc.innerHTML = src;

	    var globals = {
	      preList: substitutePreCodeTags(doc)
	    };

	    // remove all newlines and collapse spaces
	    clean(doc);

	    // some stuff, like accidental reference links must now be escaped
	    // TODO
	    // doc.innerHTML = doc.innerHTML.replace(/\[[\S\t ]]/);

	    var nodes = doc.childNodes,
	        mdDoc = '';

	    for (var i = 0; i < nodes.length; i++) {
	      mdDoc += showdown.subParser('makeMarkdown.node')(nodes[i], globals);
	    }

	    function clean (node) {
	      for (var n = 0; n < node.childNodes.length; ++n) {
	        var child = node.childNodes[n];
	        if (child.nodeType === 3) {
	          if (!/\S/.test(child.nodeValue)) {
	            node.removeChild(child);
	            --n;
	          } else {
	            child.nodeValue = child.nodeValue.split('\n').join(' ');
	            child.nodeValue = child.nodeValue.replace(/(\s)+/g, '$1');
	          }
	        } else if (child.nodeType === 1) {
	          clean(child);
	        }
	      }
	    }

	    // find all pre tags and replace contents with placeholder
	    // we need this so that we can remove all indentation from html
	    // to ease up parsing
	    function substitutePreCodeTags (doc) {

	      var pres = doc.querySelectorAll('pre'),
	          presPH = [];

	      for (var i = 0; i < pres.length; ++i) {

	        if (pres[i].childElementCount === 1 && pres[i].firstChild.tagName.toLowerCase() === 'code') {
	          var content = pres[i].firstChild.innerHTML.trim(),
	              language = pres[i].firstChild.getAttribute('data-language') || '';

	          // if data-language attribute is not defined, then we look for class language-*
	          if (language === '') {
	            var classes = pres[i].firstChild.className.split(' ');
	            for (var c = 0; c < classes.length; ++c) {
	              var matches = classes[c].match(/^language-(.+)$/);
	              if (matches !== null) {
	                language = matches[1];
	                break;
	              }
	            }
	          }

	          // unescape html entities in content
	          content = showdown.helper.unescapeHTMLEntities(content);

	          presPH.push(content);
	          pres[i].outerHTML = '<precode language="' + language + '" precodenum="' + i.toString() + '"></precode>';
	        } else {
	          presPH.push(pres[i].innerHTML);
	          pres[i].innerHTML = '';
	          pres[i].setAttribute('prenum', i.toString());
	        }
	      }
	      return presPH;
	    }

	    return mdDoc;
	  };

	  /**
	   * Set an option of this Converter instance
	   * @param {string} key
	   * @param {*} value
	   */
	  this.setOption = function (key, value) {
	    options[key] = value;
	  };

	  /**
	   * Get the option of this Converter instance
	   * @param {string} key
	   * @returns {*}
	   */
	  this.getOption = function (key) {
	    return options[key];
	  };

	  /**
	   * Get the options of this Converter instance
	   * @returns {{}}
	   */
	  this.getOptions = function () {
	    return options;
	  };

	  /**
	   * Add extension to THIS converter
	   * @param {{}} extension
	   * @param {string} [name=null]
	   */
	  this.addExtension = function (extension, name) {
	    name = name || null;
	    _parseExtension(extension, name);
	  };

	  /**
	   * Use a global registered extension with THIS converter
	   * @param {string} extensionName Name of the previously registered extension
	   */
	  this.useExtension = function (extensionName) {
	    _parseExtension(extensionName);
	  };

	  /**
	   * Set the flavor THIS converter should use
	   * @param {string} name
	   */
	  this.setFlavor = function (name) {
	    if (!flavor.hasOwnProperty(name)) {
	      throw Error(name + ' flavor was not found');
	    }
	    var preset = flavor[name];
	    setConvFlavor = name;
	    for (var option in preset) {
	      if (preset.hasOwnProperty(option)) {
	        options[option] = preset[option];
	      }
	    }
	  };

	  /**
	   * Get the currently set flavor of this converter
	   * @returns {string}
	   */
	  this.getFlavor = function () {
	    return setConvFlavor;
	  };

	  /**
	   * Remove an extension from THIS converter.
	   * Note: This is a costly operation. It's better to initialize a new converter
	   * and specify the extensions you wish to use
	   * @param {Array} extension
	   */
	  this.removeExtension = function (extension) {
	    if (!showdown.helper.isArray(extension)) {
	      extension = [extension];
	    }
	    for (var a = 0; a < extension.length; ++a) {
	      var ext = extension[a];
	      for (var i = 0; i < langExtensions.length; ++i) {
	        if (langExtensions[i] === ext) {
	          langExtensions[i].splice(i, 1);
	        }
	      }
	      for (var ii = 0; ii < outputModifiers.length; ++i) {
	        if (outputModifiers[ii] === ext) {
	          outputModifiers[ii].splice(i, 1);
	        }
	      }
	    }
	  };

	  /**
	   * Get all extension of THIS converter
	   * @returns {{language: Array, output: Array}}
	   */
	  this.getAllExtensions = function () {
	    return {
	      language: langExtensions,
	      output: outputModifiers
	    };
	  };

	  /**
	   * Get the metadata of the previously parsed document
	   * @param raw
	   * @returns {string|{}}
	   */
	  this.getMetadata = function (raw) {
	    if (raw) {
	      return metadata.raw;
	    } else {
	      return metadata.parsed;
	    }
	  };

	  /**
	   * Get the metadata format of the previously parsed document
	   * @returns {string}
	   */
	  this.getMetadataFormat = function () {
	    return metadata.format;
	  };

	  /**
	   * Private: set a single key, value metadata pair
	   * @param {string} key
	   * @param {string} value
	   */
	  this._setMetadataPair = function (key, value) {
	    metadata.parsed[key] = value;
	  };

	  /**
	   * Private: set metadata format
	   * @param {string} format
	   */
	  this._setMetadataFormat = function (format) {
	    metadata.format = format;
	  };

	  /**
	   * Private: set metadata raw text
	   * @param {string} raw
	   */
	  this._setMetadataRaw = function (raw) {
	    metadata.raw = raw;
	  };
	};

	/**
	 * Turn Markdown link shortcuts into XHTML <a> tags.
	 */
	showdown.subParser('anchors', function (text, options, globals) {

	  text = globals.converter._dispatch('anchors.before', text, options, globals);

	  var writeAnchorTag = function (wholeMatch, linkText, linkId, url, m5, m6, title) {
	    if (showdown.helper.isUndefined(title)) {
	      title = '';
	    }
	    linkId = linkId.toLowerCase();

	    // Special case for explicit empty url
	    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
	      url = '';
	    } else if (!url) {
	      if (!linkId) {
	        // lower-case and turn embedded newlines into spaces
	        linkId = linkText.toLowerCase().replace(/ ?\n/g, ' ');
	      }
	      url = '#' + linkId;

	      if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {
	        url = globals.gUrls[linkId];
	        if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {
	          title = globals.gTitles[linkId];
	        }
	      } else {
	        return wholeMatch;
	      }
	    }

	    //url = showdown.helper.escapeCharacters(url, '*_', false); // replaced line to improve performance
	    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);

	    var result = '<a href="' + url + '"';

	    if (title !== '' && title !== null) {
	      title = title.replace(/"/g, '&quot;');
	      //title = showdown.helper.escapeCharacters(title, '*_', false); // replaced line to improve performance
	      title = title.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	      result += ' title="' + title + '"';
	    }

	    // optionLinksInNewWindow only applies
	    // to external links. Hash links (#) open in same page
	    if (options.openLinksInNewWindow && !/^#/.test(url)) {
	      // escaped _
	      result += ' rel="noopener noreferrer" target="¨E95Eblank"';
	    }

	    result += '>' + linkText + '</a>';

	    return result;
	  };

	  // First, handle reference-style links: [link text] [id]
	  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, writeAnchorTag);

	  // Next, inline-style links: [link text](url "optional title")
	  // cases with crazy urls like ./image/cat1).png
	  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
	    writeAnchorTag);

	  // normal cases
	  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
	    writeAnchorTag);

	  // handle reference-style shortcuts: [link text]
	  // These must come last in case you've also got [link test][1]
	  // or [link test](/foo)
	  text = text.replace(/\[([^\[\]]+)]()()()()()/g, writeAnchorTag);

	  // Lastly handle GithubMentions if option is enabled
	  if (options.ghMentions) {
	    text = text.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function (wm, st, escape, mentions, username) {
	      if (escape === '\\') {
	        return st + mentions;
	      }

	      //check if options.ghMentionsLink is a string
	      if (!showdown.helper.isString(options.ghMentionsLink)) {
	        throw new Error('ghMentionsLink option must be a string');
	      }
	      var lnk = options.ghMentionsLink.replace(/\{u}/g, username),
	          target = '';
	      if (options.openLinksInNewWindow) {
	        target = ' rel="noopener noreferrer" target="¨E95Eblank"';
	      }
	      return st + '<a href="' + lnk + '"' + target + '>' + mentions + '</a>';
	    });
	  }

	  text = globals.converter._dispatch('anchors.after', text, options, globals);
	  return text;
	});

	// url allowed chars [a-z\d_.~:/?#[]@!$&'()*+,;=-]

	var simpleURLRegex  = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi,
	    simpleURLRegex2 = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi,
	    delimUrlRegex   = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi,
	    simpleMailRegex = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi,
	    delimMailRegex  = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,

	    replaceLink = function (options) {
	      return function (wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {
	        link = link.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	        var lnkTxt = link,
	            append = '',
	            target = '',
	            lmc    = leadingMagicChars || '',
	            tmc    = trailingMagicChars || '';
	        if (/^www\./i.test(link)) {
	          link = link.replace(/^www\./i, 'http://www.');
	        }
	        if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {
	          append = trailingPunctuation;
	        }
	        if (options.openLinksInNewWindow) {
	          target = ' rel="noopener noreferrer" target="¨E95Eblank"';
	        }
	        return lmc + '<a href="' + link + '"' + target + '>' + lnkTxt + '</a>' + append + tmc;
	      };
	    },

	    replaceMail = function (options, globals) {
	      return function (wholeMatch, b, mail) {
	        var href = 'mailto:';
	        b = b || '';
	        mail = showdown.subParser('unescapeSpecialChars')(mail, options, globals);
	        if (options.encodeEmails) {
	          href = showdown.helper.encodeEmailAddress(href + mail);
	          mail = showdown.helper.encodeEmailAddress(mail);
	        } else {
	          href = href + mail;
	        }
	        return b + '<a href="' + href + '">' + mail + '</a>';
	      };
	    };

	showdown.subParser('autoLinks', function (text, options, globals) {

	  text = globals.converter._dispatch('autoLinks.before', text, options, globals);

	  text = text.replace(delimUrlRegex, replaceLink(options));
	  text = text.replace(delimMailRegex, replaceMail(options, globals));

	  text = globals.converter._dispatch('autoLinks.after', text, options, globals);

	  return text;
	});

	showdown.subParser('simplifiedAutoLinks', function (text, options, globals) {

	  if (!options.simplifiedAutoLink) {
	    return text;
	  }

	  text = globals.converter._dispatch('simplifiedAutoLinks.before', text, options, globals);

	  if (options.excludeTrailingPunctuationFromURLs) {
	    text = text.replace(simpleURLRegex2, replaceLink(options));
	  } else {
	    text = text.replace(simpleURLRegex, replaceLink(options));
	  }
	  text = text.replace(simpleMailRegex, replaceMail(options, globals));

	  text = globals.converter._dispatch('simplifiedAutoLinks.after', text, options, globals);

	  return text;
	});

	/**
	 * These are all the transformations that form block-level
	 * tags like paragraphs, headers, and list items.
	 */
	showdown.subParser('blockGamut', function (text, options, globals) {

	  text = globals.converter._dispatch('blockGamut.before', text, options, globals);

	  // we parse blockquotes first so that we can have headings and hrs
	  // inside blockquotes
	  text = showdown.subParser('blockQuotes')(text, options, globals);
	  text = showdown.subParser('headers')(text, options, globals);

	  // Do Horizontal Rules:
	  text = showdown.subParser('horizontalRule')(text, options, globals);

	  text = showdown.subParser('lists')(text, options, globals);
	  text = showdown.subParser('codeBlocks')(text, options, globals);
	  text = showdown.subParser('tables')(text, options, globals);

	  // We already ran _HashHTMLBlocks() before, in Markdown(), but that
	  // was to escape raw HTML in the original Markdown source. This time,
	  // we're escaping the markup we've just created, so that we don't wrap
	  // <p> tags around block-level tags.
	  text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
	  text = showdown.subParser('paragraphs')(text, options, globals);

	  text = globals.converter._dispatch('blockGamut.after', text, options, globals);

	  return text;
	});

	showdown.subParser('blockQuotes', function (text, options, globals) {

	  text = globals.converter._dispatch('blockQuotes.before', text, options, globals);

	  // add a couple extra lines after the text and endtext mark
	  text = text + '\n\n';

	  var rgx = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;

	  if (options.splitAdjacentBlockquotes) {
	    rgx = /^ {0,3}>[\s\S]*?(?:\n\n)/gm;
	  }

	  text = text.replace(rgx, function (bq) {
	    // attacklab: hack around Konqueror 3.5.4 bug:
	    // "----------bug".replace(/^-/g,"") == "bug"
	    bq = bq.replace(/^[ \t]*>[ \t]?/gm, ''); // trim one level of quoting

	    // attacklab: clean up hack
	    bq = bq.replace(/¨0/g, '');

	    bq = bq.replace(/^[ \t]+$/gm, ''); // trim whitespace-only lines
	    bq = showdown.subParser('githubCodeBlocks')(bq, options, globals);
	    bq = showdown.subParser('blockGamut')(bq, options, globals); // recurse

	    bq = bq.replace(/(^|\n)/g, '$1  ');
	    // These leading spaces screw with <pre> content, so we need to fix that:
	    bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function (wholeMatch, m1) {
	      var pre = m1;
	      // attacklab: hack around Konqueror 3.5.4 bug:
	      pre = pre.replace(/^  /mg, '¨0');
	      pre = pre.replace(/¨0/g, '');
	      return pre;
	    });

	    return showdown.subParser('hashBlock')('<blockquote>\n' + bq + '\n</blockquote>', options, globals);
	  });

	  text = globals.converter._dispatch('blockQuotes.after', text, options, globals);
	  return text;
	});

	/**
	 * Process Markdown `<pre><code>` blocks.
	 */
	showdown.subParser('codeBlocks', function (text, options, globals) {

	  text = globals.converter._dispatch('codeBlocks.before', text, options, globals);

	  // sentinel workarounds for lack of \A and \Z, safari\khtml bug
	  text += '¨0';

	  var pattern = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=¨0))/g;
	  text = text.replace(pattern, function (wholeMatch, m1, m2) {
	    var codeblock = m1,
	        nextChar = m2,
	        end = '\n';

	    codeblock = showdown.subParser('outdent')(codeblock, options, globals);
	    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
	    codeblock = showdown.subParser('detab')(codeblock, options, globals);
	    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
	    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing newlines

	    if (options.omitExtraWLInCodeBlocks) {
	      end = '';
	    }

	    codeblock = '<pre><code>' + codeblock + end + '</code></pre>';

	    return showdown.subParser('hashBlock')(codeblock, options, globals) + nextChar;
	  });

	  // strip sentinel
	  text = text.replace(/¨0/, '');

	  text = globals.converter._dispatch('codeBlocks.after', text, options, globals);
	  return text;
	});

	/**
	 *
	 *   *  Backtick quotes are used for <code></code> spans.
	 *
	 *   *  You can use multiple backticks as the delimiters if you want to
	 *     include literal backticks in the code span. So, this input:
	 *
	 *         Just type ``foo `bar` baz`` at the prompt.
	 *
	 *       Will translate to:
	 *
	 *         <p>Just type <code>foo `bar` baz</code> at the prompt.</p>
	 *
	 *    There's no arbitrary limit to the number of backticks you
	 *    can use as delimters. If you need three consecutive backticks
	 *    in your code, use four for delimiters, etc.
	 *
	 *  *  You can use spaces to get literal backticks at the edges:
	 *
	 *         ... type `` `bar` `` ...
	 *
	 *       Turns to:
	 *
	 *         ... type <code>`bar`</code> ...
	 */
	showdown.subParser('codeSpans', function (text, options, globals) {

	  text = globals.converter._dispatch('codeSpans.before', text, options, globals);

	  if (typeof text === 'undefined') {
	    text = '';
	  }
	  text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
	    function (wholeMatch, m1, m2, m3) {
	      var c = m3;
	      c = c.replace(/^([ \t]*)/g, '');	// leading whitespace
	      c = c.replace(/[ \t]*$/g, '');	// trailing whitespace
	      c = showdown.subParser('encodeCode')(c, options, globals);
	      c = m1 + '<code>' + c + '</code>';
	      c = showdown.subParser('hashHTMLSpans')(c, options, globals);
	      return c;
	    }
	  );

	  text = globals.converter._dispatch('codeSpans.after', text, options, globals);
	  return text;
	});

	/**
	 * Create a full HTML document from the processed markdown
	 */
	showdown.subParser('completeHTMLDocument', function (text, options, globals) {

	  if (!options.completeHTMLDocument) {
	    return text;
	  }

	  text = globals.converter._dispatch('completeHTMLDocument.before', text, options, globals);

	  var doctype = 'html',
	      doctypeParsed = '<!DOCTYPE HTML>\n',
	      title = '',
	      charset = '<meta charset="utf-8">\n',
	      lang = '',
	      metadata = '';

	  if (typeof globals.metadata.parsed.doctype !== 'undefined') {
	    doctypeParsed = '<!DOCTYPE ' +  globals.metadata.parsed.doctype + '>\n';
	    doctype = globals.metadata.parsed.doctype.toString().toLowerCase();
	    if (doctype === 'html' || doctype === 'html5') {
	      charset = '<meta charset="utf-8">';
	    }
	  }

	  for (var meta in globals.metadata.parsed) {
	    if (globals.metadata.parsed.hasOwnProperty(meta)) {
	      switch (meta.toLowerCase()) {
	        case 'doctype':
	          break;

	        case 'title':
	          title = '<title>' +  globals.metadata.parsed.title + '</title>\n';
	          break;

	        case 'charset':
	          if (doctype === 'html' || doctype === 'html5') {
	            charset = '<meta charset="' + globals.metadata.parsed.charset + '">\n';
	          } else {
	            charset = '<meta name="charset" content="' + globals.metadata.parsed.charset + '">\n';
	          }
	          break;

	        case 'language':
	        case 'lang':
	          lang = ' lang="' + globals.metadata.parsed[meta] + '"';
	          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
	          break;

	        default:
	          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
	      }
	    }
	  }

	  text = doctypeParsed + '<html' + lang + '>\n<head>\n' + title + charset + metadata + '</head>\n<body>\n' + text.trim() + '\n</body>\n</html>';

	  text = globals.converter._dispatch('completeHTMLDocument.after', text, options, globals);
	  return text;
	});

	/**
	 * Convert all tabs to spaces
	 */
	showdown.subParser('detab', function (text, options, globals) {
	  text = globals.converter._dispatch('detab.before', text, options, globals);

	  // expand first n-1 tabs
	  text = text.replace(/\t(?=\t)/g, '    '); // g_tab_width

	  // replace the nth with two sentinels
	  text = text.replace(/\t/g, '¨A¨B');

	  // use the sentinel to anchor our regex so it doesn't explode
	  text = text.replace(/¨B(.+?)¨A/g, function (wholeMatch, m1) {
	    var leadingText = m1,
	        numSpaces = 4 - leadingText.length % 4;  // g_tab_width

	    // there *must* be a better way to do this:
	    for (var i = 0; i < numSpaces; i++) {
	      leadingText += ' ';
	    }

	    return leadingText;
	  });

	  // clean up sentinels
	  text = text.replace(/¨A/g, '    ');  // g_tab_width
	  text = text.replace(/¨B/g, '');

	  text = globals.converter._dispatch('detab.after', text, options, globals);
	  return text;
	});

	showdown.subParser('ellipsis', function (text, options, globals) {

	  text = globals.converter._dispatch('ellipsis.before', text, options, globals);

	  text = text.replace(/\.\.\./g, '…');

	  text = globals.converter._dispatch('ellipsis.after', text, options, globals);

	  return text;
	});

	/**
	 * Turn emoji codes into emojis
	 *
	 * List of supported emojis: https://github.com/showdownjs/showdown/wiki/Emojis
	 */
	showdown.subParser('emoji', function (text, options, globals) {

	  if (!options.emoji) {
	    return text;
	  }

	  text = globals.converter._dispatch('emoji.before', text, options, globals);

	  var emojiRgx = /:([\S]+?):/g;

	  text = text.replace(emojiRgx, function (wm, emojiCode) {
	    if (showdown.helper.emojis.hasOwnProperty(emojiCode)) {
	      return showdown.helper.emojis[emojiCode];
	    }
	    return wm;
	  });

	  text = globals.converter._dispatch('emoji.after', text, options, globals);

	  return text;
	});

	/**
	 * Smart processing for ampersands and angle brackets that need to be encoded.
	 */
	showdown.subParser('encodeAmpsAndAngles', function (text, options, globals) {
	  text = globals.converter._dispatch('encodeAmpsAndAngles.before', text, options, globals);

	  // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
	  // http://bumppo.net/projects/amputator/
	  text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, '&amp;');

	  // Encode naked <'s
	  text = text.replace(/<(?![a-z\/?$!])/gi, '&lt;');

	  // Encode <
	  text = text.replace(/</g, '&lt;');

	  // Encode >
	  text = text.replace(/>/g, '&gt;');

	  text = globals.converter._dispatch('encodeAmpsAndAngles.after', text, options, globals);
	  return text;
	});

	/**
	 * Returns the string, with after processing the following backslash escape sequences.
	 *
	 * attacklab: The polite way to do this is with the new escapeCharacters() function:
	 *
	 *    text = escapeCharacters(text,"\\",true);
	 *    text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);
	 *
	 * ...but we're sidestepping its use of the (slow) RegExp constructor
	 * as an optimization for Firefox.  This function gets called a LOT.
	 */
	showdown.subParser('encodeBackslashEscapes', function (text, options, globals) {
	  text = globals.converter._dispatch('encodeBackslashEscapes.before', text, options, globals);

	  text = text.replace(/\\(\\)/g, showdown.helper.escapeCharactersCallback);
	  text = text.replace(/\\([`*_{}\[\]()>#+.!~=|-])/g, showdown.helper.escapeCharactersCallback);

	  text = globals.converter._dispatch('encodeBackslashEscapes.after', text, options, globals);
	  return text;
	});

	/**
	 * Encode/escape certain characters inside Markdown code runs.
	 * The point is that in code, these characters are literals,
	 * and lose their special Markdown meanings.
	 */
	showdown.subParser('encodeCode', function (text, options, globals) {

	  text = globals.converter._dispatch('encodeCode.before', text, options, globals);

	  // Encode all ampersands; HTML entities are not
	  // entities within a Markdown code span.
	  text = text
	    .replace(/&/g, '&amp;')
	  // Do the angle bracket song and dance:
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	  // Now, escape characters that are magic in Markdown:
	    .replace(/([*_{}\[\]\\=~-])/g, showdown.helper.escapeCharactersCallback);

	  text = globals.converter._dispatch('encodeCode.after', text, options, globals);
	  return text;
	});

	/**
	 * Within tags -- meaning between < and > -- encode [\ ` * _ ~ =] so they
	 * don't conflict with their use in Markdown for code, italics and strong.
	 */
	showdown.subParser('escapeSpecialCharsWithinTagAttributes', function (text, options, globals) {
	  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.before', text, options, globals);

	  // Build a regex to find HTML tags.
	  var tags     = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi,
	      comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;

	  text = text.replace(tags, function (wholeMatch) {
	    return wholeMatch
	      .replace(/(.)<\/?code>(?=.)/g, '$1`')
	      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
	  });

	  text = text.replace(comments, function (wholeMatch) {
	    return wholeMatch
	      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
	  });

	  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.after', text, options, globals);
	  return text;
	});

	/**
	 * Handle github codeblocks prior to running HashHTML so that
	 * HTML contained within the codeblock gets escaped properly
	 * Example:
	 * ```ruby
	 *     def hello_world(x)
	 *       puts "Hello, #{x}"
	 *     end
	 * ```
	 */
	showdown.subParser('githubCodeBlocks', function (text, options, globals) {

	  // early exit if option is not enabled
	  if (!options.ghCodeBlocks) {
	    return text;
	  }

	  text = globals.converter._dispatch('githubCodeBlocks.before', text, options, globals);

	  text += '¨0';

	  text = text.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function (wholeMatch, delim, language, codeblock) {
	    var end = (options.omitExtraWLInCodeBlocks) ? '' : '\n';

	    // First parse the github code block
	    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
	    codeblock = showdown.subParser('detab')(codeblock, options, globals);
	    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
	    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing whitespace

	    codeblock = '<pre><code' + (language ? ' class="' + language + ' language-' + language + '"' : '') + '>' + codeblock + end + '</code></pre>';

	    codeblock = showdown.subParser('hashBlock')(codeblock, options, globals);

	    // Since GHCodeblocks can be false positives, we need to
	    // store the primitive text and the parsed text in a global var,
	    // and then return a token
	    return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
	  });

	  // attacklab: strip sentinel
	  text = text.replace(/¨0/, '');

	  return globals.converter._dispatch('githubCodeBlocks.after', text, options, globals);
	});

	showdown.subParser('hashBlock', function (text, options, globals) {
	  text = globals.converter._dispatch('hashBlock.before', text, options, globals);
	  text = text.replace(/(^\n+|\n+$)/g, '');
	  text = '\n\n¨K' + (globals.gHtmlBlocks.push(text) - 1) + 'K\n\n';
	  text = globals.converter._dispatch('hashBlock.after', text, options, globals);
	  return text;
	});

	/**
	 * Hash and escape <code> elements that should not be parsed as markdown
	 */
	showdown.subParser('hashCodeTags', function (text, options, globals) {
	  text = globals.converter._dispatch('hashCodeTags.before', text, options, globals);

	  var repFunc = function (wholeMatch, match, left, right) {
	    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
	    return '¨C' + (globals.gHtmlSpans.push(codeblock) - 1) + 'C';
	  };

	  // Hash naked <code>
	  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '<code\\b[^>]*>', '</code>', 'gim');

	  text = globals.converter._dispatch('hashCodeTags.after', text, options, globals);
	  return text;
	});

	showdown.subParser('hashElement', function (text, options, globals) {

	  return function (wholeMatch, m1) {
	    var blockText = m1;

	    // Undo double lines
	    blockText = blockText.replace(/\n\n/g, '\n');
	    blockText = blockText.replace(/^\n/, '');

	    // strip trailing blank lines
	    blockText = blockText.replace(/\n+$/g, '');

	    // Replace the element text with a marker ("¨KxK" where x is its key)
	    blockText = '\n\n¨K' + (globals.gHtmlBlocks.push(blockText) - 1) + 'K\n\n';

	    return blockText;
	  };
	});

	showdown.subParser('hashHTMLBlocks', function (text, options, globals) {
	  text = globals.converter._dispatch('hashHTMLBlocks.before', text, options, globals);

	  var blockTags = [
	        'pre',
	        'div',
	        'h1',
	        'h2',
	        'h3',
	        'h4',
	        'h5',
	        'h6',
	        'blockquote',
	        'table',
	        'dl',
	        'ol',
	        'ul',
	        'script',
	        'noscript',
	        'form',
	        'fieldset',
	        'iframe',
	        'math',
	        'style',
	        'section',
	        'header',
	        'footer',
	        'nav',
	        'article',
	        'aside',
	        'address',
	        'audio',
	        'canvas',
	        'figure',
	        'hgroup',
	        'output',
	        'video',
	        'p'
	      ],
	      repFunc = function (wholeMatch, match, left, right) {
	        var txt = wholeMatch;
	        // check if this html element is marked as markdown
	        // if so, it's contents should be parsed as markdown
	        if (left.search(/\bmarkdown\b/) !== -1) {
	          txt = left + globals.converter.makeHtml(match) + right;
	        }
	        return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
	      };

	  if (options.backslashEscapesHTMLTags) {
	    // encode backslash escaped HTML tags
	    text = text.replace(/\\<(\/?[^>]+?)>/g, function (wm, inside) {
	      return '&lt;' + inside + '&gt;';
	    });
	  }

	  // hash HTML Blocks
	  for (var i = 0; i < blockTags.length; ++i) {

	    var opTagPos,
	        rgx1     = new RegExp('^ {0,3}(<' + blockTags[i] + '\\b[^>]*>)', 'im'),
	        patLeft  = '<' + blockTags[i] + '\\b[^>]*>',
	        patRight = '</' + blockTags[i] + '>';
	    // 1. Look for the first position of the first opening HTML tag in the text
	    while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {

	      // if the HTML tag is \ escaped, we need to escape it and break


	      //2. Split the text in that position
	      var subTexts = showdown.helper.splitAtIndex(text, opTagPos),
	          //3. Match recursively
	          newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, 'im');

	      // prevent an infinite loop
	      if (newSubText1 === subTexts[1]) {
	        break;
	      }
	      text = subTexts[0].concat(newSubText1);
	    }
	  }
	  // HR SPECIAL CASE
	  text = text.replace(/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
	    showdown.subParser('hashElement')(text, options, globals));

	  // Special case for standalone HTML comments
	  text = showdown.helper.replaceRecursiveRegExp(text, function (txt) {
	    return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
	  }, '^ {0,3}<!--', '-->', 'gm');

	  // PHP and ASP-style processor instructions (<?...?> and <%...%>)
	  text = text.replace(/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
	    showdown.subParser('hashElement')(text, options, globals));

	  text = globals.converter._dispatch('hashHTMLBlocks.after', text, options, globals);
	  return text;
	});

	/**
	 * Hash span elements that should not be parsed as markdown
	 */
	showdown.subParser('hashHTMLSpans', function (text, options, globals) {
	  text = globals.converter._dispatch('hashHTMLSpans.before', text, options, globals);

	  function hashHTMLSpan (html) {
	    return '¨C' + (globals.gHtmlSpans.push(html) - 1) + 'C';
	  }

	  // Hash Self Closing tags
	  text = text.replace(/<[^>]+?\/>/gi, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  // Hash tags without properties
	  text = text.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  // Hash tags with properties
	  text = text.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  // Hash self closing tags without />
	  text = text.replace(/<[^>]+?>/gi, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  /*showdown.helper.matchRecursiveRegExp(text, '<code\\b[^>]*>', '</code>', 'gi');*/

	  text = globals.converter._dispatch('hashHTMLSpans.after', text, options, globals);
	  return text;
	});

	/**
	 * Unhash HTML spans
	 */
	showdown.subParser('unhashHTMLSpans', function (text, options, globals) {
	  text = globals.converter._dispatch('unhashHTMLSpans.before', text, options, globals);

	  for (var i = 0; i < globals.gHtmlSpans.length; ++i) {
	    var repText = globals.gHtmlSpans[i],
	        // limiter to prevent infinite loop (assume 10 as limit for recurse)
	        limit = 0;

	    while (/¨C(\d+)C/.test(repText)) {
	      var num = RegExp.$1;
	      repText = repText.replace('¨C' + num + 'C', globals.gHtmlSpans[num]);
	      if (limit === 10) {
	        console.error('maximum nesting of 10 spans reached!!!');
	        break;
	      }
	      ++limit;
	    }
	    text = text.replace('¨C' + i + 'C', repText);
	  }

	  text = globals.converter._dispatch('unhashHTMLSpans.after', text, options, globals);
	  return text;
	});

	/**
	 * Hash and escape <pre><code> elements that should not be parsed as markdown
	 */
	showdown.subParser('hashPreCodeTags', function (text, options, globals) {
	  text = globals.converter._dispatch('hashPreCodeTags.before', text, options, globals);

	  var repFunc = function (wholeMatch, match, left, right) {
	    // encode html entities
	    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
	    return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
	  };

	  // Hash <pre><code>
	  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>', '^ {0,3}</code>\\s*</pre>', 'gim');

	  text = globals.converter._dispatch('hashPreCodeTags.after', text, options, globals);
	  return text;
	});

	showdown.subParser('headers', function (text, options, globals) {

	  text = globals.converter._dispatch('headers.before', text, options, globals);

	  var headerLevelStart = (isNaN(parseInt(options.headerLevelStart))) ? 1 : parseInt(options.headerLevelStart),

	      // Set text-style headers:
	      //	Header 1
	      //	========
	      //
	      //	Header 2
	      //	--------
	      //
	      setextRegexH1 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm,
	      setextRegexH2 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;

	  text = text.replace(setextRegexH1, function (wholeMatch, m1) {

	    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
	        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
	        hLevel = headerLevelStart,
	        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
	    return showdown.subParser('hashBlock')(hashBlock, options, globals);
	  });

	  text = text.replace(setextRegexH2, function (matchFound, m1) {
	    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
	        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
	        hLevel = headerLevelStart + 1,
	        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
	    return showdown.subParser('hashBlock')(hashBlock, options, globals);
	  });

	  // atx-style headers:
	  //  # Header 1
	  //  ## Header 2
	  //  ## Header 2 with closing hashes ##
	  //  ...
	  //  ###### Header 6
	  //
	  var atxStyle = (options.requireSpaceBeforeHeadingText) ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;

	  text = text.replace(atxStyle, function (wholeMatch, m1, m2) {
	    var hText = m2;
	    if (options.customizedHeaderId) {
	      hText = m2.replace(/\s?\{([^{]+?)}\s*$/, '');
	    }

	    var span = showdown.subParser('spanGamut')(hText, options, globals),
	        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m2) + '"',
	        hLevel = headerLevelStart - 1 + m1.length,
	        header = '<h' + hLevel + hID + '>' + span + '</h' + hLevel + '>';

	    return showdown.subParser('hashBlock')(header, options, globals);
	  });

	  function headerId (m) {
	    var title,
	        prefix;

	    // It is separate from other options to allow combining prefix and customized
	    if (options.customizedHeaderId) {
	      var match = m.match(/\{([^{]+?)}\s*$/);
	      if (match && match[1]) {
	        m = match[1];
	      }
	    }

	    title = m;

	    // Prefix id to prevent causing inadvertent pre-existing style matches.
	    if (showdown.helper.isString(options.prefixHeaderId)) {
	      prefix = options.prefixHeaderId;
	    } else if (options.prefixHeaderId === true) {
	      prefix = 'section-';
	    } else {
	      prefix = '';
	    }

	    if (!options.rawPrefixHeaderId) {
	      title = prefix + title;
	    }

	    if (options.ghCompatibleHeaderId) {
	      title = title
	        .replace(/ /g, '-')
	        // replace previously escaped chars (&, ¨ and $)
	        .replace(/&amp;/g, '')
	        .replace(/¨T/g, '')
	        .replace(/¨D/g, '')
	        // replace rest of the chars (&~$ are repeated as they might have been escaped)
	        // borrowed from github's redcarpet (some they should produce similar results)
	        .replace(/[&+$,\/:;=?@"#{}|^¨~\[\]`\\*)(%.!'<>]/g, '')
	        .toLowerCase();
	    } else if (options.rawHeaderId) {
	      title = title
	        .replace(/ /g, '-')
	        // replace previously escaped chars (&, ¨ and $)
	        .replace(/&amp;/g, '&')
	        .replace(/¨T/g, '¨')
	        .replace(/¨D/g, '$')
	        // replace " and '
	        .replace(/["']/g, '-')
	        .toLowerCase();
	    } else {
	      title = title
	        .replace(/[^\w]/g, '')
	        .toLowerCase();
	    }

	    if (options.rawPrefixHeaderId) {
	      title = prefix + title;
	    }

	    if (globals.hashLinkCounts[title]) {
	      title = title + '-' + (globals.hashLinkCounts[title]++);
	    } else {
	      globals.hashLinkCounts[title] = 1;
	    }
	    return title;
	  }

	  text = globals.converter._dispatch('headers.after', text, options, globals);
	  return text;
	});

	/**
	 * Turn Markdown link shortcuts into XHTML <a> tags.
	 */
	showdown.subParser('horizontalRule', function (text, options, globals) {
	  text = globals.converter._dispatch('horizontalRule.before', text, options, globals);

	  var key = showdown.subParser('hashBlock')('<hr />', options, globals);
	  text = text.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, key);
	  text = text.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, key);
	  text = text.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, key);

	  text = globals.converter._dispatch('horizontalRule.after', text, options, globals);
	  return text;
	});

	/**
	 * Turn Markdown image shortcuts into <img> tags.
	 */
	showdown.subParser('images', function (text, options, globals) {

	  text = globals.converter._dispatch('images.before', text, options, globals);

	  var inlineRegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
	      crazyRegExp       = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g,
	      base64RegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
	      referenceRegExp   = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g,
	      refShortcutRegExp = /!\[([^\[\]]+)]()()()()()/g;

	  function writeImageTagBase64 (wholeMatch, altText, linkId, url, width, height, m5, title) {
	    url = url.replace(/\s/g, '');
	    return writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title);
	  }

	  function writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title) {

	    var gUrls   = globals.gUrls,
	        gTitles = globals.gTitles,
	        gDims   = globals.gDimensions;

	    linkId = linkId.toLowerCase();

	    if (!title) {
	      title = '';
	    }
	    // Special case for explicit empty url
	    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
	      url = '';

	    } else if (url === '' || url === null) {
	      if (linkId === '' || linkId === null) {
	        // lower-case and turn embedded newlines into spaces
	        linkId = altText.toLowerCase().replace(/ ?\n/g, ' ');
	      }
	      url = '#' + linkId;

	      if (!showdown.helper.isUndefined(gUrls[linkId])) {
	        url = gUrls[linkId];
	        if (!showdown.helper.isUndefined(gTitles[linkId])) {
	          title = gTitles[linkId];
	        }
	        if (!showdown.helper.isUndefined(gDims[linkId])) {
	          width = gDims[linkId].width;
	          height = gDims[linkId].height;
	        }
	      } else {
	        return wholeMatch;
	      }
	    }

	    altText = altText
	      .replace(/"/g, '&quot;')
	    //altText = showdown.helper.escapeCharacters(altText, '*_', false);
	      .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	    //url = showdown.helper.escapeCharacters(url, '*_', false);
	    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	    var result = '<img src="' + url + '" alt="' + altText + '"';

	    if (title && showdown.helper.isString(title)) {
	      title = title
	        .replace(/"/g, '&quot;')
	      //title = showdown.helper.escapeCharacters(title, '*_', false);
	        .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	      result += ' title="' + title + '"';
	    }

	    if (width && height) {
	      width  = (width === '*') ? 'auto' : width;
	      height = (height === '*') ? 'auto' : height;

	      result += ' width="' + width + '"';
	      result += ' height="' + height + '"';
	    }

	    result += ' />';

	    return result;
	  }

	  // First, handle reference-style labeled images: ![alt text][id]
	  text = text.replace(referenceRegExp, writeImageTag);

	  // Next, handle inline images:  ![alt text](url =<width>x<height> "optional title")

	  // base64 encoded images
	  text = text.replace(base64RegExp, writeImageTagBase64);

	  // cases with crazy urls like ./image/cat1).png
	  text = text.replace(crazyRegExp, writeImageTag);

	  // normal cases
	  text = text.replace(inlineRegExp, writeImageTag);

	  // handle reference-style shortcuts: ![img text]
	  text = text.replace(refShortcutRegExp, writeImageTag);

	  text = globals.converter._dispatch('images.after', text, options, globals);
	  return text;
	});

	showdown.subParser('italicsAndBold', function (text, options, globals) {

	  text = globals.converter._dispatch('italicsAndBold.before', text, options, globals);

	  // it's faster to have 3 separate regexes for each case than have just one
	  // because of backtracing, in some cases, it could lead to an exponential effect
	  // called "catastrophic backtrace". Ominous!

	  function parseInside (txt, left, right) {
	    /*
	    if (options.simplifiedAutoLink) {
	      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
	    }
	    */
	    return left + txt + right;
	  }

	  // Parse underscores
	  if (options.literalMidWordUnderscores) {
	    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
	      return parseInside (txt, '<strong><em>', '</em></strong>');
	    });
	    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
	      return parseInside (txt, '<strong>', '</strong>');
	    });
	    text = text.replace(/\b_(\S[\s\S]*?)_\b/g, function (wm, txt) {
	      return parseInside (txt, '<em>', '</em>');
	    });
	  } else {
	    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
	    });
	    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
	    });
	    text = text.replace(/_([^\s_][\s\S]*?)_/g, function (wm, m) {
	      // !/^_[^_]/.test(m) - test if it doesn't start with __ (since it seems redundant, we removed it)
	      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
	    });
	  }

	  // Now parse asterisks
	  if (options.literalMidWordAsterisks) {
	    text = text.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function (wm, lead, txt) {
	      return parseInside (txt, lead + '<strong><em>', '</em></strong>');
	    });
	    text = text.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function (wm, lead, txt) {
	      return parseInside (txt, lead + '<strong>', '</strong>');
	    });
	    text = text.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function (wm, lead, txt) {
	      return parseInside (txt, lead + '<em>', '</em>');
	    });
	  } else {
	    text = text.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
	    });
	    text = text.replace(/\*\*(\S[\s\S]*?)\*\*/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
	    });
	    text = text.replace(/\*([^\s*][\s\S]*?)\*/g, function (wm, m) {
	      // !/^\*[^*]/.test(m) - test if it doesn't start with ** (since it seems redundant, we removed it)
	      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
	    });
	  }


	  text = globals.converter._dispatch('italicsAndBold.after', text, options, globals);
	  return text;
	});

	/**
	 * Form HTML ordered (numbered) and unordered (bulleted) lists.
	 */
	showdown.subParser('lists', function (text, options, globals) {

	  /**
	   * Process the contents of a single ordered or unordered list, splitting it
	   * into individual list items.
	   * @param {string} listStr
	   * @param {boolean} trimTrailing
	   * @returns {string}
	   */
	  function processListItems (listStr, trimTrailing) {
	    // The $g_list_level global keeps track of when we're inside a list.
	    // Each time we enter a list, we increment it; when we leave a list,
	    // we decrement. If it's zero, we're not in a list anymore.
	    //
	    // We do this because when we're not inside a list, we want to treat
	    // something like this:
	    //
	    //    I recommend upgrading to version
	    //    8. Oops, now this line is treated
	    //    as a sub-list.
	    //
	    // As a single paragraph, despite the fact that the second line starts
	    // with a digit-period-space sequence.
	    //
	    // Whereas when we're inside a list (or sub-list), that line will be
	    // treated as the start of a sub-list. What a kludge, huh? This is
	    // an aspect of Markdown's syntax that's hard to parse perfectly
	    // without resorting to mind-reading. Perhaps the solution is to
	    // change the syntax rules such that sub-lists must start with a
	    // starting cardinal number; e.g. "1." or "a.".
	    globals.gListLevel++;

	    // trim trailing blank lines:
	    listStr = listStr.replace(/\n{2,}$/, '\n');

	    // attacklab: add sentinel to emulate \z
	    listStr += '¨0';

	    var rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0| {0,3}([*+-]|\d+[.])[ \t]+))/gm,
	        isParagraphed = (/\n[ \t]*\n(?!¨0)/.test(listStr));

	    // Since version 1.5, nesting sublists requires 4 spaces (or 1 tab) indentation,
	    // which is a syntax breaking change
	    // activating this option reverts to old behavior
	    if (options.disableForced4SpacesIndentedSublists) {
	      rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0|\2([*+-]|\d+[.])[ \t]+))/gm;
	    }

	    listStr = listStr.replace(rgx, function (wholeMatch, m1, m2, m3, m4, taskbtn, checked) {
	      checked = (checked && checked.trim() !== '');

	      var item = showdown.subParser('outdent')(m4, options, globals),
	          bulletStyle = '';

	      // Support for github tasklists
	      if (taskbtn && options.tasklists) {
	        bulletStyle = ' class="task-list-item" style="list-style-type: none;"';
	        item = item.replace(/^[ \t]*\[(x|X| )?]/m, function () {
	          var otp = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
	          if (checked) {
	            otp += ' checked';
	          }
	          otp += '>';
	          return otp;
	        });
	      }

	      // ISSUE #312
	      // This input: - - - a
	      // causes trouble to the parser, since it interprets it as:
	      // <ul><li><li><li>a</li></li></li></ul>
	      // instead of:
	      // <ul><li>- - a</li></ul>
	      // So, to prevent it, we will put a marker (¨A)in the beginning of the line
	      // Kind of hackish/monkey patching, but seems more effective than overcomplicating the list parser
	      item = item.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function (wm2) {
	        return '¨A' + wm2;
	      });

	      // m1 - Leading line or
	      // Has a double return (multi paragraph) or
	      // Has sublist
	      if (m1 || (item.search(/\n{2,}/) > -1)) {
	        item = showdown.subParser('githubCodeBlocks')(item, options, globals);
	        item = showdown.subParser('blockGamut')(item, options, globals);
	      } else {
	        // Recursion for sub-lists:
	        item = showdown.subParser('lists')(item, options, globals);
	        item = item.replace(/\n$/, ''); // chomp(item)
	        item = showdown.subParser('hashHTMLBlocks')(item, options, globals);

	        // Colapse double linebreaks
	        item = item.replace(/\n\n+/g, '\n\n');
	        if (isParagraphed) {
	          item = showdown.subParser('paragraphs')(item, options, globals);
	        } else {
	          item = showdown.subParser('spanGamut')(item, options, globals);
	        }
	      }

	      // now we need to remove the marker (¨A)
	      item = item.replace('¨A', '');
	      // we can finally wrap the line in list item tags
	      item =  '<li' + bulletStyle + '>' + item + '</li>\n';

	      return item;
	    });

	    // attacklab: strip sentinel
	    listStr = listStr.replace(/¨0/g, '');

	    globals.gListLevel--;

	    if (trimTrailing) {
	      listStr = listStr.replace(/\s+$/, '');
	    }

	    return listStr;
	  }

	  function styleStartNumber (list, listType) {
	    // check if ol and starts by a number different than 1
	    if (listType === 'ol') {
	      var res = list.match(/^ *(\d+)\./);
	      if (res && res[1] !== '1') {
	        return ' start="' + res[1] + '"';
	      }
	    }
	    return '';
	  }

	  /**
	   * Check and parse consecutive lists (better fix for issue #142)
	   * @param {string} list
	   * @param {string} listType
	   * @param {boolean} trimTrailing
	   * @returns {string}
	   */
	  function parseConsecutiveLists (list, listType, trimTrailing) {
	    // check if we caught 2 or more consecutive lists by mistake
	    // we use the counterRgx, meaning if listType is UL we look for OL and vice versa
	    var olRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm,
	        ulRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm,
	        counterRxg = (listType === 'ul') ? olRgx : ulRgx,
	        result = '';

	    if (list.search(counterRxg) !== -1) {
	      (function parseCL (txt) {
	        var pos = txt.search(counterRxg),
	            style = styleStartNumber(list, listType);
	        if (pos !== -1) {
	          // slice
	          result += '\n\n<' + listType + style + '>\n' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\n';

	          // invert counterType and listType
	          listType = (listType === 'ul') ? 'ol' : 'ul';
	          counterRxg = (listType === 'ul') ? olRgx : ulRgx;

	          //recurse
	          parseCL(txt.slice(pos));
	        } else {
	          result += '\n\n<' + listType + style + '>\n' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\n';
	        }
	      })(list);
	    } else {
	      var style = styleStartNumber(list, listType);
	      result = '\n\n<' + listType + style + '>\n' + processListItems(list, !!trimTrailing) + '</' + listType + '>\n';
	    }

	    return result;
	  }

	  /** Start of list parsing **/
	  text = globals.converter._dispatch('lists.before', text, options, globals);
	  // add sentinel to hack around khtml/safari bug:
	  // http://bugs.webkit.org/show_bug.cgi?id=11231
	  text += '¨0';

	  if (globals.gListLevel) {
	    text = text.replace(/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
	      function (wholeMatch, list, m2) {
	        var listType = (m2.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
	        return parseConsecutiveLists(list, listType, true);
	      }
	    );
	  } else {
	    text = text.replace(/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
	      function (wholeMatch, m1, list, m3) {
	        var listType = (m3.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
	        return parseConsecutiveLists(list, listType, false);
	      }
	    );
	  }

	  // strip sentinel
	  text = text.replace(/¨0/, '');
	  text = globals.converter._dispatch('lists.after', text, options, globals);
	  return text;
	});

	/**
	 * Parse metadata at the top of the document
	 */
	showdown.subParser('metadata', function (text, options, globals) {

	  if (!options.metadata) {
	    return text;
	  }

	  text = globals.converter._dispatch('metadata.before', text, options, globals);

	  function parseMetadataContents (content) {
	    // raw is raw so it's not changed in any way
	    globals.metadata.raw = content;

	    // escape chars forbidden in html attributes
	    // double quotes
	    content = content
	      // ampersand first
	      .replace(/&/g, '&amp;')
	      // double quotes
	      .replace(/"/g, '&quot;');

	    content = content.replace(/\n {4}/g, ' ');
	    content.replace(/^([\S ]+): +([\s\S]+?)$/gm, function (wm, key, value) {
	      globals.metadata.parsed[key] = value;
	      return '';
	    });
	  }

	  text = text.replace(/^\s*«««+(\S*?)\n([\s\S]+?)\n»»»+\n/, function (wholematch, format, content) {
	    parseMetadataContents(content);
	    return '¨M';
	  });

	  text = text.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function (wholematch, format, content) {
	    if (format) {
	      globals.metadata.format = format;
	    }
	    parseMetadataContents(content);
	    return '¨M';
	  });

	  text = text.replace(/¨M/g, '');

	  text = globals.converter._dispatch('metadata.after', text, options, globals);
	  return text;
	});

	/**
	 * Remove one level of line-leading tabs or spaces
	 */
	showdown.subParser('outdent', function (text, options, globals) {
	  text = globals.converter._dispatch('outdent.before', text, options, globals);

	  // attacklab: hack around Konqueror 3.5.4 bug:
	  // "----------bug".replace(/^-/g,"") == "bug"
	  text = text.replace(/^(\t|[ ]{1,4})/gm, '¨0'); // attacklab: g_tab_width

	  // attacklab: clean up hack
	  text = text.replace(/¨0/g, '');

	  text = globals.converter._dispatch('outdent.after', text, options, globals);
	  return text;
	});

	/**
	 *
	 */
	showdown.subParser('paragraphs', function (text, options, globals) {

	  text = globals.converter._dispatch('paragraphs.before', text, options, globals);
	  // Strip leading and trailing lines:
	  text = text.replace(/^\n+/g, '');
	  text = text.replace(/\n+$/g, '');

	  var grafs = text.split(/\n{2,}/g),
	      grafsOut = [],
	      end = grafs.length; // Wrap <p> tags

	  for (var i = 0; i < end; i++) {
	    var str = grafs[i];
	    // if this is an HTML marker, copy it
	    if (str.search(/¨(K|G)(\d+)\1/g) >= 0) {
	      grafsOut.push(str);

	    // test for presence of characters to prevent empty lines being parsed
	    // as paragraphs (resulting in undesired extra empty paragraphs)
	    } else if (str.search(/\S/) >= 0) {
	      str = showdown.subParser('spanGamut')(str, options, globals);
	      str = str.replace(/^([ \t]*)/g, '<p>');
	      str += '</p>';
	      grafsOut.push(str);
	    }
	  }

	  /** Unhashify HTML blocks */
	  end = grafsOut.length;
	  for (i = 0; i < end; i++) {
	    var blockText = '',
	        grafsOutIt = grafsOut[i],
	        codeFlag = false;
	    // if this is a marker for an html block...
	    // use RegExp.test instead of string.search because of QML bug
	    while (/¨(K|G)(\d+)\1/.test(grafsOutIt)) {
	      var delim = RegExp.$1,
	          num   = RegExp.$2;

	      if (delim === 'K') {
	        blockText = globals.gHtmlBlocks[num];
	      } else {
	        // we need to check if ghBlock is a false positive
	        if (codeFlag) {
	          // use encoded version of all text
	          blockText = showdown.subParser('encodeCode')(globals.ghCodeBlocks[num].text, options, globals);
	        } else {
	          blockText = globals.ghCodeBlocks[num].codeblock;
	        }
	      }
	      blockText = blockText.replace(/\$/g, '$$$$'); // Escape any dollar signs

	      grafsOutIt = grafsOutIt.replace(/(\n\n)?¨(K|G)\d+\2(\n\n)?/, blockText);
	      // Check if grafsOutIt is a pre->code
	      if (/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(grafsOutIt)) {
	        codeFlag = true;
	      }
	    }
	    grafsOut[i] = grafsOutIt;
	  }
	  text = grafsOut.join('\n');
	  // Strip leading and trailing lines:
	  text = text.replace(/^\n+/g, '');
	  text = text.replace(/\n+$/g, '');
	  return globals.converter._dispatch('paragraphs.after', text, options, globals);
	});

	/**
	 * Run extension
	 */
	showdown.subParser('runExtension', function (ext, text, options, globals) {

	  if (ext.filter) {
	    text = ext.filter(text, globals.converter, options);

	  } else if (ext.regex) {
	    // TODO remove this when old extension loading mechanism is deprecated
	    var re = ext.regex;
	    if (!(re instanceof RegExp)) {
	      re = new RegExp(re, 'g');
	    }
	    text = text.replace(re, ext.replace);
	  }

	  return text;
	});

	/**
	 * These are all the transformations that occur *within* block-level
	 * tags like paragraphs, headers, and list items.
	 */
	showdown.subParser('spanGamut', function (text, options, globals) {

	  text = globals.converter._dispatch('spanGamut.before', text, options, globals);
	  text = showdown.subParser('codeSpans')(text, options, globals);
	  text = showdown.subParser('escapeSpecialCharsWithinTagAttributes')(text, options, globals);
	  text = showdown.subParser('encodeBackslashEscapes')(text, options, globals);

	  // Process anchor and image tags. Images must come first,
	  // because ![foo][f] looks like an anchor.
	  text = showdown.subParser('images')(text, options, globals);
	  text = showdown.subParser('anchors')(text, options, globals);

	  // Make links out of things like `<http://example.com/>`
	  // Must come after anchors, because you can use < and >
	  // delimiters in inline links like [this](<url>).
	  text = showdown.subParser('autoLinks')(text, options, globals);
	  text = showdown.subParser('simplifiedAutoLinks')(text, options, globals);
	  text = showdown.subParser('emoji')(text, options, globals);
	  text = showdown.subParser('underline')(text, options, globals);
	  text = showdown.subParser('italicsAndBold')(text, options, globals);
	  text = showdown.subParser('strikethrough')(text, options, globals);
	  text = showdown.subParser('ellipsis')(text, options, globals);

	  // we need to hash HTML tags inside spans
	  text = showdown.subParser('hashHTMLSpans')(text, options, globals);

	  // now we encode amps and angles
	  text = showdown.subParser('encodeAmpsAndAngles')(text, options, globals);

	  // Do hard breaks
	  if (options.simpleLineBreaks) {
	    // GFM style hard breaks
	    // only add line breaks if the text does not contain a block (special case for lists)
	    if (!/\n\n¨K/.test(text)) {
	      text = text.replace(/\n+/g, '<br />\n');
	    }
	  } else {
	    // Vanilla hard breaks
	    text = text.replace(/  +\n/g, '<br />\n');
	  }

	  text = globals.converter._dispatch('spanGamut.after', text, options, globals);
	  return text;
	});

	showdown.subParser('strikethrough', function (text, options, globals) {

	  function parseInside (txt) {
	    if (options.simplifiedAutoLink) {
	      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
	    }
	    return '<del>' + txt + '</del>';
	  }

	  if (options.strikethrough) {
	    text = globals.converter._dispatch('strikethrough.before', text, options, globals);
	    text = text.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function (wm, txt) { return parseInside(txt); });
	    text = globals.converter._dispatch('strikethrough.after', text, options, globals);
	  }

	  return text;
	});

	/**
	 * Strips link definitions from text, stores the URLs and titles in
	 * hash references.
	 * Link defs are in the form: ^[id]: url "optional title"
	 */
	showdown.subParser('stripLinkDefinitions', function (text, options, globals) {

	  var regex       = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=¨0))/gm,
	      base64Regex = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=¨0)|(?=\n\[))/gm;

	  // attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
	  text += '¨0';

	  var replaceFunc = function (wholeMatch, linkId, url, width, height, blankLines, title) {
	    linkId = linkId.toLowerCase();
	    if (url.match(/^data:.+?\/.+?;base64,/)) {
	      // remove newlines
	      globals.gUrls[linkId] = url.replace(/\s/g, '');
	    } else {
	      globals.gUrls[linkId] = showdown.subParser('encodeAmpsAndAngles')(url, options, globals);  // Link IDs are case-insensitive
	    }

	    if (blankLines) {
	      // Oops, found blank lines, so it's not a title.
	      // Put back the parenthetical statement we stole.
	      return blankLines + title;

	    } else {
	      if (title) {
	        globals.gTitles[linkId] = title.replace(/"|'/g, '&quot;');
	      }
	      if (options.parseImgDimensions && width && height) {
	        globals.gDimensions[linkId] = {
	          width:  width,
	          height: height
	        };
	      }
	    }
	    // Completely remove the definition from the text
	    return '';
	  };

	  // first we try to find base64 link references
	  text = text.replace(base64Regex, replaceFunc);

	  text = text.replace(regex, replaceFunc);

	  // attacklab: strip sentinel
	  text = text.replace(/¨0/, '');

	  return text;
	});

	showdown.subParser('tables', function (text, options, globals) {

	  if (!options.tables) {
	    return text;
	  }

	  var tableRgx       = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|¨0)/gm,
	      //singeColTblRgx = /^ {0,3}\|.+\|\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n(?: {0,3}\|.+\|\n)+(?:\n\n|¨0)/gm;
	      singeColTblRgx = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|¨0)/gm;

	  function parseStyles (sLine) {
	    if (/^:[ \t]*--*$/.test(sLine)) {
	      return ' style="text-align:left;"';
	    } else if (/^--*[ \t]*:[ \t]*$/.test(sLine)) {
	      return ' style="text-align:right;"';
	    } else if (/^:[ \t]*--*[ \t]*:$/.test(sLine)) {
	      return ' style="text-align:center;"';
	    } else {
	      return '';
	    }
	  }

	  function parseHeaders (header, style) {
	    var id = '';
	    header = header.trim();
	    // support both tablesHeaderId and tableHeaderId due to error in documentation so we don't break backwards compatibility
	    if (options.tablesHeaderId || options.tableHeaderId) {
	      id = ' id="' + header.replace(/ /g, '_').toLowerCase() + '"';
	    }
	    header = showdown.subParser('spanGamut')(header, options, globals);

	    return '<th' + id + style + '>' + header + '</th>\n';
	  }

	  function parseCells (cell, style) {
	    var subText = showdown.subParser('spanGamut')(cell, options, globals);
	    return '<td' + style + '>' + subText + '</td>\n';
	  }

	  function buildTable (headers, cells) {
	    var tb = '<table>\n<thead>\n<tr>\n',
	        tblLgn = headers.length;

	    for (var i = 0; i < tblLgn; ++i) {
	      tb += headers[i];
	    }
	    tb += '</tr>\n</thead>\n<tbody>\n';

	    for (i = 0; i < cells.length; ++i) {
	      tb += '<tr>\n';
	      for (var ii = 0; ii < tblLgn; ++ii) {
	        tb += cells[i][ii];
	      }
	      tb += '</tr>\n';
	    }
	    tb += '</tbody>\n</table>\n';
	    return tb;
	  }

	  function parseTable (rawTable) {
	    var i, tableLines = rawTable.split('\n');

	    for (i = 0; i < tableLines.length; ++i) {
	      // strip wrong first and last column if wrapped tables are used
	      if (/^ {0,3}\|/.test(tableLines[i])) {
	        tableLines[i] = tableLines[i].replace(/^ {0,3}\|/, '');
	      }
	      if (/\|[ \t]*$/.test(tableLines[i])) {
	        tableLines[i] = tableLines[i].replace(/\|[ \t]*$/, '');
	      }
	      // parse code spans first, but we only support one line code spans
	      tableLines[i] = showdown.subParser('codeSpans')(tableLines[i], options, globals);
	    }

	    var rawHeaders = tableLines[0].split('|').map(function (s) { return s.trim();}),
	        rawStyles = tableLines[1].split('|').map(function (s) { return s.trim();}),
	        rawCells = [],
	        headers = [],
	        styles = [],
	        cells = [];

	    tableLines.shift();
	    tableLines.shift();

	    for (i = 0; i < tableLines.length; ++i) {
	      if (tableLines[i].trim() === '') {
	        continue;
	      }
	      rawCells.push(
	        tableLines[i]
	          .split('|')
	          .map(function (s) {
	            return s.trim();
	          })
	      );
	    }

	    if (rawHeaders.length < rawStyles.length) {
	      return rawTable;
	    }

	    for (i = 0; i < rawStyles.length; ++i) {
	      styles.push(parseStyles(rawStyles[i]));
	    }

	    for (i = 0; i < rawHeaders.length; ++i) {
	      if (showdown.helper.isUndefined(styles[i])) {
	        styles[i] = '';
	      }
	      headers.push(parseHeaders(rawHeaders[i], styles[i]));
	    }

	    for (i = 0; i < rawCells.length; ++i) {
	      var row = [];
	      for (var ii = 0; ii < headers.length; ++ii) {
	        if (showdown.helper.isUndefined(rawCells[i][ii])) ;
	        row.push(parseCells(rawCells[i][ii], styles[ii]));
	      }
	      cells.push(row);
	    }

	    return buildTable(headers, cells);
	  }

	  text = globals.converter._dispatch('tables.before', text, options, globals);

	  // find escaped pipe characters
	  text = text.replace(/\\(\|)/g, showdown.helper.escapeCharactersCallback);

	  // parse multi column tables
	  text = text.replace(tableRgx, parseTable);

	  // parse one column tables
	  text = text.replace(singeColTblRgx, parseTable);

	  text = globals.converter._dispatch('tables.after', text, options, globals);

	  return text;
	});

	showdown.subParser('underline', function (text, options, globals) {

	  if (!options.underline) {
	    return text;
	  }

	  text = globals.converter._dispatch('underline.before', text, options, globals);

	  if (options.literalMidWordUnderscores) {
	    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
	      return '<u>' + txt + '</u>';
	    });
	    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
	      return '<u>' + txt + '</u>';
	    });
	  } else {
	    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
	      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
	    });
	    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
	      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
	    });
	  }

	  // escape remaining underscores to prevent them being parsed by italic and bold
	  text = text.replace(/(_)/g, showdown.helper.escapeCharactersCallback);

	  text = globals.converter._dispatch('underline.after', text, options, globals);

	  return text;
	});

	/**
	 * Swap back in all the special characters we've hidden.
	 */
	showdown.subParser('unescapeSpecialChars', function (text, options, globals) {
	  text = globals.converter._dispatch('unescapeSpecialChars.before', text, options, globals);

	  text = text.replace(/¨E(\d+)E/g, function (wholeMatch, m1) {
	    var charCodeToReplace = parseInt(m1);
	    return String.fromCharCode(charCodeToReplace);
	  });

	  text = globals.converter._dispatch('unescapeSpecialChars.after', text, options, globals);
	  return text;
	});

	showdown.subParser('makeMarkdown.blockquote', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    var children = node.childNodes,
	        childrenLength = children.length;

	    for (var i = 0; i < childrenLength; ++i) {
	      var innerTxt = showdown.subParser('makeMarkdown.node')(children[i], globals);

	      if (innerTxt === '') {
	        continue;
	      }
	      txt += innerTxt;
	    }
	  }
	  // cleanup
	  txt = txt.trim();
	  txt = '> ' + txt.split('\n').join('\n> ');
	  return txt;
	});

	showdown.subParser('makeMarkdown.codeBlock', function (node, globals) {

	  var lang = node.getAttribute('language'),
	      num  = node.getAttribute('precodenum');
	  return '```' + lang + '\n' + globals.preList[num] + '\n```';
	});

	showdown.subParser('makeMarkdown.codeSpan', function (node) {

	  return '`' + node.innerHTML + '`';
	});

	showdown.subParser('makeMarkdown.emphasis', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    txt += '*';
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '*';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.header', function (node, globals, headerLevel) {

	  var headerMark = new Array(headerLevel + 1).join('#'),
	      txt = '';

	  if (node.hasChildNodes()) {
	    txt = headerMark + ' ';
	    var children = node.childNodes,
	        childrenLength = children.length;

	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.hr', function () {

	  return '---';
	});

	showdown.subParser('makeMarkdown.image', function (node) {

	  var txt = '';
	  if (node.hasAttribute('src')) {
	    txt += '![' + node.getAttribute('alt') + '](';
	    txt += '<' + node.getAttribute('src') + '>';
	    if (node.hasAttribute('width') && node.hasAttribute('height')) {
	      txt += ' =' + node.getAttribute('width') + 'x' + node.getAttribute('height');
	    }

	    if (node.hasAttribute('title')) {
	      txt += ' "' + node.getAttribute('title') + '"';
	    }
	    txt += ')';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.links', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes() && node.hasAttribute('href')) {
	    var children = node.childNodes,
	        childrenLength = children.length;
	    txt = '[';
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '](';
	    txt += '<' + node.getAttribute('href') + '>';
	    if (node.hasAttribute('title')) {
	      txt += ' "' + node.getAttribute('title') + '"';
	    }
	    txt += ')';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.list', function (node, globals, type) {

	  var txt = '';
	  if (!node.hasChildNodes()) {
	    return '';
	  }
	  var listItems       = node.childNodes,
	      listItemsLenght = listItems.length,
	      listNum = node.getAttribute('start') || 1;

	  for (var i = 0; i < listItemsLenght; ++i) {
	    if (typeof listItems[i].tagName === 'undefined' || listItems[i].tagName.toLowerCase() !== 'li') {
	      continue;
	    }

	    // define the bullet to use in list
	    var bullet = '';
	    if (type === 'ol') {
	      bullet = listNum.toString() + '. ';
	    } else {
	      bullet = '- ';
	    }

	    // parse list item
	    txt += bullet + showdown.subParser('makeMarkdown.listItem')(listItems[i], globals);
	    ++listNum;
	  }

	  // add comment at the end to prevent consecutive lists to be parsed as one
	  txt += '\n<!-- -->\n';
	  return txt.trim();
	});

	showdown.subParser('makeMarkdown.listItem', function (node, globals) {

	  var listItemTxt = '';

	  var children = node.childNodes,
	      childrenLenght = children.length;

	  for (var i = 0; i < childrenLenght; ++i) {
	    listItemTxt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	  }
	  // if it's only one liner, we need to add a newline at the end
	  if (!/\n$/.test(listItemTxt)) {
	    listItemTxt += '\n';
	  } else {
	    // it's multiparagraph, so we need to indent
	    listItemTxt = listItemTxt
	      .split('\n')
	      .join('\n    ')
	      .replace(/^ {4}$/gm, '')
	      .replace(/\n\n+/g, '\n\n');
	  }

	  return listItemTxt;
	});



	showdown.subParser('makeMarkdown.node', function (node, globals, spansOnly) {

	  spansOnly = spansOnly || false;

	  var txt = '';

	  // edge case of text without wrapper paragraph
	  if (node.nodeType === 3) {
	    return showdown.subParser('makeMarkdown.txt')(node, globals);
	  }

	  // HTML comment
	  if (node.nodeType === 8) {
	    return '<!--' + node.data + '-->\n\n';
	  }

	  // process only node elements
	  if (node.nodeType !== 1) {
	    return '';
	  }

	  var tagName = node.tagName.toLowerCase();

	  switch (tagName) {

	    //
	    // BLOCKS
	    //
	    case 'h1':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 1) + '\n\n'; }
	      break;
	    case 'h2':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 2) + '\n\n'; }
	      break;
	    case 'h3':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 3) + '\n\n'; }
	      break;
	    case 'h4':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 4) + '\n\n'; }
	      break;
	    case 'h5':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 5) + '\n\n'; }
	      break;
	    case 'h6':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 6) + '\n\n'; }
	      break;

	    case 'p':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.paragraph')(node, globals) + '\n\n'; }
	      break;

	    case 'blockquote':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.blockquote')(node, globals) + '\n\n'; }
	      break;

	    case 'hr':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.hr')(node, globals) + '\n\n'; }
	      break;

	    case 'ol':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ol') + '\n\n'; }
	      break;

	    case 'ul':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ul') + '\n\n'; }
	      break;

	    case 'precode':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.codeBlock')(node, globals) + '\n\n'; }
	      break;

	    case 'pre':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.pre')(node, globals) + '\n\n'; }
	      break;

	    case 'table':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.table')(node, globals) + '\n\n'; }
	      break;

	    //
	    // SPANS
	    //
	    case 'code':
	      txt = showdown.subParser('makeMarkdown.codeSpan')(node, globals);
	      break;

	    case 'em':
	    case 'i':
	      txt = showdown.subParser('makeMarkdown.emphasis')(node, globals);
	      break;

	    case 'strong':
	    case 'b':
	      txt = showdown.subParser('makeMarkdown.strong')(node, globals);
	      break;

	    case 'del':
	      txt = showdown.subParser('makeMarkdown.strikethrough')(node, globals);
	      break;

	    case 'a':
	      txt = showdown.subParser('makeMarkdown.links')(node, globals);
	      break;

	    case 'img':
	      txt = showdown.subParser('makeMarkdown.image')(node, globals);
	      break;

	    default:
	      txt = node.outerHTML + '\n\n';
	  }

	  // common normalization
	  // TODO eventually

	  return txt;
	});

	showdown.subParser('makeMarkdown.paragraph', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	  }

	  // some text normalization
	  txt = txt.trim();

	  return txt;
	});

	showdown.subParser('makeMarkdown.pre', function (node, globals) {

	  var num  = node.getAttribute('prenum');
	  return '<pre>' + globals.preList[num] + '</pre>';
	});

	showdown.subParser('makeMarkdown.strikethrough', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    txt += '~~';
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '~~';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.strong', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    txt += '**';
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '**';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.table', function (node, globals) {

	  var txt = '',
	      tableArray = [[], []],
	      headings   = node.querySelectorAll('thead>tr>th'),
	      rows       = node.querySelectorAll('tbody>tr'),
	      i, ii;
	  for (i = 0; i < headings.length; ++i) {
	    var headContent = showdown.subParser('makeMarkdown.tableCell')(headings[i], globals),
	        allign = '---';

	    if (headings[i].hasAttribute('style')) {
	      var style = headings[i].getAttribute('style').toLowerCase().replace(/\s/g, '');
	      switch (style) {
	        case 'text-align:left;':
	          allign = ':---';
	          break;
	        case 'text-align:right;':
	          allign = '---:';
	          break;
	        case 'text-align:center;':
	          allign = ':---:';
	          break;
	      }
	    }
	    tableArray[0][i] = headContent.trim();
	    tableArray[1][i] = allign;
	  }

	  for (i = 0; i < rows.length; ++i) {
	    var r = tableArray.push([]) - 1,
	        cols = rows[i].getElementsByTagName('td');

	    for (ii = 0; ii < headings.length; ++ii) {
	      var cellContent = ' ';
	      if (typeof cols[ii] !== 'undefined') {
	        cellContent = showdown.subParser('makeMarkdown.tableCell')(cols[ii], globals);
	      }
	      tableArray[r].push(cellContent);
	    }
	  }

	  var cellSpacesCount = 3;
	  for (i = 0; i < tableArray.length; ++i) {
	    for (ii = 0; ii < tableArray[i].length; ++ii) {
	      var strLen = tableArray[i][ii].length;
	      if (strLen > cellSpacesCount) {
	        cellSpacesCount = strLen;
	      }
	    }
	  }

	  for (i = 0; i < tableArray.length; ++i) {
	    for (ii = 0; ii < tableArray[i].length; ++ii) {
	      if (i === 1) {
	        if (tableArray[i][ii].slice(-1) === ':') {
	          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, '-') + ':';
	        } else {
	          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount, '-');
	        }
	      } else {
	        tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount);
	      }
	    }
	    txt += '| ' + tableArray[i].join(' | ') + ' |\n';
	  }

	  return txt.trim();
	});

	showdown.subParser('makeMarkdown.tableCell', function (node, globals) {

	  var txt = '';
	  if (!node.hasChildNodes()) {
	    return '';
	  }
	  var children = node.childNodes,
	      childrenLength = children.length;

	  for (var i = 0; i < childrenLength; ++i) {
	    txt += showdown.subParser('makeMarkdown.node')(children[i], globals, true);
	  }
	  return txt.trim();
	});

	showdown.subParser('makeMarkdown.txt', function (node) {

	  var txt = node.nodeValue;

	  // multiple spaces are collapsed
	  txt = txt.replace(/ +/g, ' ');

	  // replace the custom ¨NBSP; with a space
	  txt = txt.replace(/¨NBSP;/g, ' ');

	  // ", <, > and & should replace escaped html entities
	  txt = showdown.helper.unescapeHTMLEntities(txt);

	  // escape markdown magic characters
	  // emphasis, strong and strikethrough - can appear everywhere
	  // we also escape pipe (|) because of tables
	  // and escape ` because of code blocks and spans
	  txt = txt.replace(/([*_~|`])/g, '\\$1');

	  // escape > because of blockquotes
	  txt = txt.replace(/^(\s*)>/g, '\\$1>');

	  // hash character, only troublesome at the beginning of a line because of headers
	  txt = txt.replace(/^#/gm, '\\#');

	  // horizontal rules
	  txt = txt.replace(/^(\s*)([-=]{3,})(\s*)$/, '$1\\$2$3');

	  // dot, because of ordered lists, only troublesome at the beginning of a line when preceded by an integer
	  txt = txt.replace(/^( {0,3}\d+)\./gm, '$1\\.');

	  // +, * and -, at the beginning of a line becomes a list, so we need to escape them also (asterisk was already escaped)
	  txt = txt.replace(/^( {0,3})([+-])/gm, '$1\\$2');

	  // images and links, ] followed by ( is problematic, so we escape it
	  txt = txt.replace(/]([\s]*)\(/g, '\\]$1\\(');

	  // reference URIs must also be escaped
	  txt = txt.replace(/^ {0,3}\[([\S \t]*?)]:/gm, '\\[$1]:');

	  return txt;
	});

	var root = this;

	// AMD Loader
	if (module.exports) {
	  module.exports = showdown;

	// Regular Browser loader
	} else {
	  root.showdown = showdown;
	}
	}).call(commonjsGlobal);


	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors

	frappe.provide("frappe.tools");

	frappe.tools.downloadify = function(data, roles, title) {
		if(roles && roles.length && !has_common(roles, roles)) {
			frappe.msgprint(__("Export not allowed. You need {0} role to export.", [frappe.utils.comma_or(roles)]));
			return;
		}

		var filename = title + ".csv";
		var csv_data = frappe.tools.to_csv(data);
		var a = document.createElement('a');

		if ("download" in a) {
			// Used Blob object, because it can handle large files
			var blob_object = new Blob([csv_data], { type: 'text/csv;charset=UTF-8' });
			a.href = URL.createObjectURL(blob_object);
			a.download = filename;

		} else {
			// use old method
			a.href = 'data:attachment/csv,' + encodeURIComponent(csv_data);
			a.download = filename;
			a.target = "_blank";
		}

		document.body.appendChild(a);
		a.click();

		document.body.removeChild(a);
	};

	frappe.markdown = function(txt) {
		if(!frappe.md2html) {
			frappe.md2html = new showdown.Converter();
		}

		while(txt.substr(0,1)==="\n") {
			txt = txt.substr(1);
		}

		// remove leading tab (if they exist in the first line)
		var whitespace_len = 0,
			first_line = txt.split("\n")[0];

		while(["\n", "\t"].indexOf(first_line.substr(0,1))!== -1) {
			whitespace_len++;
			first_line = first_line.substr(1);
		}

		if(whitespace_len && whitespace_len != first_line.length) {
			var txt1 = [];
			$.each(txt.split("\n"), function(i, t) {
				txt1.push(t.substr(whitespace_len));
			});
			txt = txt1.join("\n");
		}

		return frappe.md2html.makeHtml(txt);
	};

	frappe.tools.to_csv = function(data) {
		var res = [];
		$.each(data, function(i, row) {
			row = $.map(row, function(col) {
				if (col === null || col === undefined) { col = ''; }
				return typeof col === "string" ? ('"' + $('<i>').html(col.replace(/"/g, '""')).text() + '"') : col;
			});
			res.push(row.join(","));
		});
		return res.join("\n");
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.datetime');

	frappe.defaultDateFormat = "YYYY-MM-DD";
	frappe.defaultTimeFormat = "HH:mm:ss";
	frappe.defaultDatetimeFormat = frappe.defaultDateFormat + " " + frappe.defaultTimeFormat;
	moment.defaultFormat = frappe.defaultDateFormat;

	frappe.provide("frappe.datetime");

	$.extend(frappe.datetime, {
		convert_to_user_tz: function(date, format) {
			// format defaults to true
			if(frappe.sys_defaults.time_zone) {
				var date_obj = moment.tz(date, frappe.sys_defaults.time_zone).local();
			} else {
				var date_obj = moment(date);
			}

			return (format===false) ? date_obj : date_obj.format(frappe.defaultDatetimeFormat);
		},

		convert_to_system_tz: function(date, format) {
			// format defaults to true

			if(frappe.sys_defaults.time_zone) {
				var date_obj = moment(date).tz(frappe.sys_defaults.time_zone);
			} else {
				var date_obj = moment(date);
			}

			return (format===false) ? date_obj : date_obj.format(frappe.defaultDatetimeFormat);
		},

		is_timezone_same: function() {
			if(frappe.sys_defaults.time_zone) {
				return moment().tz(frappe.sys_defaults.time_zone).utcOffset() === moment().utcOffset();
			} else {
				return true;
			}
		},

		str_to_obj: function(d) {
			return moment(d, frappe.defaultDatetimeFormat)._d;
		},

		obj_to_str: function(d) {
			return moment(d).locale("en").format();
		},

		obj_to_user: function(d) {
			return moment(d).format(frappe.datetime.get_user_date_fmt().toUpperCase());
		},

		get_diff: function(d1, d2) {
			return moment(d1).diff(d2, "days");
		},

		get_hour_diff: function(d1, d2) {
			return moment(d1).diff(d2, "hours");
		},

		get_day_diff: function(d1, d2) {
			return moment(d1).diff(d2, "days");
		},

		add_days: function(d, days) {
			return moment(d).add(days, "days").format();
		},

		add_months: function(d, months) {
			return moment(d).add(months, "months").format();
		},

		week_start: function() {
			return moment().startOf("week").format();
		},

		week_end: function() {
			return moment().endOf("week").format();
		},

		month_start: function() {
			return moment().startOf("month").format();
		},

		month_end: function() {
			return moment().endOf("month").format();
		},

		quarter_start: function() {
			return moment().startOf("quarter").format();
		},

		quarter_end: function() {
			return moment().endOf("quarter").format();
		},

		year_start: function(){
			return moment().startOf("year").format();
		},

		year_end: function(){
			return moment().endOf("year").format();
		},

		get_user_time_fmt: function() {
			return frappe.sys_defaults && frappe.sys_defaults.time_format || "HH:mm:ss";
		},

		get_user_date_fmt: function() {
			return frappe.sys_defaults && frappe.sys_defaults.date_format || "yyyy-mm-dd";
		},

		get_user_fmt: function() {  // For backwards compatibility only
			return frappe.sys_defaults && frappe.sys_defaults.date_format || "yyyy-mm-dd";
		},

		str_to_user: function(val, only_time) {
			if ( only_time === void 0 ) only_time = false;

			if(!val) { return ""; }

			var user_time_fmt = frappe.datetime.get_user_time_fmt();
			if(only_time) {
				return moment(val, frappe.defaultTimeFormat)
					.format(user_time_fmt);
			}

			var user_date_fmt = frappe.datetime.get_user_date_fmt().toUpperCase();
			if(typeof val !== "string" || val.indexOf(" ")===-1) {
				return moment(val).format(user_date_fmt);
			} else {
				return moment(val, "YYYY-MM-DD HH:mm:ss").format(user_date_fmt + " " + user_time_fmt);
			}
		},

		get_datetime_as_string: function(d) {
			return moment(d).format("YYYY-MM-DD HH:mm:ss");
		},

		user_to_str: function(val, only_time) {
			if ( only_time === void 0 ) only_time = false;


			var user_time_fmt = frappe.datetime.get_user_time_fmt();
			if(only_time) {
				return moment(val, user_time_fmt)
					.format(frappe.defaultTimeFormat);
			}

			var user_fmt = frappe.datetime.get_user_date_fmt().toUpperCase();
			var system_fmt = "YYYY-MM-DD";

			if(val.indexOf(" ")!==-1) {
				user_fmt += " " + user_time_fmt;
				system_fmt += " HH:mm:ss";
			}

			// user_fmt.replace("YYYY", "YY")? user might only input 2 digits of the year, which should also be parsed
			return moment(val, [user_fmt.replace("YYYY", "YY"),
				user_fmt]).locale("en").format(system_fmt);
		},

		user_to_obj: function(d) {
			return frappe.datetime.str_to_obj(frappe.datetime.user_to_str(d));
		},

		global_date_format: function(d) {
			var m = moment(d);
			if(m._f && m._f.indexOf("HH")!== -1) {
				return m.format("Do MMMM YYYY, h:mma")
			} else {
				return m.format('Do MMMM YYYY');
			}
		},

		now_date: function(as_obj) {
			if ( as_obj === void 0 ) as_obj = false;

			return frappe.datetime._date(frappe.defaultDateFormat, as_obj);
		},

		now_time: function(as_obj) {
			if ( as_obj === void 0 ) as_obj = false;

			return frappe.datetime._date(frappe.defaultTimeFormat, as_obj);
		},

		now_datetime: function(as_obj) {
			if ( as_obj === void 0 ) as_obj = false;

			return frappe.datetime._date(frappe.defaultDatetimeFormat, as_obj);
		},

		_date: function(format, as_obj) {
			if ( as_obj === void 0 ) as_obj = false;

			var time_zone = frappe.sys_defaults && frappe.sys_defaults.time_zone;
			var date;
			if (time_zone) {
				date = moment.tz(time_zone);
			} else {
				date = moment();
			}
			if (as_obj) {
				return frappe.datetime.moment_to_date_obj(date);
			} else {
				return date.format(format);
			}
		},

		moment_to_date_obj: function(moment) {
			var date_obj = new Date();
			var date_array = moment.toArray();
			date_obj.setFullYear(date_array[0]);
			date_obj.setMonth(date_array[1]);
			date_obj.setDate(date_array[2]);
			date_obj.setHours(date_array[3]);
			date_obj.setMinutes(date_array[4]);
			date_obj.setSeconds(date_array[5]);
			date_obj.setMilliseconds(date_array[6]);
			return date_obj;
		},

		nowdate: function() {
			return frappe.datetime.now_date();
		},

		get_today: function() {
			return frappe.datetime.now_date();
		},

		get_time: function (timestamp) {
			// return time with AM/PM
			return moment(timestamp).format('hh:mm A');
		},

		validate: function(d) {
			return moment(d, [
				frappe.defaultDateFormat,
				frappe.defaultDatetimeFormat,
				frappe.defaultTimeFormat
			], true).isValid();
		},

	});

	// Proxy for dateutil and get_today
	Object.defineProperties(window, {
		'dateutil': {
			get: function() {
				console.warn('Please use `frappe.datetime` instead of `dateutil`. It will be deprecated soon.');
				return frappe.datetime;
			}
		},
		'date': {
			get: function() {
				console.warn('Please use `frappe.datetime` instead of `date`. It will be deprecated soon.');
				return frappe.datetime;
			}
		},
		'get_today': {
			get: function() {
				console.warn('Please use `frappe.datetime.get_today` instead of `get_today`. It will be deprecated soon.');
				return frappe.datetime.get_today;
			}
		}
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	window.cstr = function(s) {
		if(s==null){ return ''; }
		return s+'';
	};

	window.cint = function(v, def) {
		if (v === true)
			{ return 1; }
		if (v === false)
			{ return 0; }
		v = v + '';
		if (v !== "0") { v = lstrip(v, ['0']); }
		v = parseInt(v); // eslint-ignore-line
		if (isNaN(v)) { v = def === undefined ? 0 : def; }
		return v;
	};

	// to title case
	window.toTitle = function(str){
		var word_in = str.split(" ");
		var word_out = [];

		for(var w in word_in){
			word_out[w] = word_in[w].charAt(0).toUpperCase() + word_in[w].slice(1);
		}

		return word_out.join(" ");
	};

	window.is_null = function(v) {
		if(v===null || v===undefined || cstr(v).trim()==="") { return true; }
	};

	window.copy_dict = function(d) {
		var n = {};
		for(var k in d) { n[k] = d[k]; }
		return n;
	};

	window.validate_email = function(txt) {
		return frappe.utils.validate_type(txt, "email");
	};

	window.validate_phone = function(txt) {
		return frappe.utils.validate_type(txt, "phone");
	};

	window.validate_name = function(txt) {
		return frappe.utils.validate_type(txt, "name");
	};

	window.nth = function(number) {
		number = cint(number);
		var s = 'th';
		if((number+'').substr(-1)=='1') { s = 'st'; }
		if((number+'').substr(-1)=='2') { s = 'nd'; }
		if((number+'').substr(-1)=='3') { s = 'rd'; }
		return number+s;
	};

	window.has_words = function(list, item) {
		if(!item) { return true; }
		if(!list) { return false; }
		for(var i=0, j=list.length; i<j; i++) {
			if(item.indexOf(list[i])!=-1)
				{ return true; }
		}
		return false;
	};

	window.has_common = function(list1, list2) {
		if(!list1 || !list2) { return false; }
		for(var i=0, j=list1.length; i<j; i++) {
			if(in_list(list2, list1[i])){ return true; }
		}
		return false;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors

	if (!window.frappe) { window.frappe = {}; }

	function flt$1(v, decimals, number_format) {
		if (v == null || v == '') { return 0; }

		if (typeof v !== "number") {
			v = v + "";

			// strip currency symbol if exists
			if (v.indexOf(" ") != -1) {
				// using slice(1).join(" ") because space could also be a group separator
				var parts = v.split(" ");
				v = isNaN(parseFloat(parts[0])) ? parts.slice(parts.length - 1).join(" ") : v;
			}

			v = strip_number_groups(v, number_format);

			v = parseFloat(v);
			if (isNaN(v))
				{ v = 0; }
		}

		if (decimals != null)
			{ return _round(v, decimals); }
		return v;
	}

	function strip_number_groups(v, number_format) {
		if (!number_format) { number_format = get_number_format$1(); }
		var info = get_number_format_info$1(number_format);

		// strip groups (,)
		var group_regex = new RegExp(info.group_sep === "." ? "\\." : info.group_sep, "g");
		v = v.replace(group_regex, "");

		// replace decimal separator with (.)
		if (info.decimal_str !== "." && info.decimal_str !== "") {
			var decimal_regex = new RegExp(info.decimal_str, "g");
			v = v.replace(decimal_regex, ".");
		}

		return v;
	}


	frappe.number_format_info = {
		"#,###.##": { decimal_str: ".", group_sep: "," },
		"#.###,##": { decimal_str: ",", group_sep: "." },
		"# ###.##": { decimal_str: ".", group_sep: " " },
		"# ###,##": { decimal_str: ",", group_sep: " " },
		"#'###.##": { decimal_str: ".", group_sep: "'" },
		"#, ###.##": { decimal_str: ".", group_sep: ", " },
		"#,##,###.##": { decimal_str: ".", group_sep: "," },
		"#,###.###": { decimal_str: ".", group_sep: "," },
		"#.###": { decimal_str: "", group_sep: "." },
		"#,###": { decimal_str: "", group_sep: "," },
	};

	window.format_number = function (v, format, decimals) {
		if (!format) {
			format = get_number_format$1();
			if (decimals == null) { decimals = cint(frappe.defaults.get_default("float_precision")) || 3; }
		}

		var info = get_number_format_info$1(format);

		// Fix the decimal first, toFixed will auto fill trailing zero.
		if (decimals == null) { decimals = info.precision; }

		v = flt$1(v, decimals, format);

		var is_negative = false;
		if (v < 0) { is_negative = true; }
		v = Math.abs(v);

		v = v.toFixed(decimals);

		var part = v.split('.');

		// get group position and parts
		var group_position = info.group_sep ? 3 : 0;

		if (group_position) {
			var integer = part[0];
			var str = '';
			var offset = integer.length % group_position;
			for (var i = integer.length; i >= 0; i--) {
				var l = replace_all(str, info.group_sep, "").length;
				if (format == "#,##,###.##" && str.indexOf(",") != -1) { // INR
					group_position = 2;
					l += 1;
				}

				str += integer.charAt(i);

				if (l && !((l + 1) % group_position) && i != 0) {
					str += info.group_sep;
				}
			}
			part[0] = str.split("").reverse().join("");
		}
		if (part[0] + "" == "") {
			part[0] = "0";
		}

		// join decimal
		part[1] = (part[1] && info.decimal_str) ? (info.decimal_str + part[1]) : "";

		// join
		return (is_negative ? "-" : "") + part[0] + part[1];
	};

	function format_currency$1(v, currency, decimals) {
		var format = get_number_format$1(currency);
		var symbol = get_currency_symbol(currency);
		if(decimals === undefined) {
			decimals = frappe.boot.sysdefaults.currency_precision || null;
		}

		if (symbol)
			{ return symbol + " " + format_number(v, format, decimals); }
		else
			{ return format_number(v, format, decimals); }
	}

	function get_currency_symbol(currency) {
		if (frappe.boot) {
			if (frappe.boot.sysdefaults && frappe.boot.sysdefaults.hide_currency_symbol == "Yes")
				{ return null; }

			if (!currency)
				{ currency = frappe.boot.sysdefaults.currency; }

			return frappe.model.get_value(":Currency", currency, "symbol") || currency;
		} else {
			// load in template
			return frappe.currency_symbols[currency];
		}
	}

	function get_number_format$1(currency) {
		return (frappe.boot && frappe.boot.sysdefaults && frappe.boot.sysdefaults.number_format) || "#,###.##";
	}

	function get_number_format_info$1(format) {
		var info = frappe.number_format_info[format];

		if (!info) {
			info = { decimal_str: ".", group_sep: "," };
		}

		// get the precision from the number format
		info.precision = format.split(info.decimal_str).slice(1)[0].length;

		return info;
	}

	function _round(num, precision) {
		var is_negative = num < 0 ? true : false;
		var d = cint(precision);
		var m = Math.pow(10, d);
		var n = +(d ? Math.abs(num) * m : Math.abs(num)).toFixed(8); // Avoid rounding errors
		var i = Math.floor(n), f = n - i;
		var r = ((!precision && f == 0.5) ? ((i % 2 == 0) ? i : i + 1) : Math.round(n));
		r = d ? r / m : r;
		return is_negative ? -r : r;

	}

	function roundNumber(num, precision) {
		// backward compatibility
		return _round(num, precision);
	}

	function precision$1(fieldname, doc) {
		if (cur_frm) {
			if (!doc) { doc = cur_frm.doc; }
			var df = frappe.meta.get_docfield(doc.doctype, fieldname, doc.parent || doc.name);
			if (!df) { console.log(fieldname + ": could not find docfield in method precision()"); }
			return frappe.meta.get_field_precision(df, doc);
		} else {
			return frappe.boot.sysdefaults.float_precision
		}
	}

	function in_list$1(list, item) {
		return list.includes(item);
	}

	function remainder(numerator, denominator, precision) {
		precision = cint(precision);
		var multiplier = Math.pow(10, precision);
		if (precision) {
			var _remainder = ((numerator * multiplier) % (denominator * multiplier)) / multiplier;
		} else {
			var _remainder = numerator % denominator;
		}

		return flt$1(_remainder, precision);
	}

	function round_based_on_smallest_currency_fraction(value, currency, precision) {
		var smallest_currency_fraction_value = flt$1(frappe.model.get_value(":Currency",
			currency, "smallest_currency_fraction_value"));

		if (smallest_currency_fraction_value) {
			var remainder_val = remainder(value, smallest_currency_fraction_value, precision);
			if (remainder_val > (smallest_currency_fraction_value / 2)) {
				value += (smallest_currency_fraction_value - remainder_val);
			} else {
				value -= remainder_val;
			}
		} else {
			value = _round(value);
		}
		return value;
	}

	function fmt_money(v, format){
		// deprecated!
		// for backward compatibility
		return format_currency$1(v, format);
	}


	Object.assign(window, {
		flt: flt$1,
		cint: cint,
		strip_number_groups: strip_number_groups,
		format_currency: format_currency$1,
		fmt_money: fmt_money,
		get_currency_symbol: get_currency_symbol,
		get_number_format: get_number_format$1,
		get_number_format_info: get_number_format_info$1,
		_round: _round,
		roundNumber: roundNumber,
		precision: precision$1,
		remainder: remainder,
		round_based_on_smallest_currency_fraction: round_based_on_smallest_currency_fraction,
		in_list: in_list$1
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.help");

	frappe.help.youtube_id = {};

	frappe.help.has_help = function(doctype) {
		return frappe.help.youtube_id[doctype];
	};

	frappe.help.show = function(doctype) {
		if(frappe.help.youtube_id[doctype]) {
			frappe.help.show_video(frappe.help.youtube_id[doctype]);
		}
	};

	frappe.help.show_video = function(youtube_id, title) {
		if (frappe.utils.is_url(youtube_id)) {
			var expression = '(?:youtube.com/(?:[^/]+/.+/|(?:v|e(?:mbed)?)/|.*[?&]v=)|youtu.be/)([^"&?\\s]{11})';
			youtube_id = youtube_id.match(expression)[1];
		}

		if($("body").width() > 768) {
			var size = [670, 377];
		} else {
			var size = [560, 315];
		}
		var dialog = frappe.msgprint({
			message: "<iframe width=\"" + (size[0]) + "\" height=\"" + (size[1]) + "\"\n\t\t\tsrc=\"https://www.youtube.com/embed/" + youtube_id + "\"\n\t\t\tframeborder=\"0\" allowfullscreen></iframe>" + (frappe.help_feedback_link || ""),
			title: title || __("Help"),
			wide: true
		});

		dialog.$wrapper.addClass("video-modal");
	};

	$("body").on("click", "a.help-link", function() {
		var doctype = $(this).attr("data-doctype");
		doctype && frappe.help.show(doctype);
	});

	frappe.provide('frappe.help.help_links');

	frappe.help.help_links['data-import-tool'] = [
		{ label: 'Importing and Exporting Data', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/data/data-import-tool.html' } ];

	frappe.help.help_links['modules/Setup'] = [
		{ label: 'Users and Permissions', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/users-and-permissions/' },
		{ label: 'Settings', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/settings/' },
		{ label: 'Data Management', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/data/' },
		{ label: 'Email', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/email/' },
		{ label: 'Printing', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/print/' } ];

	frappe.help.help_links['List/User'] = [
		{ label: 'Adding Users', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/users-and-permissions/adding-users' },
		{ label: 'Rename User', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/articles/rename-user' } ];

	frappe.help.help_links['permission-manager'] = [
		{ label: 'Role Permissions Manager', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/users-and-permissions/role-based-permissions' } ];

	frappe.help.help_links['user-permissions'] = [
		{ label: 'User Permissions', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/users-and-permissions/user-permissions' } ];

	frappe.help.help_links['Form/System Settings'] = [
		{ label: 'System Settings', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/settings/system-settings' } ];

	frappe.help.help_links['List/Email Account'] = [
		{ label: 'Email Account', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/email/email-account' } ];

	frappe.help.help_links['List/Notification'] = [
		{ label: 'Notification', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/email/email-alerts' } ];

	frappe.help.help_links['Form/Print Settings'] = [
		{ label: 'Print Settings', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/print/print-settings' } ];

	frappe.help.help_links['print-format-builder'] = [
		{ label: 'Print Format Builder', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/print/print-format-builder' } ];

	frappe.provide('frappe.contacts');

	$.extend(frappe.contacts, {
		clear_address_and_contact: function(frm) {
			$(frm.fields_dict['address_html'].wrapper).html("");
			frm.fields_dict['contact_html'] && $(frm.fields_dict['contact_html'].wrapper).html("");
		},

		render_address_and_contact: function(frm) {
			// render address
			if(frm.fields_dict['address_html'] && "addr_list" in frm.doc.__onload) {
				$(frm.fields_dict['address_html'].wrapper)
					.html(frappe.render_template("address_list",
						frm.doc.__onload))
					.find(".btn-address").on("click", function() {
						frappe.new_doc("Address");
					});
			}

			// render contact
			if(frm.fields_dict['contact_html'] && "contact_list" in frm.doc.__onload) {
				$(frm.fields_dict['contact_html'].wrapper)
					.html(frappe.render_template("contact_list",
						frm.doc.__onload))
					.find(".btn-contact").on("click", function() {
						frappe.new_doc("Contact");
					}
				);
			}
		},
		get_last_doc: function(frm) {
			var reverse_routes = frappe.route_history.reverse();
			var last_route = reverse_routes.find(function (route) {
				return route[0] === 'Form' && route[1] !== frm.doctype
			});
			var doctype = last_route && last_route[1];
			var docname = last_route && last_route[2];

			if (last_route && last_route.length > 3)
				{ docname = last_route.slice(2).join("/"); }

			return {
				doctype: doctype,
				docname: docname
			}
		}
	});

	frappe.preview_email = function(template, args, header) {
		frappe
			.call({
				method: 'frappe.email.email_body.get_email_html',
				args: {
					subject: 'Test',
					template: template,
					args: args,
					header: header
				}
			})
			.then(function (r) {
				var html = r.message;
				html = html.replace(/embed=/, 'src=');
				var d = frappe.msgprint({
					message:
						'<iframe width="100%" height="600px" style="border: none;"></iframe>',
					wide: true
				});

				setTimeout(function () {
					d.$wrapper
						.find('iframe')
						.contents()
						.find('html')
						.html(html);
					d.$wrapper.find('.modal-dialog').css('width', '70%');
				}, 1000);
			});
	};

	frappe.provide('frappe.file_manager');

	frappe.file_manager = function() {
		var files_to_move = [];
		var	old_folder = null;
		var new_folder = null;

		function cut(files, old_folder_) {
			files_to_move = files;
			old_folder = old_folder_;
		}

		function paste(new_folder_) {
			return new Promise(function (resolve, reject) {
				if (files_to_move.length === 0 || !old_folder) {
					reset();
					resolve();
					return;
				}
				new_folder = new_folder_;

				frappe.call({
					method:"frappe.core.doctype.file.file.move_file",
					args: {
						file_list: files_to_move,
						new_parent: new_folder,
						old_parent: old_folder
					},
					callback: function (r) {
						reset();
						resolve(r);
					}
				}).fail(reject);
			});
		}

		function reset() {
			files_to_move = [];
			old_folder = null;
			new_folder = null;
		}

		return {
			cut: cut,
			paste: paste,
			get can_paste() {
				return Boolean(files_to_move.length > 0 && old_folder);
			},
			get old_folder() {
				return old_folder;
			},
			get files_to_move() {
				return files_to_move;
			}
		};
	}();

	frappe.templates['upload'] = '<div class="file-upload">  <div class="input-upload">   <input class="input-upload-file hidden" type="file" {{ opts.allow_multiple ? "multiple" : "" }} name="filedata" />   <button class="btn btn-primary btn-sm btn-browse">{%= __("Browse") %}</button>  </div>  <div class="uploaded-filename hidden" style="width: 100%; margin-top: 12px;"></div>  <div class="web-link-wrapper" style="width: calc(100% - 80px);">   <span class="text-muted file-upload-or">{%= __("or") %}</span>   <div class="input-link" style="width: calc(100% - 30px);">    <div class="input-group">     <div class="input-group-addon">      <span class="hidden-xs">{%= __("Web Link") %}</span>      <i class="fa fa-link visible-xs"></i>     </div>     <input class="form-control" type="text" name="file_url"      placeholder="{%= (opts.sample_url || "e.g. http://example.com/somefile.png") %}"/>    </div>   </div>  </div>  <div class="private-file hidden">   <div class="checkbox">       <label>         <input type="checkbox" checked> {{ __("Private") }}       </label>     </div>  </div> </div> ';

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var script = {
		name: 'FilePreview',
		props: ['file'],
		data: function data() {
			return {
				src: null
			}
		},
		mounted: function mounted() {
			var this$1 = this;

			if (this.is_image) {
				if (window.FileReader) {
					var fr = new FileReader();
					fr.onload = function () { return this$1.src = fr.result; };
					fr.readAsDataURL(this.file.file_obj);
				}
			}
		},
		filters: {
			file_size: function file_size(value) {
				return frappe.form.formatters.FileSize(value);
			},
			file_name: function file_name(value) {
				return frappe.utils.file_name_ellipsis(value, 9);
			}
		},
		computed: {
			uploaded: function uploaded() {
				return this.file.total && this.file.total === this.file.progress && !this.file.failed;
			},
			is_image: function is_image() {
				return this.file.file_obj.type.startsWith('image');
			}
		}
	};

	/* script */
	            var __vue_script__ = script;
	            
	/* template */
	var __vue_render__ = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", { staticClass: "file-preview" }, [
	    _c("div", { staticClass: "file-icon border rounded" }, [
	      _vm.is_image
	        ? _c("img", {
	            staticStyle: { "object-fit": "cover", height: "100%" },
	            attrs: { src: _vm.src, alt: _vm.file.name }
	          })
	        : _c(
	            "div",
	            {
	              staticClass: "flex align-center justify-center",
	              staticStyle: { height: "100%" }
	            },
	            [
	              _c("i", {
	                staticClass: "octicon octicon-file-text text-extra-muted",
	                staticStyle: { "font-size": "5rem" }
	              })
	            ]
	          )
	    ]),
	    _vm._v(" "),
	    _c("div", { staticClass: "file-info" }, [
	      _c("div", { staticClass: "text-medium flex justify-between" }, [
	        _c("span", { attrs: { title: _vm.file.name } }, [
	          _vm.file.doc
	            ? _c(
	                "a",
	                { attrs: { href: _vm.file.doc.file_url, target: "_blank" } },
	                [
	                  _vm.file.doc.is_private
	                    ? _c("i", { staticClass: "fa fa-lock fa-fw text-warning" })
	                    : _c("i", {
	                        staticClass: "fa fa-unlock-alt fa-fw text-warning"
	                      }),
	                  _vm._v(
	                    "\n\t\t\t\t\t" +
	                      _vm._s(_vm._f("file_name")(_vm.file.name)) +
	                      "\n\t\t\t\t"
	                  )
	                ]
	              )
	            : _c("span", [
	                _c(
	                  "span",
	                  {
	                    staticClass: "cursor-pointer",
	                    attrs: { title: _vm.__("Toggle Public/Private") },
	                    on: {
	                      click: function($event) {
	                        return _vm.$emit("toggle_private")
	                      }
	                    }
	                  },
	                  [
	                    _vm.file.private
	                      ? _c("i", {
	                          staticClass: "fa fa-lock fa-fw text-warning"
	                        })
	                      : _c("i", {
	                          staticClass: "fa fa-unlock-alt fa-fw text-warning"
	                        })
	                  ]
	                ),
	                _vm._v(
	                  "\n\t\t\t\t\t" +
	                    _vm._s(_vm._f("file_name")(_vm.file.name)) +
	                    "\n\t\t\t\t"
	                )
	              ])
	        ]),
	        _vm._v(" "),
	        _vm.uploaded
	          ? _c("i", {
	              staticClass: "octicon octicon-check text-success",
	              attrs: { title: _vm.__("Uploaded successfully") }
	            })
	          : _vm._e(),
	        _vm._v(" "),
	        _vm.file.failed
	          ? _c("i", {
	              staticClass: "octicon octicon-x text-danger",
	              attrs: { title: _vm.__("Upload failed") }
	            })
	          : _vm._e()
	      ]),
	      _vm._v(" "),
	      _c("div", [
	        _c("span", { staticClass: "text-small text-muted" }, [
	          _vm._v(
	            "\n\t\t\t\t" +
	              _vm._s(_vm._f("file_size")(_vm.file.file_obj.size)) +
	              "\n\t\t\t"
	          )
	        ])
	      ])
	    ]),
	    _vm._v(" "),
	    !_vm.uploaded
	      ? _c(
	          "div",
	          {
	            staticClass: "file-remove",
	            on: {
	              click: function($event) {
	                return _vm.$emit("remove")
	              }
	            }
	          },
	          [
	            _c(
	              "svg",
	              {
	                staticClass: "feather feather-x",
	                attrs: {
	                  xmlns: "http://www.w3.org/2000/svg",
	                  width: "12",
	                  height: "12",
	                  viewBox: "0 0 24 24",
	                  fill: "none",
	                  stroke: "currentColor",
	                  "stroke-width": "2",
	                  "stroke-linecap": "round",
	                  "stroke-linejoin": "round"
	                }
	              },
	              [
	                _c("line", { attrs: { x1: "18", y1: "6", x2: "6", y2: "18" } }),
	                _c("line", { attrs: { x1: "6", y1: "6", x2: "18", y2: "18" } })
	              ]
	            )
	          ]
	        )
	      : _vm._e()
	  ])
	};
	var __vue_staticRenderFns__ = [];
	__vue_render__._withStripped = true;

	  /* style */
	  var __vue_inject_styles__ = function (inject) {
	    if (!inject) { return }
	    inject("data-v-2d66da67_0", { source: "/* palette colors*/\n.file-preview {\n  width: 25%;\n  padding-right: 15px;\n  padding-bottom: 15px;\n  position: relative;\n}\n.file-icon {\n  height: 10rem;\n  overflow: hidden;\n}\n.file-info {\n  margin-top: 5px;\n}\n.file-remove {\n  position: absolute;\n  top: -7px;\n  right: 7px;\n  background: #2e3338;\n  color: white;\n  padding: 3px;\n  border-radius: 50%;\n  display: flex;\n  cursor: pointer;\n}\n", map: {"version":3,"sources":["FilePreview.vue"],"names":[],"mappings":"AAAA,kBAAkB;AAClB;EACE,UAAU;EACV,mBAAmB;EACnB,oBAAoB;EACpB,kBAAkB;AACpB;AACA;EACE,aAAa;EACb,gBAAgB;AAClB;AACA;EACE,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,UAAU;EACV,mBAAmB;EACnB,YAAY;EACZ,YAAY;EACZ,kBAAkB;EAClB,aAAa;EACb,eAAe;AACjB","file":"FilePreview.vue","sourcesContent":["/* palette colors*/\n.file-preview {\n  width: 25%;\n  padding-right: 15px;\n  padding-bottom: 15px;\n  position: relative;\n}\n.file-icon {\n  height: 10rem;\n  overflow: hidden;\n}\n.file-info {\n  margin-top: 5px;\n}\n.file-remove {\n  position: absolute;\n  top: -7px;\n  right: 7px;\n  background: #2e3338;\n  color: white;\n  padding: 3px;\n  border-radius: 50%;\n  display: flex;\n  cursor: pointer;\n}\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__ = undefined;
	  /* module identifier */
	  var __vue_module_identifier__ = undefined;
	  /* functional template */
	  var __vue_is_functional_template__ = false;
	  /* component normalizer */
	  function __vue_normalize__(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/mieone/Downloads/frappe-practice/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/FilePreview.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var FilePreview = __vue_normalize__(
	    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
	    __vue_inject_styles__,
	    __vue_script__,
	    __vue_scope_id__,
	    __vue_is_functional_template__,
	    __vue_module_identifier__,
	    __vue_create_injector__,
	    undefined
	  );

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var script$1 = {
		name: 'TreeNode',
		props: ['node', 'selected_node'],
		components: {
			TreeNode: function () { return frappe.ui.components.TreeNode; }
		}
	};

	/* script */
	            var __vue_script__$1 = script$1;
	            
	/* template */
	var __vue_render__$1 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    {
	      directives: [
	        {
	          name: "show",
	          rawName: "v-show",
	          value: _vm.node.filtered,
	          expression: "node.filtered"
	        }
	      ],
	      staticClass: "tree-node",
	      class: { opened: _vm.node.open }
	    },
	    [
	      _c(
	        "span",
	        {
	          staticClass: "tree-link",
	          class: { active: _vm.node.value === _vm.selected_node.value },
	          attrs: { disabled: _vm.node.fetching },
	          on: {
	            click: function($event) {
	              return _vm.$emit("node-click", _vm.node)
	            }
	          }
	        },
	        [
	          _vm.node.is_leaf
	            ? _c("i", {
	                staticClass: "octicon octicon-primitive-dot node-leaf"
	              })
	            : _c("i", {
	                staticClass: "fa fa-fw node-parent",
	                class: [_vm.node.open ? "fa-folder-open" : "fa-folder"]
	              }),
	          _vm._v(" "),
	          _c("a", { staticClass: "tree-label grey h6" }, [
	            _vm._v(_vm._s(_vm.node.label))
	          ])
	        ]
	      ),
	      _vm._v(" "),
	      _c(
	        "ul",
	        {
	          directives: [
	            {
	              name: "show",
	              rawName: "v-show",
	              value: _vm.node.open,
	              expression: "node.open"
	            }
	          ],
	          staticClass: "tree-children"
	        },
	        _vm._l(_vm.node.children, function(n) {
	          return _c("TreeNode", {
	            key: n.value,
	            attrs: { node: n, selected_node: _vm.selected_node },
	            on: {
	              "node-click": function(n) {
	                return _vm.$emit("node-click", n)
	              }
	            }
	          })
	        }),
	        1
	      )
	    ]
	  )
	};
	var __vue_staticRenderFns__$1 = [];
	__vue_render__$1._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$1 = undefined;
	  /* scoped */
	  var __vue_scope_id__$1 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$1 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$1 = false;
	  /* component normalizer */
	  function __vue_normalize__$1(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/mieone/Downloads/frappe-practice/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/TreeNode.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    return component
	  }
	  /* style inject */
	  
	  /* style inject SSR */
	  

	  
	  var TreeNode = __vue_normalize__$1(
	    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
	    __vue_inject_styles__$1,
	    __vue_script__$1,
	    __vue_scope_id__$1,
	    __vue_is_functional_template__$1,
	    __vue_module_identifier__$1,
	    undefined,
	    undefined
	  );

	//

	var script$2 = {
		name: 'FileBrowser',
		components: {
			TreeNode: TreeNode
		},
		data: function data() {
			return {
				node: {
					label: __('Home'),
					value: 'Home',
					children: [],
					is_leaf: false,
					fetching: false,
					fetched: false,
					open: false,
					filtered: true
				},
				selected_node: {},
				filter_text: ''
			}
		},
		mounted: function mounted() {
			this.toggle_node(this.node);
		},
		methods: {
			toggle_node: function toggle_node(node) {
				if (!node.fetched && !node.is_leaf) {
					node.fetching = true;
					this.get_files_in_folder(node.value)
						.then(function (files) {
							node.open = true;
							node.children = files;
							node.fetched = true;
							node.fetching = false;
						});
				} else {
					node.open = !node.open;
					this.select_node(node);
				}
			},
			select_node: function select_node(node) {
				if (node.is_leaf) {
					this.selected_node = node;
				}
			},
			get_files_in_folder: function get_files_in_folder(folder) {
				return frappe.call('frappe.core.doctype.file.file.get_files_in_folder', { folder: folder })
					.then(function (r) {
						var files = r.message || [];
						files.sort(function (a, b) {
							if (a.is_folder && b.is_folder) {
								return a.modified < b.modified ? -1 : 1;
							}
							if (a.is_folder) {
								return -1;
							}
							if (b.is_folder) {
								return 1;
							}
							return 0;
						});
						return files.map(function (file) {
							var filename = file.file_name || file.name;
							return {
								label: frappe.utils.file_name_ellipsis(filename, 40),
								filename: filename,
								file_url: file.file_url,
								value: file.name,
								is_leaf: !file.is_folder,
								fetched: !file.is_folder, // fetched if node is leaf
								children: [],
								open: false,
								fetching: false,
								filtered: true
							}
						});
					});
			},
			apply_filter: frappe.utils.debounce(function() {
				var filter_text = this.filter_text.toLowerCase();
				var apply_filter = function (node) {
					var search_string = node.filename.toLowerCase();
					if (node.is_leaf) {
						node.filtered = search_string.includes(filter_text);
					} else {
						node.children.forEach(apply_filter);
					}
				};
				this.node.children.forEach(apply_filter);
			}, 300)
		}
	};

	/* script */
	            var __vue_script__$2 = script$2;
	            
	/* template */
	var __vue_render__$2 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", { staticClass: "file-browser" }, [
	    _c("div", [
	      _c(
	        "a",
	        {
	          staticClass: "text-muted text-medium",
	          attrs: { href: "" },
	          on: {
	            click: function($event) {
	              $event.preventDefault();
	              return _vm.$emit("hide-browser")
	            }
	          }
	        },
	        [_vm._v(_vm._s(_vm.__("← Back to upload files")))]
	      )
	    ]),
	    _vm._v(" "),
	    _c(
	      "div",
	      { staticClass: "file-browser-list border rounded" },
	      [
	        _c("div", { staticClass: "file-filter" }, [
	          _c("input", {
	            directives: [
	              {
	                name: "model",
	                rawName: "v-model",
	                value: _vm.filter_text,
	                expression: "filter_text"
	              }
	            ],
	            staticClass: "form-control input-xs",
	            attrs: {
	              type: "text",
	              placeholder: _vm.__("Search by filename or extension")
	            },
	            domProps: { value: _vm.filter_text },
	            on: {
	              input: [
	                function($event) {
	                  if ($event.target.composing) {
	                    return
	                  }
	                  _vm.filter_text = $event.target.value;
	                },
	                _vm.apply_filter
	              ]
	            }
	          })
	        ]),
	        _vm._v(" "),
	        _c("TreeNode", {
	          staticClass: "tree with-skeleton",
	          attrs: { node: _vm.node, selected_node: _vm.selected_node },
	          on: {
	            "node-click": function(n) {
	              return _vm.toggle_node(n)
	            }
	          }
	        })
	      ],
	      1
	    )
	  ])
	};
	var __vue_staticRenderFns__$2 = [];
	__vue_render__$2._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$2 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-f680713a_0", { source: "\n.file-browser-list {\n\theight: 300px;\n\toverflow: auto;\n\tmargin-top: 10px;\n}\n.file-filter {\n\tpadding: 15px 15px 0;\n}\n", map: {"version":3,"sources":["/home/mieone/Downloads/frappe-practice/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/FileBrowser.vue"],"names":[],"mappings":";AA8HA;CACA,aAAA;CACA,cAAA;CACA,gBAAA;AACA;AAEA;CACA,oBAAA;AACA","file":"FileBrowser.vue","sourcesContent":["<template>\n\t<div class=\"file-browser\">\n\t\t<div>\n\t\t\t<a\n\t\t\t\thref=\"\"\n\t\t\t\tclass=\"text-muted text-medium\"\n\t\t\t\t@click.prevent=\"$emit('hide-browser')\"\n\t\t\t>{{ __('← Back to upload files') }}</a>\n\t\t</div>\n\t\t<div class=\"file-browser-list border rounded\">\n\t\t\t<div class=\"file-filter\">\n\t\t\t\t<input\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tclass=\"form-control input-xs\"\n\t\t\t\t\t:placeholder=\"__('Search by filename or extension')\"\n\t\t\t\t\tv-model=\"filter_text\"\n\t\t\t\t\t@input=\"apply_filter\"\n\t\t\t\t>\n\t\t\t</div>\n\t\t\t<TreeNode\n\t\t\t\tclass=\"tree with-skeleton\"\n\t\t\t\t:node=\"node\"\n\t\t\t\t:selected_node=\"selected_node\"\n\t\t\t\t@node-click=\"n => toggle_node(n)\"\n\t\t\t/>\n\t\t</div>\n\t</div>\n</template>\n<script>\nimport TreeNode from \"./TreeNode.vue\";\n\nexport default {\n\tname: 'FileBrowser',\n\tcomponents: {\n\t\tTreeNode\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tnode: {\n\t\t\t\tlabel: __('Home'),\n\t\t\t\tvalue: 'Home',\n\t\t\t\tchildren: [],\n\t\t\t\tis_leaf: false,\n\t\t\t\tfetching: false,\n\t\t\t\tfetched: false,\n\t\t\t\topen: false,\n\t\t\t\tfiltered: true\n\t\t\t},\n\t\t\tselected_node: {},\n\t\t\tfilter_text: ''\n\t\t}\n\t},\n\tmounted() {\n\t\tthis.toggle_node(this.node);\n\t},\n\tmethods: {\n\t\ttoggle_node(node) {\n\t\t\tif (!node.fetched && !node.is_leaf) {\n\t\t\t\tnode.fetching = true;\n\t\t\t\tthis.get_files_in_folder(node.value)\n\t\t\t\t\t.then(files => {\n\t\t\t\t\t\tnode.open = true;\n\t\t\t\t\t\tnode.children = files;\n\t\t\t\t\t\tnode.fetched = true;\n\t\t\t\t\t\tnode.fetching = false;\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tnode.open = !node.open;\n\t\t\t\tthis.select_node(node);\n\t\t\t}\n\t\t},\n\t\tselect_node(node) {\n\t\t\tif (node.is_leaf) {\n\t\t\t\tthis.selected_node = node;\n\t\t\t}\n\t\t},\n\t\tget_files_in_folder(folder) {\n\t\t\treturn frappe.call('frappe.core.doctype.file.file.get_files_in_folder', { folder })\n\t\t\t\t.then(r => {\n\t\t\t\t\tlet files = r.message || [];\n\t\t\t\t\tfiles.sort((a, b) => {\n\t\t\t\t\t\tif (a.is_folder && b.is_folder) {\n\t\t\t\t\t\t\treturn a.modified < b.modified ? -1 : 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a.is_folder) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (b.is_folder) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t});\n\t\t\t\t\treturn files.map(file => {\n\t\t\t\t\t\tlet filename = file.file_name || file.name;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tlabel: frappe.utils.file_name_ellipsis(filename, 40),\n\t\t\t\t\t\t\tfilename: filename,\n\t\t\t\t\t\t\tfile_url: file.file_url,\n\t\t\t\t\t\t\tvalue: file.name,\n\t\t\t\t\t\t\tis_leaf: !file.is_folder,\n\t\t\t\t\t\t\tfetched: !file.is_folder, // fetched if node is leaf\n\t\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\t\topen: false,\n\t\t\t\t\t\t\tfetching: false,\n\t\t\t\t\t\t\tfiltered: true\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t},\n\t\tapply_filter: frappe.utils.debounce(function() {\n\t\t\tlet filter_text = this.filter_text.toLowerCase();\n\t\t\tlet apply_filter = (node) => {\n\t\t\t\tlet search_string = node.filename.toLowerCase();\n\t\t\t\tif (node.is_leaf) {\n\t\t\t\t\tnode.filtered = search_string.includes(filter_text);\n\t\t\t\t} else {\n\t\t\t\t\tnode.children.forEach(apply_filter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.node.children.forEach(apply_filter);\n\t\t}, 300)\n\t}\n}\n</script>\n\n<style>\n.file-browser-list {\n\theight: 300px;\n\toverflow: auto;\n\tmargin-top: 10px;\n}\n\n.file-filter {\n\tpadding: 15px 15px 0;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$2 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$2 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$2 = false;
	  /* component normalizer */
	  function __vue_normalize__$2(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/mieone/Downloads/frappe-practice/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/FileBrowser.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$1() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var FileBrowser = __vue_normalize__$2(
	    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
	    __vue_inject_styles__$2,
	    __vue_script__$2,
	    __vue_scope_id__$2,
	    __vue_is_functional_template__$2,
	    __vue_module_identifier__$2,
	    __vue_create_injector__$1,
	    undefined
	  );

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var script$3 = {
		name: 'WebLink',
		data: function data() {
			return {
				url: '',
			}
		}
	};

	/* script */
	            var __vue_script__$3 = script$3;
	            
	/* template */
	var __vue_render__$3 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", { staticClass: "file-web-link margin-bottom" }, [
	    _c(
	      "a",
	      {
	        staticClass: "text-muted text-medium",
	        attrs: { href: "" },
	        on: {
	          click: function($event) {
	            $event.preventDefault();
	            return _vm.$emit("hide-web-link")
	          }
	        }
	      },
	      [_vm._v("\n\t\t" + _vm._s(_vm.__("← Back to upload files")) + "\n\t")]
	    ),
	    _vm._v(" "),
	    _c("div", { staticClass: "input-group" }, [
	      _c("div", { staticClass: "input-group-addon" }, [
	        _c("span", { staticClass: "text-muted text-medium" }, [
	          _vm._v(_vm._s(_vm.__("Web Link")))
	        ])
	      ]),
	      _vm._v(" "),
	      _c("input", {
	        directives: [
	          {
	            name: "model",
	            rawName: "v-model",
	            value: _vm.url,
	            expression: "url"
	          }
	        ],
	        staticClass: "form-control",
	        attrs: { type: "text", placeholder: _vm.__("Attach a web link") },
	        domProps: { value: _vm.url },
	        on: {
	          input: function($event) {
	            if ($event.target.composing) {
	              return
	            }
	            _vm.url = $event.target.value;
	          }
	        }
	      })
	    ])
	  ])
	};
	var __vue_staticRenderFns__$3 = [];
	__vue_render__$3._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$3 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-3e4189d9_0", { source: "\n.file-web-link .input-group {\n\tmargin-top: 10px;\n}\n", map: {"version":3,"sources":["/home/mieone/Downloads/frappe-practice/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/WebLink.vue"],"names":[],"mappings":";AAgCA;CACA,gBAAA;AACA","file":"WebLink.vue","sourcesContent":["<template>\n\t<div class=\"file-web-link margin-bottom\">\n\t\t<a href class=\"text-muted text-medium\"\n\t\t\t@click.prevent=\"$emit('hide-web-link')\"\n\t\t>\n\t\t\t{{ __('← Back to upload files') }}\n\t\t</a>\n\t\t<div class=\"input-group\">\n\t\t\t<div class=\"input-group-addon\">\n\t\t\t\t<span class=\"text-muted text-medium\">{{ __('Web Link') }}</span>\n\t\t\t</div>\n\t\t\t<input\n\t\t\t\ttype=\"text\"\n\t\t\t\tclass=\"form-control\"\n\t\t\t\t:placeholder=\"__('Attach a web link')\"\n\t\t\t\tv-model=\"url\"\n\t\t\t>\n\t\t</div>\n\t</div>\n</template>\n<script>\nexport default {\n\tname: 'WebLink',\n\tdata() {\n\t\treturn {\n\t\t\turl: '',\n\t\t}\n\t}\n}\n</script>\n\n<style>\n.file-web-link .input-group {\n\tmargin-top: 10px;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$3 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$3 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$3 = false;
	  /* component normalizer */
	  function __vue_normalize__$3(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/mieone/Downloads/frappe-practice/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/WebLink.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$2() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var WebLink = __vue_normalize__$3(
	    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
	    __vue_inject_styles__$3,
	    __vue_script__$3,
	    __vue_scope_id__$3,
	    __vue_is_functional_template__$3,
	    __vue_module_identifier__$3,
	    __vue_create_injector__$2,
	    undefined
	  );

	//

	var script$4 = {
		name: 'FileUploader',
		props: {
			show_upload_button: {
				default: true
			},
			disable_file_browser: {
				default: false
			},
			allow_multiple: {
				default: true
			},
			as_dataurl: {
				default: false
			},
			doctype: {
				default: null
			},
			docname: {
				default: null
			},
			fieldname: {
				default: null
			},
			folder: {
				default: 'Home'
			},
			method: {
				default: null
			},
			on_success: {
				default: null
			},
			restrictions: {
				default: function () { return ({
					max_file_size: null, // 2048 -> 2KB
					max_number_of_files: null,
					allowed_file_types: [] // ['image/*', 'video/*', '.jpg', '.gif', '.pdf']
				}); }
			},
			upload_notes: {
				default: null // "Images or video, upto 2MB"
			}
		},
		components: {
			FilePreview: FilePreview,
			FileBrowser: FileBrowser,
			WebLink: WebLink
		},
		data: function data() {
			return {
				files: [],
				is_dragging: false,
				currently_uploading: -1,
				show_file_browser: false,
				show_web_link: false,
			}
		},
		watch: {
			files: function files(newvalue, oldvalue) {
				if (!this.allow_multiple && newvalue.length > 1) {
					this.files = [newvalue[newvalue.length - 1]];
				}
			}
		},
		computed: {
			upload_complete: function upload_complete() {
				return this.files.length > 0
					&& this.files.every(
						function (file) { return file.total !== 0 && file.progress === file.total; });
			}
		},
		methods: {
			dragover: function dragover() {
				this.is_dragging = true;
			},
			dragleave: function dragleave() {
				this.is_dragging = false;
			},
			dropfiles: function dropfiles(e) {
				this.is_dragging = false;
				this.add_files(e.dataTransfer.files);
			},
			browse_files: function browse_files() {
				this.$refs.file_input.click();
			},
			on_file_input: function on_file_input(e) {
				this.add_files(this.$refs.file_input.files);
			},
			remove_file: function remove_file(i) {
				this.files = this.files.filter(function (file, j) { return i !== j; });
			},
			toggle_private: function toggle_private(i) {
				this.files[i].private = !this.files[i].private;
			},
			toggle_all_private: function toggle_all_private(flag) {
				this.files = this.files.map(function (file) {
					file.private = flag;
					return file;
				});
			},
			add_files: function add_files(file_array) {
				var files = Array.from(file_array)
					.filter(this.check_restrictions)
					.map(function (file) {
						var is_image = file.type.startsWith('image');
						return {
							file_obj: file,
							name: file.name,
							doc: null,
							progress: 0,
							total: 0,
							failed: false,
							uploading: false,
							private: !is_image
						}
					});
				this.files = this.files.concat(files);
			},
			check_restrictions: function check_restrictions(file) {
				var ref = this.restrictions;
				var max_file_size = ref.max_file_size;
				var allowed_file_types = ref.allowed_file_types;

				var mime_type = file.type;
				var extension = '.' + file.name.split('.').pop();

				var is_correct_type = true;
				var valid_file_size = true;

				if (allowed_file_types.length) {
					is_correct_type = allowed_file_types.some(function (type) {
						// is this is a mime-type
						if (type.includes('/')) {
							if (!file.type) { return false; }
							return file.type.match(type);
						}

						// otherwise this is likely an extension
						if (type[0] === '.') {
							return file.name.endsWith(type);
						}
						return false;
					});
				}

				if (max_file_size && file.size != null) {
					valid_file_size = file.size < max_file_size;
				}

				if (!is_correct_type) {
					console.warn('File skipped because of invalid file type', file);
				}
				if (!valid_file_size) {
					console.warn('File skipped because of invalid file size', file.size, file);
				}

				return is_correct_type && valid_file_size;
			},
			upload_files: function upload_files() {
				var this$1 = this;

				if (this.show_file_browser) {
					return this.upload_via_file_browser();
				}
				if (this.show_web_link) {
					return this.upload_via_web_link();
				}
				if (this.as_dataurl) {
					return this.return_as_dataurl();
				}
				return frappe.run_serially(
					this.files.map(
						function (file, i) { return function () { return this$1.upload_file(file, i); }; }
					)
				);
			},
			upload_via_file_browser: function upload_via_file_browser() {
				var selected_file = this.$refs.file_browser.selected_node;
				if (!selected_file.value) {
					frappe.msgprint(__('Click on a file to select it.'));
					return Promise.reject();
				}

				return this.upload_file({
					file_url: selected_file.file_url
				});
			},
			upload_via_web_link: function upload_via_web_link() {
				var file_url = this.$refs.web_link.url;
				if (!file_url) {
					frappe.msgprint(__('Invalid URL'));
					return Promise.reject();
				}

				return this.upload_file({
					file_url: file_url
				});
			},
			return_as_dataurl: function return_as_dataurl() {
				var this$1 = this;

				var promises = this.files.map(function (file) { return frappe.dom.file_to_base64(file.file_obj)
						.then(function (dataurl) {
							file.dataurl = dataurl;
							this$1.on_success && this$1.on_success(file);
						}); }
				);
				return Promise.all(promises);
			},
			upload_file: function upload_file(file, i) {
				var this$1 = this;

				this.currently_uploading = i;

				return new Promise(function (resolve, reject) {
					var xhr = new XMLHttpRequest();
					xhr.upload.addEventListener('loadstart', function (e) {
						file.uploading = true;
					});
					xhr.upload.addEventListener('progress', function (e) {
						if (e.lengthComputable) {
							file.progress = e.loaded;
							file.total = e.total;
						}
					});
					xhr.upload.addEventListener('load', function (e) {
						file.uploading = false;
						resolve();
					});
					xhr.addEventListener('error', function (e) {
						file.failed = true;
						reject();
					});
					xhr.onreadystatechange = function () {
						if (xhr.readyState == XMLHttpRequest.DONE) {
							if (xhr.status === 200) {
								var r = null;
								var file_doc = null;
								try {
									r = JSON.parse(xhr.responseText);
									if (r.message.doctype === 'File') {
										file_doc = r.message;
									}
								} catch(e) {
									r = xhr.responseText;
								}

								file.doc = file_doc;

								if (this$1.on_success) {
									this$1.on_success(file_doc, r);
								}
							} else if (xhr.status === 403) {
								var response = JSON.parse(xhr.responseText);
								frappe.msgprint({
									title: __('Not permitted'),
									indicator: 'red',
									message: response._error_message
								});
							} else {
								file.failed = true;
								var error = null;
								try {
									error = JSON.parse(xhr.responseText);
								} catch(e) {
									// pass
								}
								frappe.request.cleanup({}, error);
							}
						}
					};
					xhr.open('POST', '/api/method/upload_file', true);
					xhr.setRequestHeader('Accept', 'application/json');
					xhr.setRequestHeader('X-Frappe-CSRF-Token', frappe.csrf_token);

					var form_data = new FormData();
					if (file.file_obj) {
						form_data.append('file', file.file_obj, file.name);
					}
					form_data.append('is_private', +file.private);
					form_data.append('folder', this$1.folder);

					if (file.file_url) {
						form_data.append('file_url', file.file_url);
					}

					if (this$1.doctype && this$1.docname) {
						form_data.append('doctype', this$1.doctype);
						form_data.append('docname', this$1.docname);
					}

					if (this$1.fieldname) {
						form_data.append('fieldname', this$1.fieldname);
					}

					if (this$1.method) {
						form_data.append('method', this$1.method);
					}

					xhr.send(form_data);
				});
			}
		}
	};

	/* script */
	            var __vue_script__$4 = script$4;
	            
	/* template */
	var __vue_render__$4 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    {
	      staticClass: "file-uploader",
	      on: {
	        dragover: function($event) {
	          $event.preventDefault();
	          return _vm.dragover($event)
	        },
	        dragleave: function($event) {
	          $event.preventDefault();
	          return _vm.dragleave($event)
	        },
	        drop: function($event) {
	          $event.preventDefault();
	          return _vm.dropfiles($event)
	        }
	      }
	    },
	    [
	      _c(
	        "div",
	        {
	          directives: [
	            {
	              name: "show",
	              rawName: "v-show",
	              value:
	                _vm.files.length === 0 &&
	                !_vm.show_file_browser &&
	                !_vm.show_web_link,
	              expression:
	                "files.length === 0 && !show_file_browser && !show_web_link"
	            }
	          ],
	          staticClass:
	            "file-upload-area padding border rounded text-center cursor-pointer flex align-center justify-center",
	          on: { click: _vm.browse_files }
	        },
	        [
	          !_vm.is_dragging
	            ? _c("div", [
	                _c("div", [
	                  _vm._v(
	                    "\n\t\t\t\t" +
	                      _vm._s(_vm.__("Drag and drop files, ")) +
	                      "\n\t\t\t\t"
	                  ),
	                  _c("label", { staticStyle: { margin: "0" } }, [
	                    _c(
	                      "a",
	                      {
	                        staticClass: "text-primary",
	                        attrs: { href: "#" },
	                        on: {
	                          click: function($event) {
	                            $event.preventDefault();
	                          }
	                        }
	                      },
	                      [_vm._v(_vm._s(_vm.__("browse,")))]
	                    ),
	                    _vm._v(" "),
	                    _c("input", {
	                      ref: "file_input",
	                      staticClass: "hidden",
	                      attrs: {
	                        type: "file",
	                        multiple: _vm.allow_multiple,
	                        accept: _vm.restrictions.allowed_file_types.join(", ")
	                      },
	                      on: { change: _vm.on_file_input }
	                    })
	                  ]),
	                  _vm._v(" "),
	                  !_vm.disable_file_browser
	                    ? _c("span", [
	                        _vm._v(
	                          "\n\t\t\t\t\t" +
	                            _vm._s(_vm.__("choose an")) +
	                            "\n\t\t\t\t\t"
	                        ),
	                        _c(
	                          "a",
	                          {
	                            staticClass: "text-primary bold",
	                            attrs: { href: "#" },
	                            on: {
	                              click: function($event) {
	                                $event.stopPropagation();
	                                $event.preventDefault();
	                                _vm.show_file_browser = true;
	                              }
	                            }
	                          },
	                          [
	                            _vm._v(
	                              "\n\t\t\t\t\t\t" +
	                                _vm._s(_vm.__("uploaded file")) +
	                                "\n\t\t\t\t\t"
	                            )
	                          ]
	                        )
	                      ])
	                    : _vm._e(),
	                  _vm._v(
	                    "\n\t\t\t\t" + _vm._s(_vm.__("or attach a")) + "\n\t\t\t\t"
	                  ),
	                  _c(
	                    "a",
	                    {
	                      staticClass: "text-primary bold",
	                      attrs: { href: "" },
	                      on: {
	                        click: function($event) {
	                          $event.stopPropagation();
	                          $event.preventDefault();
	                          _vm.show_web_link = true;
	                        }
	                      }
	                    },
	                    [
	                      _vm._v(
	                        "\n\t\t\t\t\t" +
	                          _vm._s(_vm.__("web link")) +
	                          "\n\t\t\t\t"
	                      )
	                    ]
	                  )
	                ]),
	                _vm._v(" "),
	                _c("div", { staticClass: "text-muted text-medium" }, [
	                  _vm._v("\n\t\t\t\t" + _vm._s(_vm.upload_notes) + "\n\t\t\t")
	                ])
	              ])
	            : _c("div", [
	                _vm._v(
	                  "\n\t\t\t" + _vm._s(_vm.__("Drop files here")) + "\n\t\t"
	                )
	              ])
	        ]
	      ),
	      _vm._v(" "),
	      _c(
	        "div",
	        {
	          directives: [
	            {
	              name: "show",
	              rawName: "v-show",
	              value:
	                _vm.files.length &&
	                !_vm.show_file_browser &&
	                !_vm.show_web_link,
	              expression: "files.length && !show_file_browser && !show_web_link"
	            }
	          ],
	          staticClass: "file-preview-area"
	        },
	        [
	          !_vm.upload_complete
	            ? _c("div", { staticClass: "margin-bottom" }, [
	                _c("label", [
	                  _c("input", {
	                    staticClass: "input-with-feedback",
	                    attrs: { type: "checkbox" },
	                    on: {
	                      change: function(e) {
	                        return _vm.toggle_all_private(e.target.checked)
	                      }
	                    }
	                  }),
	                  _vm._v(" "),
	                  _c(
	                    "span",
	                    {
	                      staticClass: "text-medium",
	                      staticStyle: { "font-weight": "normal" }
	                    },
	                    [
	                      _vm._v(
	                        "\n\t\t\t\t\t" +
	                          _vm._s(_vm.__("Make all attachments private")) +
	                          "\n\t\t\t\t"
	                      )
	                    ]
	                  )
	                ])
	              ])
	            : _vm._e(),
	          _vm._v(" "),
	          _c(
	            "div",
	            { staticClass: "flex flex-wrap" },
	            _vm._l(_vm.files, function(file, i) {
	              return _c("FilePreview", {
	                key: file.name,
	                attrs: { file: file },
	                on: {
	                  remove: function($event) {
	                    return _vm.remove_file(i)
	                  },
	                  toggle_private: function($event) {
	                    return _vm.toggle_private(i)
	                  }
	                }
	              })
	            }),
	            1
	          ),
	          _vm._v(" "),
	          _vm.show_upload_button && _vm.currently_uploading === -1
	            ? _c("div", { staticClass: "flex align-center" }, [
	                _c(
	                  "button",
	                  {
	                    staticClass: "btn btn-primary btn-sm margin-right",
	                    on: { click: _vm.upload_files }
	                  },
	                  [
	                    _vm.files.length === 1
	                      ? _c("span", [
	                          _vm._v(
	                            "\n\t\t\t\t\t" +
	                              _vm._s(_vm.__("Upload file")) +
	                              "\n\t\t\t\t"
	                          )
	                        ])
	                      : _c("span", [
	                          _vm._v(
	                            "\n\t\t\t\t\t" +
	                              _vm._s(
	                                _vm.__("Upload {0} files", [_vm.files.length])
	                              ) +
	                              "\n\t\t\t\t"
	                          )
	                        ])
	                  ]
	                ),
	                _vm._v(" "),
	                _c("div", { staticClass: "text-muted text-medium" }, [
	                  _vm._v(
	                    "\n\t\t\t\t" +
	                      _vm._s(
	                        _vm.__(
	                          "Click on the lock icon to toggle public/private"
	                        )
	                      ) +
	                      "\n\t\t\t"
	                  )
	                ])
	              ])
	            : _vm._e()
	        ]
	      ),
	      _vm._v(" "),
	      _vm.currently_uploading !== -1 &&
	      !_vm.upload_complete &&
	      !_vm.show_file_browser &&
	      !_vm.show_web_link
	        ? _c(
	            "div",
	            { staticClass: "upload-progress" },
	            [
	              _c("span", {
	                staticClass: "text-medium",
	                domProps: {
	                  innerHTML: _vm._s(
	                    _vm.__("Uploading {0} of {1}", [
	                      String(_vm.currently_uploading + 1).bold(),
	                      String(_vm.files.length).bold()
	                    ])
	                  )
	                }
	              }),
	              _vm._v(" "),
	              _vm._l(_vm.files, function(file, i) {
	                return _c(
	                  "div",
	                  {
	                    directives: [
	                      {
	                        name: "show",
	                        rawName: "v-show",
	                        value: _vm.currently_uploading === i,
	                        expression: "currently_uploading===i"
	                      }
	                    ],
	                    key: i,
	                    staticClass: "progress"
	                  },
	                  [
	                    _c("div", {
	                      staticClass: "progress-bar",
	                      class: [
	                        file.total - file.progress < 20
	                          ? "progress-bar-success"
	                          : "progress-bar-warning"
	                      ],
	                      style: {
	                        width: (file.progress * 100) / file.total + "%"
	                      },
	                      attrs: {
	                        role: "progressbar",
	                        "aria-valuenow": (file.progress * 100) / file.total,
	                        "aria-valuemin": "0",
	                        "aria-valuemax": "100"
	                      }
	                    })
	                  ]
	                )
	              })
	            ],
	            2
	          )
	        : _vm._e(),
	      _vm._v(" "),
	      _vm.show_file_browser && !_vm.disable_file_browser
	        ? _c("FileBrowser", {
	            ref: "file_browser",
	            on: {
	              "hide-browser": function($event) {
	                _vm.show_file_browser = false;
	              }
	            }
	          })
	        : _vm._e(),
	      _vm._v(" "),
	      _vm.show_web_link
	        ? _c("WebLink", {
	            ref: "web_link",
	            on: {
	              "hide-web-link": function($event) {
	                _vm.show_web_link = false;
	              }
	            }
	          })
	        : _vm._e()
	    ],
	    1
	  )
	};
	var __vue_staticRenderFns__$4 = [];
	__vue_render__$4._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$4 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-353b3a17_0", { source: "\n.file-upload-area {\n\tmin-height: 100px;\n}\n", map: {"version":3,"sources":["/home/mieone/Downloads/frappe-practice/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/FileUploader.vue"],"names":[],"mappings":";AA0aA;CACA,iBAAA;AACA","file":"FileUploader.vue","sourcesContent":["<template>\n\t<div class=\"file-uploader\"\n\t\t@dragover.prevent=\"dragover\"\n\t\t@dragleave.prevent=\"dragleave\"\n\t\t@drop.prevent=\"dropfiles\"\n\t>\n\t\t<div\n\t\t\tclass=\"file-upload-area padding border rounded text-center cursor-pointer flex align-center justify-center\"\n\t\t\t@click=\"browse_files\"\n\t\t\tv-show=\"files.length === 0 && !show_file_browser && !show_web_link\"\n\t\t>\n\t\t\t<div v-if=\"!is_dragging\">\n\t\t\t\t<div>\n\t\t\t\t\t{{ __('Drag and drop files, ') }}\n\t\t\t\t\t<label style=\"margin: 0\">\n\t\t\t\t\t\t<a href=\"#\" class=\"text-primary\" @click.prevent>{{ __('browse,') }}</a>\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\ttype=\"file\"\n\t\t\t\t\t\t\tclass=\"hidden\"\n\t\t\t\t\t\t\tref=\"file_input\"\n\t\t\t\t\t\t\t@change=\"on_file_input\"\n\t\t\t\t\t\t\t:multiple=\"allow_multiple\"\n\t\t\t\t\t\t\t:accept=\"restrictions.allowed_file_types.join(', ')\"\n\t\t\t\t\t\t>\n\t\t\t\t\t</label>\n\t\t\t\t\t<span v-if=\"!disable_file_browser\">\n\t\t\t\t\t\t{{ __('choose an') }}\n\t\t\t\t\t\t<a href=\"#\" class=\"text-primary bold\"\n\t\t\t\t\t\t\t@click.stop.prevent=\"show_file_browser = true\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{{ __('uploaded file') }}\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</span>\n\t\t\t\t\t{{ __('or attach a') }}\n\t\t\t\t\t<a class=\"text-primary bold\" href\n\t\t\t\t\t\t@click.stop.prevent=\"show_web_link = true\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{{ __('web link') }}\n\t\t\t\t\t</a>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"text-muted text-medium\">\n\t\t\t\t\t{{ upload_notes }}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div v-else>\n\t\t\t\t{{ __('Drop files here') }}\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"file-preview-area\" v-show=\"files.length && !show_file_browser && !show_web_link\">\n\t\t\t<div class=\"margin-bottom\" v-if=\"!upload_complete\">\n\t\t\t\t<label>\n\t\t\t\t\t<input type=\"checkbox\" class=\"input-with-feedback\" @change=\"e => toggle_all_private(e.target.checked)\">\n\t\t\t\t\t<span class=\"text-medium\" style=\"font-weight: normal;\">\n\t\t\t\t\t\t{{ __('Make all attachments private') }}\n\t\t\t\t\t</span>\n\t\t\t\t</label>\n\t\t\t</div>\n\t\t\t<div class=\"flex flex-wrap\">\n\t\t\t\t<FilePreview\n\t\t\t\t\tv-for=\"(file, i) in files\"\n\t\t\t\t\t:key=\"file.name\"\n\t\t\t\t\t:file=\"file\"\n\t\t\t\t\t@remove=\"remove_file(i)\"\n\t\t\t\t\t@toggle_private=\"toggle_private(i)\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t\t<div class=\"flex align-center\" v-if=\"show_upload_button && currently_uploading === -1\">\n\t\t\t\t<button\n\t\t\t\t\tclass=\"btn btn-primary btn-sm margin-right\"\n\t\t\t\t\t@click=\"upload_files\"\n\t\t\t\t>\n\t\t\t\t\t<span v-if=\"files.length === 1\">\n\t\t\t\t\t\t{{ __('Upload file') }}\n\t\t\t\t\t</span>\n\t\t\t\t\t<span v-else>\n\t\t\t\t\t\t{{ __('Upload {0} files', [files.length]) }}\n\t\t\t\t\t</span>\n\t\t\t\t</button>\n\t\t\t\t<div class=\"text-muted text-medium\">\n\t\t\t\t\t{{ __('Click on the lock icon to toggle public/private') }}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"upload-progress\" v-if=\"currently_uploading !== -1 && !upload_complete && !show_file_browser && !show_web_link\">\n\t\t\t<span\n\t\t\t\tclass=\"text-medium\"\n\t\t\t\tv-html=\"__('Uploading {0} of {1}', [String(currently_uploading + 1).bold(), String(files.length).bold()])\"\n\t\t\t>\n\t\t\t</span>\n\t\t\t<div\n\t\t\t\tclass=\"progress\"\n\t\t\t\t:key=\"i\"\n\t\t\t\tv-for=\"(file, i) in files\"\n\t\t\t\tv-show=\"currently_uploading===i\"\n\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\tclass=\"progress-bar\"\n\t\t\t\t\t:class=\"[file.total - file.progress < 20 ? 'progress-bar-success' : 'progress-bar-warning']\"\n\t\t\t\t\trole=\"progressbar\"\n\t\t\t\t\t:aria-valuenow=\"(file.progress * 100 / file.total)\"\n\t\t\t\t\taria-valuemin=\"0\"\n\t\t\t\t\taria-valuemax=\"100\"\n\t\t\t\t\t:style=\"{'width': (file.progress * 100 / file.total) + '%' }\"\n\t\t\t\t>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<FileBrowser\n\t\t\tref=\"file_browser\"\n\t\t\tv-if=\"show_file_browser && !disable_file_browser\"\n\t\t\t@hide-browser=\"show_file_browser = false\"\n\t\t/>\n\t\t<WebLink\n\t\t\tref=\"web_link\"\n\t\t\tv-if=\"show_web_link\"\n\t\t\t@hide-web-link=\"show_web_link = false\"\n\t\t/>\n\t</div>\n</template>\n\n<script>\nimport FilePreview from './FilePreview.vue';\nimport FileBrowser from './FileBrowser.vue';\nimport WebLink from './WebLink.vue';\n\nexport default {\n\tname: 'FileUploader',\n\tprops: {\n\t\tshow_upload_button: {\n\t\t\tdefault: true\n\t\t},\n\t\tdisable_file_browser: {\n\t\t\tdefault: false\n\t\t},\n\t\tallow_multiple: {\n\t\t\tdefault: true\n\t\t},\n\t\tas_dataurl: {\n\t\t\tdefault: false\n\t\t},\n\t\tdoctype: {\n\t\t\tdefault: null\n\t\t},\n\t\tdocname: {\n\t\t\tdefault: null\n\t\t},\n\t\tfieldname: {\n\t\t\tdefault: null\n\t\t},\n\t\tfolder: {\n\t\t\tdefault: 'Home'\n\t\t},\n\t\tmethod: {\n\t\t\tdefault: null\n\t\t},\n\t\ton_success: {\n\t\t\tdefault: null\n\t\t},\n\t\trestrictions: {\n\t\t\tdefault: () => ({\n\t\t\t\tmax_file_size: null, // 2048 -> 2KB\n\t\t\t\tmax_number_of_files: null,\n\t\t\t\tallowed_file_types: [] // ['image/*', 'video/*', '.jpg', '.gif', '.pdf']\n\t\t\t})\n\t\t},\n\t\tupload_notes: {\n\t\t\tdefault: null // \"Images or video, upto 2MB\"\n\t\t}\n\t},\n\tcomponents: {\n\t\tFilePreview,\n\t\tFileBrowser,\n\t\tWebLink\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tfiles: [],\n\t\t\tis_dragging: false,\n\t\t\tcurrently_uploading: -1,\n\t\t\tshow_file_browser: false,\n\t\t\tshow_web_link: false,\n\t\t}\n\t},\n\twatch: {\n\t\tfiles(newvalue, oldvalue) {\n\t\t\tif (!this.allow_multiple && newvalue.length > 1) {\n\t\t\t\tthis.files = [newvalue[newvalue.length - 1]];\n\t\t\t}\n\t\t}\n\t},\n\tcomputed: {\n\t\tupload_complete() {\n\t\t\treturn this.files.length > 0\n\t\t\t\t&& this.files.every(\n\t\t\t\t\tfile => file.total !== 0 && file.progress === file.total);\n\t\t}\n\t},\n\tmethods: {\n\t\tdragover() {\n\t\t\tthis.is_dragging = true;\n\t\t},\n\t\tdragleave() {\n\t\t\tthis.is_dragging = false;\n\t\t},\n\t\tdropfiles(e) {\n\t\t\tthis.is_dragging = false;\n\t\t\tthis.add_files(e.dataTransfer.files);\n\t\t},\n\t\tbrowse_files() {\n\t\t\tthis.$refs.file_input.click();\n\t\t},\n\t\ton_file_input(e) {\n\t\t\tthis.add_files(this.$refs.file_input.files);\n\t\t},\n\t\tremove_file(i) {\n\t\t\tthis.files = this.files.filter((file, j) => i !== j);\n\t\t},\n\t\ttoggle_private(i) {\n\t\t\tthis.files[i].private = !this.files[i].private;\n\t\t},\n\t\ttoggle_all_private(flag) {\n\t\t\tthis.files = this.files.map(file => {\n\t\t\t\tfile.private = flag;\n\t\t\t\treturn file;\n\t\t\t});\n\t\t},\n\t\tadd_files(file_array) {\n\t\t\tlet files = Array.from(file_array)\n\t\t\t\t.filter(this.check_restrictions)\n\t\t\t\t.map(file => {\n\t\t\t\t\tlet is_image = file.type.startsWith('image');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfile_obj: file,\n\t\t\t\t\t\tname: file.name,\n\t\t\t\t\t\tdoc: null,\n\t\t\t\t\t\tprogress: 0,\n\t\t\t\t\t\ttotal: 0,\n\t\t\t\t\t\tfailed: false,\n\t\t\t\t\t\tuploading: false,\n\t\t\t\t\t\tprivate: !is_image\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tthis.files = this.files.concat(files);\n\t\t},\n\t\tcheck_restrictions(file) {\n\t\t\tlet { max_file_size, allowed_file_types } = this.restrictions;\n\n\t\t\tlet mime_type = file.type;\n\t\t\tlet extension = '.' + file.name.split('.').pop();\n\n\t\t\tlet is_correct_type = true;\n\t\t\tlet valid_file_size = true;\n\n\t\t\tif (allowed_file_types.length) {\n\t\t\t\tis_correct_type = allowed_file_types.some((type) => {\n\t\t\t\t\t// is this is a mime-type\n\t\t\t\t\tif (type.includes('/')) {\n\t\t\t\t\t\tif (!file.type) return false;\n\t\t\t\t\t\treturn file.type.match(type);\n\t\t\t\t\t}\n\n\t\t\t\t\t// otherwise this is likely an extension\n\t\t\t\t\tif (type[0] === '.') {\n\t\t\t\t\t\treturn file.name.endsWith(type);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (max_file_size && file.size != null) {\n\t\t\t\tvalid_file_size = file.size < max_file_size;\n\t\t\t}\n\n\t\t\tif (!is_correct_type) {\n\t\t\t\tconsole.warn('File skipped because of invalid file type', file);\n\t\t\t}\n\t\t\tif (!valid_file_size) {\n\t\t\t\tconsole.warn('File skipped because of invalid file size', file.size, file);\n\t\t\t}\n\n\t\t\treturn is_correct_type && valid_file_size;\n\t\t},\n\t\tupload_files() {\n\t\t\tif (this.show_file_browser) {\n\t\t\t\treturn this.upload_via_file_browser();\n\t\t\t}\n\t\t\tif (this.show_web_link) {\n\t\t\t\treturn this.upload_via_web_link();\n\t\t\t}\n\t\t\tif (this.as_dataurl) {\n\t\t\t\treturn this.return_as_dataurl();\n\t\t\t}\n\t\t\treturn frappe.run_serially(\n\t\t\t\tthis.files.map(\n\t\t\t\t\t(file, i) =>\n\t\t\t\t\t\t() => this.upload_file(file, i)\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\tupload_via_file_browser() {\n\t\t\tlet selected_file = this.$refs.file_browser.selected_node;\n\t\t\tif (!selected_file.value) {\n\t\t\t\tfrappe.msgprint(__('Click on a file to select it.'));\n\t\t\t\treturn Promise.reject();\n\t\t\t}\n\n\t\t\treturn this.upload_file({\n\t\t\t\tfile_url: selected_file.file_url\n\t\t\t});\n\t\t},\n\t\tupload_via_web_link() {\n\t\t\tlet file_url = this.$refs.web_link.url;\n\t\t\tif (!file_url) {\n\t\t\t\tfrappe.msgprint(__('Invalid URL'));\n\t\t\t\treturn Promise.reject();\n\t\t\t}\n\n\t\t\treturn this.upload_file({\n\t\t\t\tfile_url\n\t\t\t});\n\t\t},\n\t\treturn_as_dataurl() {\n\t\t\tlet promises = this.files.map(file =>\n\t\t\t\tfrappe.dom.file_to_base64(file.file_obj)\n\t\t\t\t\t.then(dataurl => {\n\t\t\t\t\t\tfile.dataurl = dataurl;\n\t\t\t\t\t\tthis.on_success && this.on_success(file);\n\t\t\t\t\t})\n\t\t\t);\n\t\t\treturn Promise.all(promises);\n\t\t},\n\t\tupload_file(file, i) {\n\t\t\tthis.currently_uploading = i;\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tlet xhr = new XMLHttpRequest();\n\t\t\t\txhr.upload.addEventListener('loadstart', (e) => {\n\t\t\t\t\tfile.uploading = true;\n\t\t\t\t})\n\t\t\t\txhr.upload.addEventListener('progress', (e) => {\n\t\t\t\t\tif (e.lengthComputable) {\n\t\t\t\t\t\tfile.progress = e.loaded;\n\t\t\t\t\t\tfile.total = e.total;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\txhr.upload.addEventListener('load', (e) => {\n\t\t\t\t\tfile.uploading = false;\n\t\t\t\t\tresolve();\n\t\t\t\t})\n\t\t\t\txhr.addEventListener('error', (e) => {\n\t\t\t\t\tfile.failed = true;\n\t\t\t\t\treject();\n\t\t\t\t})\n\t\t\t\txhr.onreadystatechange = () => {\n\t\t\t\t\tif (xhr.readyState == XMLHttpRequest.DONE) {\n\t\t\t\t\t\tif (xhr.status === 200) {\n\t\t\t\t\t\t\tlet r = null;\n\t\t\t\t\t\t\tlet file_doc = null;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tr = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t\t\tif (r.message.doctype === 'File') {\n\t\t\t\t\t\t\t\t\tfile_doc = r.message;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\t\tr = xhr.responseText;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfile.doc = file_doc;\n\n\t\t\t\t\t\t\tif (this.on_success) {\n\t\t\t\t\t\t\t\tthis.on_success(file_doc, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (xhr.status === 403) {\n\t\t\t\t\t\t\tlet response = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t\tfrappe.msgprint({\n\t\t\t\t\t\t\t\ttitle: __('Not permitted'),\n\t\t\t\t\t\t\t\tindicator: 'red',\n\t\t\t\t\t\t\t\tmessage: response._error_message\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfile.failed = true;\n\t\t\t\t\t\t\tlet error = null;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\terror = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\t\t// pass\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfrappe.request.cleanup({}, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txhr.open('POST', '/api/method/upload_file', true);\n\t\t\t\txhr.setRequestHeader('Accept', 'application/json');\n\t\t\t\txhr.setRequestHeader('X-Frappe-CSRF-Token', frappe.csrf_token);\n\n\t\t\t\tlet form_data = new FormData();\n\t\t\t\tif (file.file_obj) {\n\t\t\t\t\tform_data.append('file', file.file_obj, file.name);\n\t\t\t\t}\n\t\t\t\tform_data.append('is_private', +file.private);\n\t\t\t\tform_data.append('folder', this.folder);\n\n\t\t\t\tif (file.file_url) {\n\t\t\t\t\tform_data.append('file_url', file.file_url);\n\t\t\t\t}\n\n\t\t\t\tif (this.doctype && this.docname) {\n\t\t\t\t\tform_data.append('doctype', this.doctype);\n\t\t\t\t\tform_data.append('docname', this.docname);\n\t\t\t\t}\n\n\t\t\t\tif (this.fieldname) {\n\t\t\t\t\tform_data.append('fieldname', this.fieldname);\n\t\t\t\t}\n\n\t\t\t\tif (this.method) {\n\t\t\t\t\tform_data.append('method', this.method);\n\t\t\t\t}\n\n\t\t\t\txhr.send(form_data);\n\t\t\t});\n\t\t}\n\t}\n}\n</script>\n<style>\n.file-upload-area {\n\tmin-height: 100px;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$4 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$4 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$4 = false;
	  /* component normalizer */
	  function __vue_normalize__$4(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/mieone/Downloads/frappe-practice/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/FileUploader.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$3() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$3.styles || (__vue_create_injector__$3.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var FileUploaderComponent = __vue_normalize__$4(
	    { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
	    __vue_inject_styles__$4,
	    __vue_script__$4,
	    __vue_scope_id__$4,
	    __vue_is_functional_template__$4,
	    __vue_module_identifier__$4,
	    __vue_create_injector__$3,
	    undefined
	  );

	class FileUploader {
		constructor(ref) {
		var this$1 = this;
		if ( ref === void 0 ) ref = {};
		var wrapper = ref.wrapper;
		var method = ref.method;
		var on_success = ref.on_success;
		var doctype = ref.doctype;
		var docname = ref.docname;
		var fieldname = ref.fieldname;
		var files = ref.files;
		var folder = ref.folder;
		var restrictions = ref.restrictions;
		var upload_notes = ref.upload_notes;
		var allow_multiple = ref.allow_multiple;
		var as_dataurl = ref.as_dataurl;
		var disable_file_browser = ref.disable_file_browser;

			if (!wrapper) {
				this.make_dialog();
			} else {
				this.wrapper = wrapper.get ? wrapper.get(0) : wrapper;
			}

			this.$fileuploader = new Vue({
				el: this.wrapper,
				render: function (h) { return h(FileUploaderComponent, {
					props: {
						show_upload_button: !Boolean(this$1.dialog),
						doctype: doctype,
						docname: docname,
						fieldname: fieldname,
						method: method,
						folder: folder,
						on_success: on_success,
						restrictions: restrictions,
						upload_notes: upload_notes,
						allow_multiple: allow_multiple,
						as_dataurl: as_dataurl,
						disable_file_browser: disable_file_browser,
					}
				}); }
			});

			this.uploader = this.$fileuploader.$children[0];

			if (files && files.length) {
				this.uploader.add_files(files);
			}
		}

		upload_files() {
			var this$1 = this;

			this.dialog && this.dialog.get_primary_btn().prop('disabled', true);
			return this.uploader.upload_files()
				.then(function () {
					this$1.dialog && this$1.dialog.hide();
				});
		}

		make_dialog() {
			var this$1 = this;

			this.dialog = new frappe.ui.Dialog({
				title: 'Upload',
				fields: [
					{
						fieldtype: 'HTML',
						fieldname: 'upload_area'
					}
				],
				primary_action_label: __('Upload'),
				primary_action: function () { return this$1.upload_files(); }
			});

			this.wrapper = this.dialog.fields_dict.upload_area.$wrapper[0];
			this.dialog.show();
			this.dialog.$wrapper.on('hidden.bs.modal', function() {
				$(this).data('bs.modal', null);
				$(this).remove();
			});
		}
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors

	frappe.provide('frappe.ui');
	frappe.ui.FileUploader = FileUploader;

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.ui');

	frappe.ui.Tree = class {
		constructor(ref) {
		var parent = ref.parent;
		var label = ref.label;
		var root_value = ref.root_value;
		var icon_set = ref.icon_set;
		var toolbar = ref.toolbar;
		var expandable = ref.expandable;
		var with_skeleton = ref.with_skeleton; if ( with_skeleton === void 0 ) with_skeleton = 1;
		var args = ref.args;
		var method = ref.method;
		var get_label = ref.get_label;
		var on_render = ref.on_render;
		var on_click = ref.on_click;

			$.extend(this, arguments[0]);
			if (root_value == null) {
				this.root_value = label;
			}
			this.setup_treenode_class();
			this.nodes = {};
			this.wrapper = $('<div class="tree">').appendTo(this.parent);
			if (with_skeleton) { this.wrapper.addClass('with-skeleton'); }

			if (!icon_set) {
				this.icon_set = {
					open: 'fa fa-fw fa-folder-open',
					closed: 'fa fa-fw fa-folder',
					leaf: 'octicon octicon-primitive-dot'
				};
			}

			this.setup_root_node();
		}

		get_nodes(value, is_root) {
			var this$1 = this;

			var args = Object.assign({}, this.args);
			args.parent = value;
			args.is_root = is_root;

			return new Promise(function (resolve) {
				frappe.call({
					method: this$1.method,
					args: args,
					callback: function (r) {
						resolve(r.message);
					}
				});
			});
		}

		get_all_nodes(value, is_root, label) {
			var args = Object.assign({}, this.args);
			args.label = label || value;
			args.parent = value;
			args.is_root = is_root;

			args.tree_method = this.method;

			return new Promise(function (resolve) {
				frappe.call({
					method: 'frappe.desk.treeview.get_all_nodes',
					args: args,
					callback: function (r) {
						resolve(r.message);
					}
				});
			});
		}

		setup_treenode_class() {
			var tree = this;
			this.TreeNode = class {
				constructor(ref) {
				var parent = ref.parent;
				var label = ref.label;
				var parent_label = ref.parent_label;
				var expandable = ref.expandable;
				var is_root = ref.is_root;
				var data = ref.data;

					$.extend(this, arguments[0]);
					this.loaded = 0;
					this.expanded = 0;
					if(this.parent_label){
						this.parent_node = tree.nodes[this.parent_label];
					}

					tree.nodes[this.label] = this;
					tree.make_node_element(this);
					tree.on_render && tree.on_render(this);
				}
			};
		}

		setup_root_node() {
			this.root_node = new this.TreeNode({
				parent: this.wrapper,
				label: this.label,
				parent_label: null,
				expandable: true,
				is_root: true,
				data: {
					value: this.root_value
				}
			});
			this.expand_node(this.root_node, false);
		}

		refresh() {
			this.selected_node.parent_node &&
				this.load_children(this.selected_node.parent_node, true);
		}

		make_node_element(node) {
			node.$tree_link = $('<span class="tree-link">')
				.attr('data-label', node.label)
				.data('node', node)
				.appendTo(node.parent);

			node.$ul = $('<ul class="tree-children">')
				.hide().appendTo(node.parent);

			this.make_icon_and_label(node);
			if(this.toolbar) {
				node.$toolbar = this.get_toolbar(node).insertAfter(node.$tree_link);
			}
		}

		add_node(node, data) {
			var $li = $('<li class="tree-node">');

			return new this.TreeNode({
				parent: $li.appendTo(node.$ul),
				parent_label: node.label,
				label: data.value,
				title: data.title,
				expandable: data.expandable,
				data: data
			});
		}

		reload_node(node) {
			this.load_children(node);
		}

		toggle() {
			this.get_selected_node().toggle();
		}

		get_selected_node() {
			return this.selected_node;
		}

		set_selected_node(node) {
			this.selected_node = node;
		}

		load_children(node, deep) {
			var this$1 = this;
			if ( deep === void 0 ) deep=false;

			var lab = node.label, value = node.data.value, is_root = node.is_root;

			if(!deep) {
				frappe.run_serially([
					function () { return this$1.get_nodes(value, is_root); },
					function (data_set) { return this$1.render_node_children(node, data_set); },
					function () { return this$1.set_selected_node(node); }
				]);
			} else {
				frappe.run_serially([
					function () { return this$1.get_all_nodes(value, is_root, lab); },
					function (data_list) { return this$1.render_children_of_all_nodes(data_list); },
					function () { return this$1.set_selected_node(node); }
				]);
			}
		}

		render_children_of_all_nodes(data_list) {
			var this$1 = this;

			data_list.map(function (d) { return this$1.render_node_children(this$1.nodes[d.parent], d.data); });
		}

		render_node_children(node, data_set) {
			var this$1 = this;

			node.$ul.empty();
			if (data_set) {
				$.each(data_set, function (i, data) {
					var child_node = this$1.add_node(node, data);
					child_node.$tree_link
						.data('node-data', data)
						.data('node', child_node);
				});
			}

			node.expanded = false;

			// As children loaded
			node.loaded = true;
			this.expand_node(node);
		}

		on_node_click(node) {
			this.expand_node(node);
			frappe.dom.activate(this.wrapper, node.$tree_link, 'tree-link');
			if(node.$toolbar) { this.show_toolbar(node); }
		}

		expand_node(node, click) {
			if ( click === void 0 ) click = true;

			this.set_selected_node(node);

			if(click) {
				this.on_click && this.on_click(node);
			}

			if(node.expandable) {
				this.toggle_node(node);
			}
			this.select_link(node);

			node.expanded = !node.expanded;
			node.parent.toggleClass('opened', node.expanded);
		}

		toggle_node(node) {
			if(node.expandable && this.get_nodes && !node.loaded) {
				return this.load_children(node);
			}

			// expand children
			if(node.$ul) {
				if(node.$ul.children().length) {
					node.$ul.toggle(!node.expanded);
				}

				// open close icon
				if(this.icon_set) {
					node.$tree_link.find('i').removeClass();
					if(!node.expanded) {
						node.$tree_link.find('i').addClass(((this.icon_set.open) + " node-parent"));
					} else {
						node.$tree_link.find('i').addClass(((this.icon_set.closed) + " node-parent"));
					}
				}
			}
		}

		select_link(node) {
			this.wrapper.find('.selected')
				.removeClass('selected');
			node.$tree_link.toggleClass('selected');
		}

		show_toolbar(node) {
			if(this.cur_toolbar)
				{ $(this.cur_toolbar).hide(); }
			this.cur_toolbar = node.$toolbar;
			node.$toolbar.show();
		}

		get_node_label(node) {
			if(this.get_label) {
				return this.get_label(node);
			}
			if (node.title && node.title != node.label) {
				return __(node.title) + " <span class='text-muted'>(" + (node.label) + ")</span>";
			} else {
				return __(node.title || node.label);
			}
		}

		make_icon_and_label(node) {
			var this$1 = this;

			var icon_html = '';
			if(this.icon_set) {
				if(node.expandable) {
					icon_html = "<i class=\"" + (this.icon_set.closed) + " node-parent\"></i>";
				} else {
					icon_html = "<i class=\"" + (this.icon_set.leaf) + " node-leaf\"></i>";
				}
			}

			$(icon_html).appendTo(node.$tree_link);
			$(("<a class=\"tree-label grey h6\"> " + (this.get_node_label(node)) + "</a>")).appendTo(node.$tree_link);

			node.$tree_link.on('click', function () {
				setTimeout(function () {this$1.on_node_click(node);}, 100);
			});
		}

		get_toolbar(node) {
			var this$1 = this;

			var $toolbar = $('<span class="tree-node-toolbar btn-group"></span>').hide();

			Object.keys(this.toolbar).map(function (key) {
				var obj = this$1.toolbar[key];
				if(!obj.label) { return; }
				if(obj.condition && !obj.condition(node)) { return; }

				var label = obj.get_label ? obj.get_label() : obj.label;
				var $link = $("<button class='btn btn-default btn-xs'></button>")
					.html(label)
					.addClass('tree-toolbar-button ' + (obj.btnClass || ''))
					.appendTo($toolbar);
				$link.on('click', function () {
					obj.click(node);
					this$1.refresh();
				});
			});

			return $toolbar;
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// page container
	frappe.provide('frappe.pages');
	frappe.provide('frappe.views');

	window.cur_page = null;
	frappe.views.Container = Class.extend({
		_intro: "Container contains pages inside `#container` and manages \
			page creation, switching",
		init: function() {
			this.container = $('#body_div').get(0);
			this.page = null; // current page
			this.pagewidth = $(this.container).width();
			this.pagemargin = 50;

			var me = this;

			$(document).on("page-change", function() {
				// set data-route in body
				var route_str = frappe.get_route_str();
				$("body").attr("data-route", route_str);
				$("body").attr("data-sidebar", me.has_sidebar() ? 1 : 0);
			});

			$(document).bind('rename', function(event, dt, old_name, new_name) {
				frappe.breadcrumbs.rename(dt, old_name, new_name);
			});
		},
		add_page: function(label) {
			var page = $('<div class="content page-container"></div>')
				.attr('id', "page-" + label)
				.attr("data-page-route", label)
				.hide()
				.appendTo(this.container).get(0);
			page.label = label;
			frappe.pages[label] = page;

			return page;
		},
		change_to: function(label) {
			cur_page = this;
			if(this.page && this.page.label === label) {
				$(this.page).trigger('show');
				return;
			}
			if(label.tagName) {
				// if sent the div, get the table
				var page = label;
			} else {
				var page = frappe.pages[label];
			}
			if(!page) {
				console.log(__('Page not found')+ ': ' + label);
				return;
			}

			// hide dialog
			if(window.cur_dialog && cur_dialog.display && !cur_dialog.keep_open) {
				if (!cur_dialog.minimizable) {
					cur_dialog.hide();
				} else if (!cur_dialog.is_minimized) {
					cur_dialog.toggle_minimize();
				}
			}

			// hide current
			if(this.page && this.page != page) {
				$(this.page).hide();
				$(this.page).trigger('hide');
			}

			// show new
			if(!this.page || this.page != page) {
				this.page = page;
				// $(this.page).fadeIn(300);
				$(this.page).show();
			}

			$(document).trigger("page-change");

			this.page._route = window.location.hash;
			$(this.page).trigger('show');
			!this.page.disable_scroll_to_top && frappe.utils.scroll_to(0);
			frappe.breadcrumbs.update();

			return this.page;
		},
		has_sidebar: function() {
			var flag = 0;
			var route_str = frappe.get_route_str();
			// check in frappe.ui.pages
			flag = frappe.ui.pages[route_str] && !frappe.ui.pages[route_str].single_column;

			// sometimes frappe.ui.pages is updated later,
			// so check the dom directly
			if(!flag) {
				var page_route = route_str.split('/').slice(0, 2).join('/');
				flag = $((".page-container[data-page-route=\"" + page_route + "\"] .layout-side-section")).length ? 1 : 0;
			}

			return flag;
		},
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.breadcrumbs = {
		all: {},

		preferred: {
			"File": "",
			"Dashboard": "Customization",
			"Dashboard Chart": "Customization",
			"Dashboard Chart Source": "Customization"
		},

		module_map: {
			'Core': 'Settings',
			'Email': 'Settings',
			'Custom': 'Settings',
			'Workflow': 'Settings',
			'Printing': 'Settings',
			'Setup': 'Settings',
			'Event Streaming': 'Tools',
			'Automation': 'Tools',
		},

		set_doctype_module: function(doctype, module) {
			localStorage["preferred_breadcrumbs:" + doctype] = module;
		},

		get_doctype_module: function(doctype) {
			return localStorage["preferred_breadcrumbs:" + doctype];
		},

		add: function(module, doctype, type) {
			var obj;
			if (typeof module === 'object') {
				obj = module;
			} else {
				obj = {
					module:module,
					doctype:doctype,
					type:type
				};
			}

			frappe.breadcrumbs.all[frappe.breadcrumbs.current_page()] = obj;
			frappe.breadcrumbs.update();
		},

		current_page: function() {
			return frappe.get_route_str();
		},

		update: function() {
			var breadcrumbs = frappe.breadcrumbs.all[frappe.breadcrumbs.current_page()];

			if(!frappe.visible_modules) {
				frappe.visible_modules = $.map(frappe.boot.allowed_modules, function (m) {
					return m.module_name;
				});
			}

			var $breadcrumbs = $("#navbar-breadcrumbs").empty();

			if(!breadcrumbs) {
				$("body").addClass("no-breadcrumbs");
				return;
			}

			if (breadcrumbs.type === 'Custom') {
				var html = "<li><a href=\"" + (breadcrumbs.route) + "\">" + (breadcrumbs.label) + "</a></li>";
				$breadcrumbs.append(html);
				$("body").removeClass("no-breadcrumbs");
				return;
			}

			// get preferred module for breadcrumbs, based on sent via module
			var from_module = frappe.breadcrumbs.get_doctype_module(breadcrumbs.doctype);

			if(from_module) {
				breadcrumbs.module = from_module;
			} else if(frappe.breadcrumbs.preferred[breadcrumbs.doctype]!==undefined) {
				// get preferred module for breadcrumbs
				breadcrumbs.module = frappe.breadcrumbs.preferred[breadcrumbs.doctype];
			}

			if(breadcrumbs.module) {
				if (frappe.breadcrumbs.module_map[breadcrumbs.module]) {
					breadcrumbs.module = frappe.breadcrumbs.module_map[breadcrumbs.module];
				}

				var current_module = breadcrumbs.module;
				// Check if a desk page exists
				if (frappe.boot.module_page_map[breadcrumbs.module]) {
					breadcrumbs.module = frappe.boot.module_page_map[breadcrumbs.module];
				}

				if(frappe.get_module(current_module)) {
					// if module access exists
					var module_info = frappe.get_module(current_module),
						icon = module_info && module_info.icon,
						label = module_info ? module_info.label : breadcrumbs.module;

					if(module_info && !module_info.blocked && frappe.visible_modules.includes(module_info.module_name)) {
						$(repl('<li><a href="#workspace/%(module)s">%(label)s</a></li>',
							{ module: breadcrumbs.module, label: __(breadcrumbs.module) }))
							.appendTo($breadcrumbs);
					}
				}
			}
			if(breadcrumbs.doctype && frappe.get_route()[0]==="Form") {
				if(breadcrumbs.doctype==="User"
					|| frappe.get_doc('DocType', breadcrumbs.doctype).issingle) ; else {
					var route;
					if(frappe.boot.treeviews.indexOf(breadcrumbs.doctype) !== -1) {
						var view = frappe.model.user_settings[breadcrumbs.doctype].last_view || 'Tree';
						route = view + '/' + breadcrumbs.doctype;
					} else {
						route = 'List/' + breadcrumbs.doctype;
					}
					$(repl('<li><a href="#%(route)s">%(label)s</a></li>',
						{route: route, label: __(breadcrumbs.doctype)}))
						.appendTo($breadcrumbs);
				}
			}

			$("body").removeClass("no-breadcrumbs");
		},

		rename: function(doctype, old_name, new_name) {
			var old_route_str = ["Form", doctype, old_name].join("/");
			var new_route_str = ["Form", doctype, new_name].join("/");
			frappe.breadcrumbs.all[new_route_str] = frappe.breadcrumbs.all[old_route_str];
			delete frappe.breadcrumbs.all[old_route_str];
		}

	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.pages');
	frappe.provide('frappe.views');

	frappe.views.Factory = class Factory {
		constructor(opts) {
			$.extend(this, opts);
		}

		show() {
			var page_name = frappe.get_route_str(),
				me = this;

			if(frappe.pages[page_name] && !page_name.includes("Form/")) {
				frappe.container.change_to(page_name);
				if(me.on_show) {
					me.on_show();
				}
			} else {
				var route = frappe.get_route();
				if(route[1]) {
					me.make(route);
				} else {
					frappe.show_not_found(route);
				}
			}
		}

		make_page(double_column, page_name) {
			return frappe.make_page(double_column, page_name);
		}
	};

	frappe.make_page = function(double_column, page_name) {
		if(!page_name) {
			var page_name = frappe.get_route_str();
		}
		var page = frappe.container.add_page(page_name);

		frappe.ui.make_app_page({
			parent: page,
			single_column: !double_column
		});
		frappe.container.change_to(page_name);
		return page;
	};

	class Desktop {
		constructor(ref) {
		var wrapper = ref.wrapper;

			this.wrapper = wrapper;
			this.pages = {};
			this.sidebar_items = {};
			this.mobile_sidebar_items = {};
			this.sidebar_categories = [
				"Modules",
				"Domains",
				"Places",
				"Administration"
			];
			this.make();
		}

		make() {
			var this$1 = this;

			this.make_container();
			this.fetch_desktop_settings().then(function () {
				this$1.route();
				this$1.make_sidebar();
			});
		}

		route() {
			var page = this.get_page_to_show();
			this.show_page(page);
		}

		make_container() {
			this.container = $("\n\t\t\t<div class=\"desk-container row\">\n\t\t\t\t<div class=\"desk-sidebar\"></div>\n\t\t\t\t<div class=\"desk-body\">\n\t\t\t\t\t<div class=\"page-switcher\">\n\t\t\t\t\t\t<div class=\"current-title\"></div>\n\t\t\t\t\t\t<i class=\"fa fa-chevron-down text-muted\"></i>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"mobile-list\">\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>");

			this.container.appendTo(this.wrapper);
			this.sidebar = this.container.find(".desk-sidebar");
			this.body = this.container.find(".desk-body");
			this.current_title = this.container.find(".current-title");
			this.mobile_list = this.container.find(".mobile-list");
			this.page_switcher = this.container.find(".page-switcher");
		}

		fetch_desktop_settings() {
			var this$1 = this;

			return frappe
				.call("frappe.desk.desktop.get_desk_sidebar_items")
				.then(function (response) {
					if (response.message) {
						this$1.sidebar_configuration = response.message;
					} else {
						frappe.throw({
							title: __("Couldn't Load Desk"),
							message:
								__("Something went wrong while loading Desk. <b>Please relaod the page</b>. If the problem persists, contact the Administrator"),
							indicator: "red",
							primary_action: {
								label: __("Reload"),
								action: function () { return location.reload(); }
							}
						});
					}
				});
		}

		make_sidebar() {
			var this$1 = this;

			var get_sidebar_item = function (item) {
				return $(("<a href=\"" + ("desk#workspace/" + item.name) + "\"\n\t\t\t\t\tclass=\"sidebar-item\n\t\t\t\t\t\t" + (item.selected ? " selected" : "") + "\n\t\t\t\t\t\t" + (item.hidden ? "hidden" : "") + "\n\t\t\t\t\t\">\n\t\t\t\t\t<span>" + (item.label || item.name) + "</span>\n\t\t\t\t</div>"));
			};

			var make_sidebar_category_item = function (item) {
				if (item.name == this$1.get_page_to_show()) {
					item.selected = true;
					this$1.current_page = item.name;
				}
				var $item = get_sidebar_item(item);
				var $mobile_item = $item.clone();

				$item.appendTo(this$1.sidebar);
				this$1.sidebar_items[item.name] = $item;

				$mobile_item.appendTo(this$1.mobile_list);
				this$1.mobile_sidebar_items[item.name] = $mobile_item;
			};

			var make_category_title = function (name) {
				// DO NOT REMOVE: Comment to load translation
				// __("Modules") __("Domains") __("Places") __("Administration")
				var $title = $(
					("<div class=\"sidebar-group-title h6 uppercase\">" + (__(name)) + "</div>")
				);
				$title.appendTo(this$1.sidebar);
				$title.clone().appendTo(this$1.mobile_list);
			};

			this.sidebar_categories.forEach(function (category) {
				if (this$1.sidebar_configuration.hasOwnProperty(category)) {
					make_category_title(category);
					this$1.sidebar_configuration[category].forEach(function (item) {
						make_sidebar_category_item(item);
					});
				}
			});
			if (frappe.is_mobile) {
				this.page_switcher.on('click', function () {
					this$1.mobile_list.toggle();
				});
			}
		}

		show_page(page) {
			if (this.current_page && this.pages[this.current_page]) {
				this.pages[this.current_page].hide();
			}

			if (this.sidebar_items && this.sidebar_items[this.current_page]) {
				this.sidebar_items[this.current_page].removeClass("selected");
				this.mobile_sidebar_items[this.current_page].removeClass("selected");

				this.sidebar_items[page].addClass("selected");
				this.mobile_sidebar_items[page].addClass("selected");
			}
			this.current_page = page;
			this.mobile_list.hide();
			this.current_title.empty().append(this.current_page);
			localStorage.current_desk_page = page;
			this.pages[page] ? this.pages[page].show() : this.make_page(page);
		}

		get_page_to_show() {
			var default_page;

			if (this.sidebar_configuration && this.sidebar_configuration["Modules"]) {
				default_page = this.sidebar_configuration["Modules"][0].name;
			} else {
				default_page = frappe.boot.allowed_workspaces[0].name;
			}

			var page =
				frappe.get_route()[1] ||
				localStorage.current_desk_page ||
				default_page;

			return page;
		}

		make_page(page) {
			var $page = new DesktopPage({
				container: this.body,
				page_name: page
			});

			this.pages[page] = $page;
			return $page;
		}
	}

	class DesktopPage {
		constructor(ref) {
		var container = ref.container;
		var page_name = ref.page_name;

			frappe.desk_page = this;
			this.container = container;
			this.page_name = page_name;
			this.sections = {};
			this.allow_customization = false;
			this.reload();
		}

		show() {
			frappe.desk_page = this;
			this.page.show();
			if (this.sections.shortcuts) {
				this.sections.shortcuts.widgets_list.forEach(function (wid) {
					wid.set_actions();
				});
			}
		}

		hide() {
			this.page.hide();
		}

		reload() {
			this.in_customize_mode = false;
			this.page && this.page.remove();
			this.make();
			this.setup_events();
		}

		make_customization_link() {
			var this$1 = this;

			this.customize_link = $(("<div class=\"small customize-options\" style=\"cursor: pointer;\">" + (__('Customize Workspace')) + "</div>"));
			this.customize_link.appendTo(this.page);
			this.customize_link.on('click', function () {
				this$1.customize();
			});

			this.save_or_discard_link = $(("<div class=\"small customize-options small-bounce\">\n\t\t\t<span class=\"save-customization\">" + (__('Save')) + "</span> / <span class=\"discard-customization\">" + (__('Discard')) + "</span>\n\t\t\t</div>")).hide();

			this.save_or_discard_link.appendTo(this.page);
			this.save_or_discard_link.find(".save-customization").on("click", function () { return this$1.save_customization(); });
			this.save_or_discard_link.find(".discard-customization").on("click", function () { return this$1.reload(); });
			this.page.addClass('allow-customization');
		}

		make() {
			var this$1 = this;

			this.page = $(("<div class=\"desk-page\" data-page-name=" + (this.page_name) + "></div>"));
			this.page.appendTo(this.container);

			this.get_data().then(function (res) {
				this$1.data = res.message;
				if (!this$1.data) {
					delete localStorage.current_desk_page;
					frappe.set_route("workspace");
					return;
				}

				this$1.refresh();
			});
		}

		refresh() {
			var this$1 = this;

			this.page.empty();
			this.allow_customization = this.data.allow_customization || false;

			if (frappe.is_mobile()) {
				this.allow_customization = false;
			}

			this.allow_customization && this.make_customization_link();
			this.data.onboarding && this.data.onboarding.items.length && this.make_onboarding();
			this.make_charts().then(function () {
				this$1.make_shortcuts();
				this$1.make_cards();

				if (this$1.allow_customization) {
					// Move the widget group up to align with labels if customization is allowed
					$('.desk-page .widget-group:visible:first').css('margin-top', '-25px');
				}
			});
		}

		get_data() {
			return frappe.call("frappe.desk.desktop.get_desktop_page", {
				page: this.page_name
			});
		}

		setup_events() {
			var this$1 = this;

			$(document.body).on('toggleFullWidth', function () { return this$1.refresh(); });
		}

		customize() {
			var this$1 = this;

			if (this.in_customize_mode) {
				return;
			}

			// It may be possible the chart area is hidden since it has no widgets
			// So the margin-top: -25px would be applied to the shortcut group
			// We need to remove this as the  chart group will be visible during customization
			$('.widget.onboarding-widget-box').hide();
			$('.desk-page .widget-group:visible:first').css('margin-top', '0px');

			this.customize_link.hide();
			this.save_or_discard_link.show();

			Object.keys(this.sections).forEach(function (section) {
				this$1.sections[section].customize();
			});
			this.in_customize_mode = true;

			// Move the widget group up to align with labels if customization is allowed
			$('.desk-page .widget-group:visible:first').css('margin-top', '-25px');
		}

		save_customization() {
			var this$1 = this;

			frappe.dom.freeze();
			var config = {};

			if (this.sections.charts) { config.charts = this.sections.charts.get_widget_config(); }
			if (this.sections.shortcuts) { config.shortcuts = this.sections.shortcuts.get_widget_config(); }
			if (this.sections.cards) { config.cards = this.sections.cards.get_widget_config(); }

			frappe.call('frappe.desk.desktop.save_customization', {
				page: this.page_name,
				config: config
			}).then(function (res) {
				frappe.dom.unfreeze();
				if (res.message) {
					frappe.msgprint({ message: __("Customizations Saved Successfully"), title: __("Success") });
					this$1.reload();
				} else {
					frappe.throw({ message: __("Something went wrong while saving customizations"), title: __("Failed") });
					this$1.reload();
				}
			});
		}

		make_onboarding() {
			this.onboarding_widget = frappe.widget.make_widget({
				label: this.data.onboarding.label || __("Let's Get Started"),
				subtitle: this.data.onboarding.subtitle,
				steps: this.data.onboarding.items,
				success: this.data.onboarding.success,
				docs_url: this.data.onboarding.docs_url,
				widget_type: 'onboarding',
				container: this.page,
				options: {
					allow_sorting: false,
					allow_create: false,
					allow_delete: false,
					allow_hiding: false,
					allow_edit: false,
					max_widget_count: 2,
				}
			});
		}

		make_charts() {
			var this$1 = this;

			return frappe.dashboard_utils.get_dashboard_settings().then(function (settings) {
				var chart_config = settings.chart_config ? JSON.parse(settings.chart_config) : {};
				if (this$1.data.charts.items) {
					this$1.data.charts.items.map(function (chart) {
						chart.chart_settings = chart_config[chart.chart_name] || {};
					});
				}

				this$1.sections["charts"] = new frappe.widget.WidgetGroup({
					title: this$1.data.charts.label || __('{} Dashboard', [__(this$1.page_name)]),
					container: this$1.page,
					type: "chart",
					columns: 1,
					hidden: Boolean(this$1.onboarding_widget),
					options: {
						allow_sorting: this$1.allow_customization,
						allow_create: this$1.allow_customization,
						allow_delete: this$1.allow_customization,
						allow_hiding: false,
						allow_edit: true,
						max_widget_count: 2,
					},
					widgets: this$1.data.charts.items
				});
			});
		}

		make_shortcuts() {
			this.sections["shortcuts"] = new frappe.widget.WidgetGroup({
				title: this.data.shortcuts.label || __('Your Shortcuts'),
				container: this.page,
				type: "shortcut",
				columns: 3,
				options: {
					allow_sorting: this.allow_customization,
					allow_create: this.allow_customization,
					allow_delete: this.allow_customization,
					allow_hiding: false,
					allow_edit: true,
				},
				widgets: this.data.shortcuts.items
			});
		}

		make_cards() {
			var cards = new frappe.widget.WidgetGroup({
				title: this.data.cards.label || __("Reports & Masters"),
				container: this.page,
				type: "links",
				columns: 3,
				options: {
					allow_sorting: this.allow_customization,
					allow_create: false,
					allow_delete: false,
					allow_hiding: this.allow_customization,
					allow_edit: false,
				},
				widgets: this.data.cards.items
			});

			this.sections["cards"] = cards;

			var legend = [
				{
					color: "blue",
					description: __("Important")
				},
				{
					color: "orange",
					description: __("No Records Created")
				}
			].map(function (item) {
				return ("<div class=\"legend-item small text-muted justify-flex-start\">\n\t\t\t\t<span class=\"indicator " + (item.color) + "\"></span>\n\t\t\t\t<span class=\"link-content ellipsis\" draggable=\"false\">" + (item.description) + "</span>\n\t\t\t</div>");
			});

			$(("<div class=\"legend\">\n\t\t\t" + (legend.join("\n")) + "\n\t\t</div>")).insertAfter(cards.body);
		}
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors

	frappe.provide('frappe.views.pageview');
	frappe.provide("frappe.standard_pages");

	frappe.views.pageview = {
		with_page: function(name, callback) {
			if(in_list(Object.keys(frappe.standard_pages), name)) {
				if(!frappe.pages[name]) {
					frappe.standard_pages[name]();
				}
				callback();
				return;
			}

			if((locals.Page && locals.Page[name] && locals.Page[name].script) || name==window.page_name) {
				// already loaded
				callback();
			} else if(localStorage["_page:" + name] && frappe.boot.developer_mode!=1) {
				// cached in local storage
				frappe.model.sync(JSON.parse(localStorage["_page:" + name]));
				callback();
			} else {
				// get fresh
				return frappe.call({
					method: 'frappe.desk.desk_page.getpage',
					args: {'name':name },
					callback: function(r) {
						if(!r.docs._dynamic_page) {
							localStorage["_page:" + name] = JSON.stringify(r.docs);
						}
						callback();
					},
					freeze: true,
				});
			}
		},

		show: function(name) {
			if(!name) {
				name = (frappe.boot ? frappe.boot.home_page : window.page_name);

				if(name === "workspace") {
					if(!frappe.workspace) {
						var page = frappe.container.add_page('workspace');
						var container = $('<div class="container"></div>').appendTo(page);
						container = $('<div></div>').appendTo(container);

						frappe.workspace = new Desktop({
							wrapper: container
						});
					}

					frappe.container.change_to('workspace');
					frappe.workspace.route();
					frappe.utils.set_title(__('Desk'));
					return;
				}
			}
			frappe.model.with_doctype("Page", function() {
				frappe.views.pageview.with_page(name, function(r) {
					if(r && r.exc) {
						if(!r['403'])
							{ frappe.show_not_found(name); }
					} else if(!frappe.pages[name]) {
						new frappe.views.Page(name);
					}
					frappe.container.change_to(name);
				});
			});
		}
	};

	frappe.views.Page = Class.extend({
		init: function(name) {
			this.name = name;
			var me = this;
			// web home page
			if(name==window.page_name) {
				this.wrapper = document.getElementById('page-' + name);
				this.wrapper.label = document.title || window.page_name;
				this.wrapper.page_name = window.page_name;
				frappe.pages[window.page_name] = this.wrapper;
			} else {
				this.pagedoc = locals.Page[this.name];
				if(!this.pagedoc) {
					frappe.show_not_found(name);
					return;
				}
				this.wrapper = frappe.container.add_page(this.name);
				this.wrapper.label = this.pagedoc.title || this.pagedoc.name;
				this.wrapper.page_name = this.pagedoc.name;

				// set content, script and style
				if(this.pagedoc.content)
					{ this.wrapper.innerHTML = this.pagedoc.content; }
				frappe.dom.eval(this.pagedoc.__script || this.pagedoc.script || '');
				frappe.dom.set_style(this.pagedoc.style || '');

				// set breadcrumbs
				frappe.breadcrumbs.add(this.pagedoc.module || null);
			}

			this.trigger_page_event('on_page_load');
			// set events
			$(this.wrapper).on('show', function() {
				window.cur_frm = null;
				me.trigger_page_event('on_page_show');
				me.trigger_page_event('refresh');
			});
		},
		trigger_page_event: function(eventname) {
			var me = this;
			if(me.wrapper[eventname]) {
				me.wrapper[eventname](me.wrapper);
			}
		}
	});

	frappe.show_not_found = function(page_name) {
		frappe.show_message_page({
			page_name: page_name,
			message: __("Sorry! I could not find what you were looking for."),
			img: "/assets/frappe/images/ui/bubble-tea-sorry.svg"
		});
	};

	frappe.show_not_permitted = function(page_name) {
		frappe.show_message_page({
			page_name: page_name,
			message: __("Sorry! You are not permitted to view this page."),
			img: "/assets/frappe/images/ui/bubble-tea-sorry.svg",
			// icon: "octicon octicon-circle-slash"
		});
	};

	frappe.show_message_page = function(opts) {
		// opts can include `page_name`, `message`, `icon` or `img`
		if(!opts.page_name) {
			opts.page_name = frappe.get_route_str();
		}

		if(opts.icon) {
			opts.img = repl('<span class="%(icon)s message-page-icon"></span> ', opts);
		} else if (opts.img) {
			opts.img = repl('<img src="%(img)s" class="message-page-image">', opts);
		}

		var page = frappe.pages[opts.page_name] || frappe.container.add_page(opts.page_name);
		$(page).html(
			repl('<div class="page message-page">\
			<div class="text-center message-page-content">\
				%(img)s\
				<p class="lead">%(message)s</p>\
				<a class="btn btn-default btn-sm btn-home" href="#">%(home)s</a>\
			</div>\
		</div>', {
					img: opts.img || "",
					message: opts.message || "",
					home: __("Home")
				})
		);

		frappe.container.change_to(opts.page_name);
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt
	frappe.provide('frappe.search');
	frappe.provide('frappe.tags');

	frappe.search.AwesomeBar = Class.extend({
		setup: function(element) {
			var me = this;

			var $input = $(element);
			var input = $input.get(0);

			this.options = [];
			this.global_results = [];

			var awesomplete = new Awesomplete(input, {
				minChars: 0,
				maxItems: 99,
				autoFirst: true,
				list: [],
				filter: function(text, term) {
					return true;
				},
				data: function(item, input) {
					return {
						label: (item.index || ""),
						value: item.value
					};
				},
				item: function(item, term) {
					var d = this.get_item(item.value);
					var name = __(d.label || d.value);
					var html = '<span>' + name + '</span>';
					if(d.description && d.value!==d.description) {
						html += '<br><span class="text-muted ellipsis">' + __(d.description) + '</span>';
					}
					return $('<li></li>')
						.data('item.autocomplete', d)
						.html('<a style="font-weight:normal"><p>' + html + '</p></a>')
						.get(0);
				},
				sort: function(a, b) {
					return (b.label - a.label);
				}
			});

			// Added to aid UI testing of global search
			input.awesomplete = awesomplete;

			$input.on("input", function(e) {
				var value = e.target.value;
				var txt = value.trim().replace(/\s\s+/g, ' ');
				var last_space = txt.lastIndexOf(' ');
				me.global_results = [];
				// if(txt && txt.length > 1) {
				// 	me.global.get_awesome_bar_options(txt.toLowerCase(), me);
				// }

				var $this = $(this);
				clearTimeout($this.data('timeout'));

				$this.data('timeout', setTimeout(function(){
					me.options = [];
					if(txt && txt.length > 1) {
						if(last_space !== -1) {
							me.set_specifics(txt.slice(0,last_space), txt.slice(last_space+1));
						}
						me.add_defaults(txt);
						me.options = me.options.concat(me.build_options(txt));
						me.options = me.options.concat(me.global_results);
					} else {
						me.options = me.options.concat(
							me.deduplicate(frappe.search.utils.get_recent_pages(txt || "")));
						me.options = me.options.concat(frappe.search.utils.get_frequent_links());
					}
					me.add_help();

					awesomplete.list = me.deduplicate(me.options);
				}, 100));

			});

			var open_recent = function() {
				if (!this.autocomplete_open) {
					$(this).trigger("input");
				}
			};
			$input.on("focus", open_recent);

			$input.on("awesomplete-open", function(e) {
				me.autocomplete_open = e.target;
			});

			$input.on("awesomplete-close", function(e) {
				me.autocomplete_open = false;
			});

			$input.on("awesomplete-select", function(e) {
				var o = e.originalEvent;
				var value = o.text.value;
				var item = awesomplete.get_item(value);

				if(item.route_options) {
					frappe.route_options = item.route_options;
				}

				if(item.onclick) {
					item.onclick(item.match);
				} else {
					var previous_hash = window.location.hash;
					frappe.set_route(item.route);

					// hashchange didn't fire!
					if (window.location.hash == previous_hash) {
						frappe.route();
					}
				}
				$input.val("");
			});

			$input.on("awesomplete-selectcomplete", function(e) {
				$input.val("");
			});

			$input.on("keydown", null, 'esc', function() {
				$input.blur();
			});
			frappe.search.utils.setup_recent();
		},

		add_help: function() {
			this.options.push({
				value: __("Help on Search"),
				index: -10,
				default: "Help",
				onclick: function() {
					var txt = '<table class="table table-bordered">\
					<tr><td style="width: 50%">'+__('Create a new record')+'</td><td>'+
							__("new type of document")+'</td></tr>\
					<tr><td>'+__("List a document type")+'</td><td>'+
							__("document type..., e.g. customer")+'</td></tr>\
					<tr><td>'+__("Search in a document type")+'</td><td>'+
							__("text in document type")+'</td></tr>\
					<tr><td>'+__("Tags")+'</td><td>'+
							__("tag name..., e.g. #tag")+'</td></tr>\
					<tr><td>'+__("Open a module or tool")+'</td><td>'+
							__("module name...")+'</td></tr>\
					<tr><td>'+__("Calculate")+'</td><td>'+
							__("e.g. (55 + 434) / 4 or =Math.sin(Math.PI/2)...")+'</td></tr>\
				</table>';
					frappe.msgprint(txt, __("Search Help"));
				}
			});
		},

		set_specifics: function(txt, end_txt) {
			var me = this;
			var results = this.build_options(txt);
			results.forEach(function(r) {
				if(r.type && (r.type).toLowerCase().indexOf(end_txt.toLowerCase()) === 0) {
					me.options.push(r);
				}
			});
		},

		add_defaults: function(txt) {
			this.make_global_search(txt);
			this.make_search_in_current(txt);
			this.make_calculator(txt);
			this.make_random(txt);
		},

		build_options: function(txt) {
			var options = frappe.search.utils.get_creatables(txt).concat(
				frappe.search.utils.get_search_in_list(txt),
				frappe.search.utils.get_doctypes(txt),
				frappe.search.utils.get_reports(txt),
				frappe.search.utils.get_pages(txt),
				frappe.search.utils.get_workspaces(txt),
				frappe.search.utils.get_dashboards(txt),
				frappe.search.utils.get_recent_pages(txt || ""),
				frappe.search.utils.get_executables(txt)
			);
			if (txt.charAt(0) === "#") {
				options = frappe.tags.utils.get_tags(txt);
			}
			var out = this.deduplicate(options);
			return out.sort(function(a, b) {
				return b.index - a.index;
			});
		},

		deduplicate: function(options) {
			var out = [], routes = [];
			options.forEach(function(option) {
				if(option.route) {
					if(option.route[0] === "List" && option.route[2] !== 'Report') {
						option.route.splice(2);
					}
					var str_route = (typeof option.route==='string') ?
						option.route : option.route.join('/');
					if(routes.indexOf(str_route)===-1) {
						out.push(option);
						routes.push(str_route);
					} else {
						var old = routes.indexOf(str_route);
						if(out[old].index < option.index && !option.recent) {
							out[old] = option;
						}
					}
				} else {
					out.push(option);
					routes.push("");
				}
			});
			return out;
		},

		set_global_results: function(global_results, txt) {
			this.global_results = this.global_results.concat(global_results);
		},

		make_global_search: function(txt) {

			if (txt.charAt(0) === "#") {
				return;
			}

			this.options.push({
				label: __("Search for '{0}'", [frappe.utils.xss_sanitise(txt).bold()]),
				value: __("Search for '{0}'", [txt]),
				match: txt,
				index: 100,
				default: "Search",
				onclick: function() {
					frappe.searchdialog.search.init_search(txt, "global_search");
				}
			});
		},

		make_search_in_current: function(txt) {
			var route = frappe.get_route();
			if(route[0]==="List" && txt.indexOf(" in") === -1) {
				// search in title field
				var meta = frappe.get_meta(frappe.container.page.list_view.doctype);
				var search_field = meta.title_field || "name";
				var options = {};
				options[search_field] = ["like", "%" + txt + "%"];
				this.options.push({
					label: __('Find {0} in {1}', [txt.bold(), __(route[1]).bold()]),
					value: __('Find {0} in {1}', [txt, __(route[1])]),
					route_options: options,
					onclick: function() {
						cur_list.show();
					},
					index: 90,
					default: "Current",
					match: txt
				});
			}
		},

		make_calculator: function(txt) {
			var first = txt.substr(0,1);
			if(first==parseInt(first) || first==="(" || first==="=") {
				if(first==="=") {
					txt = txt.substr(1);
				}
				try {
					var val = eval(txt);
					var formatted_value = __('{0} = {1}', [txt, (val + '').bold()]);
					this.options.push({
						label: formatted_value,
						value: __('{0} = {1}', [txt, val]),
						match: val,
						index: 80,
						default: "Calculator",
						onclick: function() {
							frappe.msgprint(formatted_value, "Result");
						}
					});
				} catch(e) {
					// pass
				}
			}
		},

		make_random: function(txt) {
			if(txt.toLowerCase().includes('random')) {
				this.options.push({
					label: "Generate Random Password",
					value: frappe.utils.get_random(16),
					onclick: function() {
						frappe.msgprint(frappe.utils.get_random(16), "Result");
					}
				});
			}
		}
	});

	frappe.provide('frappe.search');

	frappe.ui.Notifications = class Notifications {
		constructor() {
		var this$1 = this;

			frappe.model
				.with_doc('Notification Settings', frappe.session.user)
				.then(function (doc) {
					this$1.notifications_settings = doc;
					this$1.make();
				});
		}

		make() {
			this.$dropdown = $('.navbar').find('.dropdown-notifications');
			this.$dropdown_list = this.$dropdown.find('.notifications-list');
			this.$notification_indicator = this.$dropdown.find(
				'.notifications-indicator'
			);
			this.user = frappe.session.user;
			this.max_length = 20;

			this.render_dropdown_headers();
			this.$notifications = this.$dropdown_list.find(
				'.category-list[data-category="Notifications"]'
			);
			this.$open_docs = this.$dropdown_list.find(
				'.category-list[data-category="Open Documents"]'
			);
			this.$today_events = this.$dropdown_list.find(
				'.category-list[data-category="Todays Events"]'
			);

			frappe.utils.bind_actions_with_object(this.$dropdown_list, this);
			var me = this;
			frappe.search.utils.make_function_searchable(
				me.route_to_settings,
				__('Notification Settings')
			);

			this.setup_notifications();
			this.bind_events();
		}

		route_to_settings() {
			frappe.set_route(("#Form/Notification Settings/" + (frappe.session.user)));
		}

		setup_notifications() {
			var this$1 = this;

			this.get_notifications_list(this.max_length).then(function (list) {
				this$1.dropdown_items = list;
				this$1.render_notifications_dropdown();
				if (this$1.notifications_settings.seen == 0) {
					this$1.$notification_indicator.show();
				}
			});
		}

		render_todays_events(e, $target) {
			var this$1 = this;

			var hide = $target.next().hasClass('in');
			if (!hide) {
				var today = frappe.datetime.get_today();
				frappe.xcall('frappe.desk.doctype.event.event.get_events', {
					start: today,
					end: today
				}).then(function (event_list) {
					this$1.render_events_html(event_list);
				});
			}
		}

		render_events_html(event_list) {
			var html = '';
			if (event_list.length) {
				var get_event_html = function (event) {
					var time = frappe.datetime.get_time(event.starts_on);
					return ("<a class=\"recent-item event\" href=\"#Form/Event/" + (event.name) + "\">\n\t\t\t\t\t<span class=\"event-time bold\">" + time + "</span>\n\t\t\t\t\t<span class=\"event-subject\">" + (event.subject) + "</span>\n\t\t\t\t</a>");
				};
				html = event_list.map(get_event_html).join('');
			} else {
				html = "<li class=\"recent-item text-center\">\n\t\t\t\t\t<span class=\"text-muted\">" + (__('No Events Today')) + "</span>\n\t\t\t\t</li>";
			}

			this.$today_events.html(html);
		}

		get_open_document_config(e) {
			var this$1 = this;

			this.open_docs_config = {
				ToDo: { label: __('To Do') },
				Event: { label: __('Calendar'), route: 'List/Event/Calendar' }
			};

			var hide = $(e.currentTarget)
				.next()
				.hasClass('in');
			if (!hide) {
				frappe.ui.notifications.get_notification_config().then(function (r) {
					this$1.open_document_list = r;
					this$1.render_open_document_count();
				});
			}
		}

		render_open_document_count() {
			this.$open_docs.html('');
			var defaults = ['ToDo'];
			this.get_counts(this.open_document_list['open_count_doctype'], 1, defaults);
			var targets = { doctypes: {} },
				map = this.open_document_list['targets'];

			Object.keys(map).map(function (doctype) {
				Object.keys(map[doctype]).map(function (doc) {
					targets[doc] = map[doctype][doc];
					targets.doctypes[doc] = doctype;
				});
			});

			this.get_counts(targets, 1, null, ['doctypes'], true);
			this.get_counts(
				this.open_document_list['open_count_doctype'],
				0,
				null,
				defaults
			);
		}

		get_counts(map, divide, keys, excluded, target) {
			var this$1 = this;
			if ( excluded === void 0 ) excluded = [];
			if ( target === void 0 ) target = false;

			var empty_map = 1;
			keys = keys
				? keys
				: Object.keys(map).sort().filter(function (e) { return !excluded.includes(e); });
			keys.map(function (key) {
				var doc_dt = map.doctypes ? map.doctypes[key] : undefined;
				if (map[key] > 0 || target) {
					this$1.add_open_document_html(key, map[key], doc_dt, target);
					empty_map = 0;
				}
			});

			if (divide && !empty_map) {
				this.$open_docs.append($('<li class="divider"></li>'));
			}
		}

		add_open_document_html(name, value, doc_dt, target) {
			if ( target === void 0 ) target = false;

			var label = this.open_docs_config[name]
				? this.open_docs_config[name].label
				: name;
			var title = target ? ("title=\"" + (__('Your Target')) + "\"") : '';
			var $list_item = !target
				? $(("<li><a class=\"badge-hover\" data-action=\"route_to_document_type\" data-doctype=\"" + name + "\" " + title + ">\n\t\t\t\t" + (__(label)) + "\n\t\t\t\t<span class=\"badge pull-right\">" + value + "</span>\n\t\t\t</a></li>"))
				: $(("<li><a class=\"progress-small\" data-action=\"route_to_document_type\" " + title + "\n\t\t\t\tdata-doctype=\"" + doc_dt + "\" data-docname=\"" + name + "\">\n\t\t\t\t\t<span class=\"dropdown-item-label\">" + (__(label)) + "<span>\n\t\t\t\t\t<div class=\"progress-chart\">\n\t\t\t\t\t\t<div class=\"progress\">\n\t\t\t\t\t\t\t<div class=\"progress-bar\" style=\"width: " + value + "%\"></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t</a></li>"));

			this.$open_docs.append($list_item);
			if (!target) { this.total += value; }
		}

		route_to_document_type(e) {
			this.$dropdown.removeClass('open');
			this.$dropdown.trigger('hide.bs.dropdown');
			var doctype = $(e.currentTarget).attr('data-doctype');
			var docname = $(e.currentTarget).attr('data-docname');
			if (!docname) {
				var config = this.open_docs_config[doctype] || {};
				if (config.route) {
					frappe.set_route(config.route);
				} else if (config.click) {
					config.click();
				} else {
					frappe.ui.notifications.show_open_count_list(doctype);
				}
			} else {
				frappe.set_route('Form', doctype, docname);
			}
		}

		update_dropdown() {
			var this$1 = this;

			this.get_notifications_list(1).then(function (r) {
				var new_item = r[0];
				this$1.dropdown_items.unshift(new_item);
				if (this$1.dropdown_items.length > this$1.max_length) {
					this$1.$dropdown_list
						.find('.recent-notification')
						.last()
						.remove();
					this$1.dropdown_items.pop();
				}

				this$1.insert_into_dropdown();
			});
		}

		insert_into_dropdown() {
			var new_item = this.dropdown_items[0];
			var new_item_html = this.get_dropdown_item_html(new_item);
			$(new_item_html).prependTo(this.$dropdown_list.find(this.$notifications));
			this.change_activity_status();
		}

		change_activity_status() {
			if (this.$dropdown_list.find('.activity-status')) {
				this.$dropdown_list.find('.activity-status').replaceWith(
					("<a class=\"recent-item text-center text-muted\"\n\t\t\t\t\thref=\"#List/Notification Log\">\n\t\t\t\t\t<div class=\"full-log-btn\">" + (__('View Full Log')) + "</div>\n\t\t\t\t</a>")
				);
			}
		}

		set_field_as_read(docname, $el) {
			frappe.call(
				'frappe.desk.doctype.notification_log.notification_log.mark_as_read',
				{ docname: docname }
			).then(function (){
				$el.removeClass('unread');
			});
		}

		explicitly_mark_as_read(e, $target) {
			e.preventDefault();
			e.stopImmediatePropagation();
			var docname = $target.parents('.unread').attr('data-name');
			this.set_field_as_read(docname, $target.parents('.unread'));
		}

		mark_as_read(e, $target) {
			var docname = $target.attr('data-name');
			var df = this.dropdown_items.filter(function (f) { return docname.includes(f.name); })[0];
			this.set_field_as_read(df.name, $target);
		}

		mark_all_as_read(e) {
			e.stopImmediatePropagation();
			this.$dropdown_list.find('.unread').removeClass('unread');
			frappe.call(
				'frappe.desk.doctype.notification_log.notification_log.mark_all_as_read'
			);
		}

		toggle_seen(flag) {
			frappe.call(
				'frappe.desk.doctype.notification_settings.notification_settings.set_seen_value',
				{
					value: cint(flag),
					user: frappe.session.user
				}
			);
		}

		get_notifications_list(limit) {
			return frappe.db.get_list('Notification Log', {
				fields: ['*'],
				limit: limit,
				order_by: 'creation desc'
			});
		}

		render_notifications_dropdown() {
			var this$1 = this;

			var body_html = '';
			var view_full_log_html = '';
			var dropdown_html;

			if (this.notifications_settings && !this.notifications_settings.enabled) {
				dropdown_html = "<li class=\"recent-item text-center\">\n\t\t\t\t<span class=\"text-muted\">\n\t\t\t\t\t" + (__('Notifications Disabled')) + "\n\t\t\t\t</span></li>";
			} else {
				if (this.dropdown_items.length) {
					this.dropdown_items.forEach(function (field) {
						var item_html = this$1.get_dropdown_item_html(field);
						if (item_html) { body_html += item_html; }
					});
					view_full_log_html = "<a class=\"recent-item text-center text-muted\"\n\t\t\t\t\thref=\"#List/Notification Log\">\n\t\t\t\t\t\t<div class=\"full-log-btn\">" + (__('View Full Log')) + "</div>\n\t\t\t\t\t</a>";
				} else {
					body_html += "<li class=\"recent-item text-center activity-status\">\n\t\t\t\t\t<span class=\"text-muted\">\n\t\t\t\t\t\t" + (__('No activity')) + "\n\t\t\t\t\t</span></li>";
				}
				dropdown_html = body_html + view_full_log_html;
			}

			this.$notifications.html(dropdown_html);
		}

		get_dropdown_item_html(field) {
			var doc_link = this.get_item_link(field);
			var read_class = field.read ? '' : 'unread';
			var mark_read_action = field.read ? '': 'data-action="mark_as_read"';
			var message = field.subject;
			var title = message.match(/<b class="subject-title">(.*?)<\/b>/);
			message = title ? message.replace(title[1], frappe.ellipsis(strip_html(title[1]), 100)) : message;
			var message_html = "<div class=\"message\">" + message + "</div>";
			var user = field.from_user;
			var user_avatar = frappe.avatar(user, 'avatar-small user-avatar');
			var timestamp = frappe.datetime.comment_when(field.creation, true);
			var item_html =
				"<a class=\"recent-item " + read_class + "\"\n\t\t\t\thref=\"" + doc_link + "\"\n\t\t\t\tdata-name=\"" + (field.name) + "\"\n\t\t\t\t" + mark_read_action + "\n\t\t\t>\n\t\t\t\t" + user_avatar + "\n\t\t\t\t" + message_html + "\n\t\t\t\t<div class=\"notification-timestamp text-muted\">\n\t\t\t\t\t" + timestamp + "\n\t\t\t\t</div>\n\t\t\t\t<span class=\"mark-read text-muted hidden-xs\" data-action=\"explicitly_mark_as_read\">\n\t\t\t\t\t" + (__('Mark as Read')) + "\n\t\t\t\t</span>\n\t\t\t</a>";

			return item_html;
		}

		get_item_link(notification_doc) {
			var link_doctype =
				notification_doc.type == 'Alert' ? 'Notification Log': notification_doc.document_type;
			var link_docname =
				notification_doc.type == 'Alert' ? notification_doc.name: notification_doc.document_name;
			return frappe.utils.get_form_link(
				link_doctype,
				link_docname
			);
		}

		render_dropdown_headers() {
			this.categories = [
				{
					label: __("Notifications"),
					value: "Notifications"
				},
				{
					label: __("Today's Events"),
					value: "Todays Events",
					action: "render_todays_events"
				},
				{
					label: __("Open Documents"),
					value: "Open Documents",
					action: "get_open_document_config"
				}
			];

			var get_headers_html = function (category) {
				var category_id = frappe.dom.get_unique_id();
				var settings_html =
					category.value === 'Notifications'
						? ("<span class=\"notification-settings pull-right\" data-action=\"go_to_settings\">\n\t\t\t\t\t\t" + (__('Settings')) + "\n\t\t\t\t\t</span>")
						: '';
				var mark_all_read_html =
					category.value === 'Notifications'
						? ("<span class=\"mark-all-read pull-right\" data-action=\"mark_all_as_read\">\n\t\t\t\t\t\t" + (__('Mark all as Read')) + "\n\t\t\t\t\t</span>")
						: '';
				var html = "<li class=\"notifications-category\">\n\t\t\t\t\t<li class=\"text-muted header\"\n\t\t\t\t\t\tdata-action=\"" + (category.action) + "\"\n\t\t\t\t\t\thref=\"#" + category_id + "\"\n\t\t\t\t\t\tdata-toggle=\"collapse\">\n\t\t\t\t\t\t" + (category.label) + "\n\t\t\t\t\t\t<span class=\"octicon octicon-chevron-down collapse-indicator\"></span>\n\t\t\t\t\t\t" + settings_html + "\n\t\t\t\t\t\t" + mark_all_read_html + "\n\t\t\t\t\t</li>\n\t\t\t\t\t<div id=\"" + category_id + "\" class=\"collapse category-list\" data-category=\"" + (category.value) + "\">\n\t\t\t\t\t\t<div class=\"text-center text-muted notifications-loading\">\n\t\t\t\t\t\t\t" + (__('Loading...')) + "\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</li>";

				return html;
			};

			var html = this.categories
				.map(get_headers_html)
				.join('<li class="divider"></li>');
			this.$dropdown_list.append(html);
			this.$dropdown_list
				.find('.category-list[data-category="Notifications"]')
				.collapse('show');
			this.toggle_collapse_indicator(
				this.$dropdown_list.find('.category-list[data-category="Notifications"]')
			);
		}

		go_to_settings(e) {
			e.stopImmediatePropagation();
			this.$dropdown.removeClass('open');
			this.$dropdown.trigger('hide.bs.dropdown');
			this.route_to_settings();
		}

		bind_events() {
			var this$1 = this;

			this.setup_dropdown_events();
			this.setup_notification_listeners();

			this.$dropdown_list.on('click', '.recent-item', function () {
				this$1.$dropdown.removeClass('open');
			});

			$('.category-list').on('hide.bs.collapse', function (e) {
				this$1.toggle_collapse_indicator($(e.currentTarget));
			});

			$('.category-list').on('show.bs.collapse', function (e) {
				this$1.toggle_collapse_indicator($(e.currentTarget));
			});
		}

		setup_notification_listeners() {
			var this$1 = this;

			frappe.realtime.on('notification', function () {
				this$1.$dropdown.find('.notifications-indicator').show();
				this$1.update_dropdown();
			});

			frappe.realtime.on('indicator_hide', function () {
				this$1.$dropdown.find('.notifications-indicator').hide();
			});
		}

		setup_dropdown_events() {
			var this$1 = this;

			this.$dropdown_list
				.find(
					'[data-category="Notifications"], [data-category="Todays Events"], [data-category="Open Documents"]'
				)
				.collapse({
					toggle: false
				});
			this.$dropdown.on('hide.bs.dropdown', function (e) {
				var hide = $(e.currentTarget).data('closable');
				$(e.currentTarget).data('closable', true);
				return hide;
			});

			this.$dropdown.on('show.bs.dropdown', function () {
				this$1.toggle_seen(true);
				if (this$1.$notification_indicator.is(':visible')) {
					this$1.$notification_indicator.hide();
					frappe.call(
						'frappe.desk.doctype.notification_log.notification_log.trigger_indicator_hide'
					);
				}
			});

			this.$dropdown.on('click', function (e) {
				if ($(e.target).closest('.dropdown-toggle').length) {
					$(e.currentTarget).data('closable', true);
				} else {
					$(e.currentTarget).data('closable', false);
				}
			});
		}

		toggle_collapse_indicator($el) {
			$el
				.prev()
				.find('.collapse-indicator')
				.toggleClass('octicon-chevron-down');
			$el
				.prev()
				.find('.collapse-indicator')
				.toggleClass('octicon-chevron-up');
		}
	};


	frappe.ui.notifications = {
		get_notification_config: function get_notification_config() {
			return frappe.xcall('frappe.desk.notifications.get_notification_info').then(function (r) {
				frappe.ui.notifications.config = r;
				return r;
			});
		},

		show_open_count_list: function show_open_count_list(doctype) {
			var this$1 = this;

			if (!frappe.ui.notifications.config) {
				this.get_notification_config().then(function (){
					this$1.route_to_list_with_filters(doctype);
				});
			} else {
				this.route_to_list_with_filters(doctype);
			}
		},

		route_to_list_with_filters: function route_to_list_with_filters(doctype) {
			var filters = frappe.ui.notifications.config['conditions'][doctype];
			if (filters && $.isPlainObject(filters)) {
				if (!frappe.route_options) {
					frappe.route_options = {};
				}
				$.extend(frappe.route_options, filters);
			}
			frappe.set_route('List', doctype);
		}
	};

	frappe.provide('frappe.search');

	frappe.search.SearchDialog = Class.extend({
		init: function(opts) {
			$.extend(this, opts);
			this.make();
		},

		make: function() {
			var d = new frappe.ui.Dialog();
			$(d.header).html($(frappe.render_template("search_header")));
			this.search_dialog = d;
			this.$search_modal = $(d.$wrapper).addClass('search-dialog');
			this.$modal_body = $(d.body);
			this.$input = this.$search_modal.find(".search-input");
			this.setup();
		},

		setup: function() {
			this.modal_state = 0;
			this.current_keyword = "";
			this.more_count = 20;
			this.full_lists = {};
			this.nav_lists = {};
			this.bind_input();
			this.bind_events();
		},

		update: function($r) {
			this.$search_modal.find('.loading-state').addClass('hide');
			this.$modal_body.append($r);
			if(this.$modal_body.find('.search-results').length > 1) {
				this.$modal_body.find('.search-results').first().addClass("hide");
				$r.removeClass("hide");
				this.$modal_body.find('.search-results').first().remove();
			} else {
				$r.removeClass("hide");
			}
		},

		put_placeholder: function(status_text) {
			var $placeholder = $('<div class="row search-results hide">' +
					'<div class="empty-state"><span style="margin-top: -100px">' +
					'<i class="mega-octicon octicon-telescope status-icon">' +
					'<i class="fa fa-square cover twinkle-one hide" style="left:0px;"></i>'+
					'<i class="fa fa-square cover twinkle-two hide" style="left:8px; top:5px;"></i>'+
					'<i class="fa fa-square cover twinkle-three hide" style="left:13px; top:-3px;"></i></i>'+
					'<p>' + status_text + '</p></span></div>' +
				'</div>');
			this.update($placeholder);
		},

		bind_input: function() {
			var me = this;
			this.$input.on("input", function() {
				var $this = $(this);
				clearTimeout($this.data('timeout'));
				$this.data('timeout', setTimeout(function() {
					if(me.$input.val() === me.current_keyword) { return; }
					var keywords = me.$input.val();
					if(keywords.length > 1) {
						me.get_results(keywords);
					} else {
						me.current_keyword = "";
						me.put_placeholder(me.search.empty_state_text);
					}
				}, 300));
			});
		},

		bind_events: function() {
			var this$1 = this;

			var me = this;

			// Sidebar
			this.$modal_body.on('click', '.list-link',  function() {
				var link = $(this);
				me.$modal_body.find('.search-sidebar').find(".list-link").removeClass("active select");
				link.addClass("active select");
				var type = link.attr('data-category');
				me.$modal_body.find('.results-area').empty().html(me.full_lists[type]);
				me.$modal_body.find('.module-section-link').first().focus();
				me.current_type = type;
			});

			// Summary more links
			this.$modal_body.on('click', '.section-more', function() {
				var type = $(this).attr('data-category');
				me.$modal_body.find('.search-sidebar').find('*[data-category="'+ type +'"]').trigger('click');
			});

			// Back-links (mobile-view)
			this.$modal_body.on('click', '.all-results-link', function() {
				me.$modal_body.find('.search-sidebar').find('*[data-category="All Results"]').trigger('click');
			});

			// Full list more links
			this.$modal_body.on('click', '.list-more', function() {
				var type = $(this).attr('data-category');
				var fetch_type = $(this).attr('data-search');
				var current_count = me.$modal_body.find('.result').length;
				if(fetch_type === "Global") {
					frappe.search.utils.get_global_results(me.current_keyword,
						current_count, me.more_count, type)
						.then(function(doctype_results) {
							me.add_more_results(doctype_results);
						}, function (err) {
							console.error(err);
						});
				} else {
					var results = me.nav_lists[type].slice(0, me.more_count);
					me.nav_lists[type].splice(0, me.more_count);
					me.add_more_results([{title: type, results: results}]);
				}
			});

			// Switch to global search link
			this.$modal_body.on('click', '.switch-to-global-search', function() {
				me.search = me.searches['global_search'];
				me.$input.attr("placeholder", me.search.input_placeholder);
				me.put_placeholder(me.search.empty_state_text);
				me.get_results(me.current_keyword);
			});

			// Help results
			// this.$modal_body.on('click', 'a[data-path]', frappe.help.show_results);
			this.bind_keyboard_events();

			// Setup Minimizable functionality
			this.search_dialog.minimizable = true;
			this.search_dialog.is_minimized = false;
			this.search_dialog.$wrapper.find('.btn-modal-minimize').click(function () { return this$1.toggle_minimize(); });
		},

		bind_keyboard_events: function() {
			var me = this;
			this.$search_modal.on('keydown', function(e) {

				if(me.$modal_body.find('.list-link').length > 1) {
					if(me.modal_state === 0) {
						// DOWN and UP keys navigate sidebar
						var ref = frappe.ui.keyCode;
						var UP_ARROW = ref.UP_ARROW;
						var DOWN_ARROW = ref.DOWN_ARROW;
						var TAB = ref.TAB;
						if(e.which === DOWN_ARROW || e.which === TAB) {
							e.preventDefault();
							var $link = me.$modal_body.find('.list-link.select').next();
							if($link.length > 0) {
								// me.$modal_body.find('.list-link').removeClass('select');
								// $link.addClass('select');
								$link.trigger('click');
							}
						} else if(e.which === UP_ARROW) {
							e.preventDefault();
							var $link = me.$modal_body.find('.list-link.select').prev();
							if($link.length > 0) {
								$link.trigger('click');
							}
						}
					}
				}

				if(!me.$input.is(":focus")) {
					me.$input.focus();
				}
			});

		},

		init_search: function(keywords, search_type) {
			var me = this;
			this.search = this.searches[search_type];
			this.$input.attr("placeholder", this.search.input_placeholder);
			this.put_placeholder(this.search.empty_state_text);
			this.get_results(keywords);
			this.search_dialog.show();
			this.$input.val(keywords);
			setTimeout(function() { me.$input.select(); }, 500);
		},

		get_results: function(keywords) {
			this.current_keyword = keywords;
			if(this.$modal_body.find('.empty-state').length > 0) {
				this.put_placeholder(__("Searching ..."));
				this.$modal_body.find('.cover').removeClass('hide');
			} else {
				this.$search_modal.find('.loading-state').removeClass('hide');
			}

			if (this.current_keyword.charAt(0) === "#") {
				this.search = this.searches["tags"];
			} else {
				this.search = this.searches["global_search"];
			}

			this.search.get_results(keywords, this.parse_results.bind(this));
			if (this.search_dialog.is_minimized) {
				this.toggle_minimize();
			}
		},

		parse_results: function(result_sets, keyword) {
			result_sets = result_sets.filter(function(set) {
				return set.results.length > 0;
			});
			if(result_sets.length > 0) {
				this.render_data(result_sets);
			} else {
				this.put_placeholder(this.search.no_results_status(keyword));
			}
		},

		render_data: function(result_sets) {
			var me = this;
			var $search_results = $(frappe.render_template("search")).addClass('hide');
			var $sidebar = $search_results.find(".search-sidebar").empty();
			var sidebar_item_html = '<li class="module-sidebar-item list-link" data-category="{0}">' +
				'<a><span class="ellipsis">{0}</span><i class="octicon octicon-chevron-right"' +
				'></a></li>';

			this.modal_state = 0;
			this.full_lists = {	'All Results': $('<div class="module-body results-summary"></div>') };
			this.nav_lists = {};

			result_sets.forEach(function(set) {
				$sidebar.append($(__(sidebar_item_html, [set.title])));
				me.add_section_to_summary(set.title, set.results);
				me.full_lists[set.title] = me.render_full_list(set.title, set.results, set.fetch_type);
			});

			if(result_sets.length > 1) {
				$sidebar.prepend($(__(sidebar_item_html, ["All Results"])));
			}

			this.update($search_results.clone());
			this.$modal_body.find('.list-link').first().trigger('click');
		},

		render_full_list: function(type, results, fetch_type) {
			var me = this, max_length = 20;
			var $results_list = $(' <div class="module-body"><div class="row module-section full-list '+
				type+'-section">'+'<div class="col-sm-12 module-section-column">' +
				'<div class="back-link"><a class="all-results-link small"> All Results</a></div>' +
				'<div class="h4 section-head">'+type+'</div>' +
				'<div class="section-body"></div></div></div></div>');

			var $results_col = $results_list.find('.module-section-column');
			for(var i = 0; i < max_length && results.length > 0; i++) {
				$results_col.append(me.render_result(type, results.shift()));
			}
			if(results.length > 0) {
				if(fetch_type === "Nav") { this.nav_lists[type] = results; }
				$results_col.append('<a class="list-more small" data-search="'+ fetch_type +
					'" data-category="'+ type + '" data-count="' + max_length +
					'" style="margin-top:10px">'+__("More...")+'</a>');
			}
			return $results_list;
		},

		add_section_to_summary: function(type, results) {
			var me = this;
			var are_expansive = false;
			var margin_more = "10px";
			for(var i = 0; i < results.length; i++) {
				if(results[i]["description"] || false) {
					are_expansive = true;
					break;
				}
			}
			if(results[0].image) { margin_more = "20px"; }
			var ref = are_expansive ? [3, "12"] : [4, "6"];
			var section_length = ref[0];
			var col_width = ref[1];

			// check state of last summary section
			if(this.full_lists['All Results'].find('.module-section').last().find('.col-sm-6').length !== 1
				|| are_expansive) {
				this.full_lists['All Results'].append($('<div class="row module-section"></div>'));
			}
			var $results_col = $(("<div class=\"col-sm-" + col_width + " module-section-column\" data-type=\"" + type + "\">\n\t\t\t<div class=\"h4 section-head\">" + type + "</div>\n\t\t\t<div class=\"section-body\"></div>\n\t\t\t</div>"));
			results.slice(0, section_length).forEach(function(result) {
				$results_col.append(me.render_result(type, result));
			});
			if(results.length > section_length) {
				$results_col.append(("<div style=\"margin-top:" + margin_more + "\"><a class=\"section-more small\"\n\t\t\t\tdata-category=\"" + type + "\">" + (__("More...")) + "</a></div>"));
			}

			this.full_lists['All Results'].find('.module-section').last().append($results_col);
		},

		render_result: function(type, result) {
			var this$1 = this;

			var $result = $('<div class="result '+ type +'-result"></div>');

			function get_link(result) {
				var link;
				if(result.route) {
					link = 'href="#'+result.route.join('/')+'" ';
				} else if (result.data_path) {
					link = 'data-path="'+result.data_path+'"';
				} else {
					link = "";
				}
				return link;
			}

			if (result.image) {
				$result.append(("<a " + (get_link(result)) + ">\n\t\t\t\t<div class=\"result-image\">\n\t\t\t\t\t<img\n\t\t\t\t\t\tdata-name=\"" + (result.label) + "\"\n\t\t\t\t\t\tsrc=\"" + (result.image) + "\"\n\t\t\t\t\t\talt=\"" + (result.label) + "\"\n\t\t\t\t\t\tonerror=\"this.src='/assets/frappe/images/fallback-thumbnail.jpg'\">\n\t\t\t\t</div>\n\t\t\t</a>"));
			} else if (result.image === null) {
				$result.append('<a '+ get_link(result) +
					'><div class="result-image"><div class="flex-text"><span>'
						+ frappe.get_abbr(result.label) +'</span></div></div></a>');
			}

			var title_html = '<a '+ get_link(result) +' class="module-section-link small">'+ result.label +'</a>';
			var $result_text = $('<div style="display: inline-block;"></div>');
			if(result.description) {
				$result_text.append($('<b>' + title_html + '</b>'));
				$result_text.append('<p class="small">'+ result.description +'</p>');
			} else {
				$result_text.append($(title_html));
				if(result.route_options) {
					frappe.route_options = result.route_options;
				}
				$result.on('click', function (e) {
					this$1.toggle_minimize();
					if(result.onclick) {
						result.onclick(result.match);
					} else {
						var previous_hash = window.location.hash;
						frappe.set_route(result.route);

						// hashchange didn't fire!
						if (window.location.hash == previous_hash) {
							frappe.route();
						}
					}
				});
			}

			$result.append($result_text);

			if(result.subtypes) {
				result.subtypes.forEach(function(subtype) {
					$result.append(subtype);
				});
			}

			return $result;
		},

		add_more_results: function(results_set) {
			var me = this;
			var more_results = $('<div class="more-results last"></div>');
			results_set[0].results.forEach(function(result) {
				more_results.append(me.render_result(results_set[0].title, result));
			});
			this.$modal_body.find('.list-more').before(more_results);

			if(results_set[0].results.length < this.more_count) {
				// hide more button and add a result count
				this.$modal_body.find('.list-more').hide();
				var no_of_results = this.$modal_body.find('.result').length;
				var no_of_results_cue = $('<p class="results-status text-muted small">'+
					no_of_results +' results found</p>');
				this.$modal_body.find(".more-results:last").append(no_of_results_cue);
			}
			this.$modal_body.find('.more-results.last').slideDown(200, function() {});
		},

		get_minimize_btn: function() {
			return this.search_dialog.$wrapper.find(".modal-header .btn-modal-minimize");
		},

		toggle_minimize: function() {
			var modal = this.search_dialog.$wrapper.closest('.modal').toggleClass('modal-minimize');
			modal.attr('tabindex') ? modal.removeAttr('tabindex') : modal.attr('tabindex', -1);
			this.get_minimize_btn().find('i').toggleClass('octicon-chevron-down').toggleClass('octicon-chevron-up');
			this.search_dialog.is_minimized = !this.search_dialog.is_minimized;
			this.on_minimize_toggle && this.on_minimize_toggle(this.search_dialog.is_minimized);
			this.search_dialog.header.find('.modal-title').toggleClass('cursor-pointer');
		},

		// Search objects
		searches: {
			global_search: {
				input_placeholder: __("Search"),
				empty_state_text: __("Search for anything"),
				no_results_status: function (keyword) { return "<p>" + __("No results found for {0} in Global Search", [keyword]) + "</p>"; },

				get_results: function(keywords, callback) {
					var start = 0, limit = 1000;
					var results = frappe.search.utils.get_nav_results(keywords);
					frappe.search.utils.get_global_results(keywords, start, limit)
						.then(function(global_results) {
							results = results.concat(global_results);
							callback(results, keywords);
						}, function (err) {
							console.error(err);
						});
				}
			},
			tags: {
				input_placeholder: __("Search"),
				empty_state_text: __("Search for anything"),
				no_results_status: function (keyword) { return "<p>" + __("No documents found tagged with {0}", [keyword]) + "</p>"; },

				get_results: function(keywords, callback) {
					var results = frappe.search.utils.get_nav_results(keywords);
					frappe.tags.utils.get_tag_results(keywords)
						.then(function(global_results) {
							results = results.concat(global_results);
							callback(results, keywords);
						}, function (err) {
							console.error(err);
						});
				}
			},
		},

	});

	// Copyright (c) 2019, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.tags");

	frappe.tags.utils = {
		get_tags: function(txt) {
			txt = txt.slice(1);
			var out = [];

			var loop = function ( i ) {
				var tag = frappe.tags.tags[i];
				var level = frappe.search.utils.fuzzy_search(txt, tag);
				if (level) {
					out.push({
						type: "Tag",
						label: __("#{0}", [frappe.search.utils.bolden_match_part(__(tag), txt)]),
						value: __("#{0}", [__(tag)]),
						index: 1 + level,
						match: tag,
						onclick: function onclick() {
							// Use Global Search Dialog for tag search too.
							frappe.searchdialog.search.init_search("#".concat(tag), "tags");
						}
					});
				}
			};

			for (var i in frappe.tags.tags) loop( i );

			return out;
		},

		fetch_tags: function fetch_tags() {
			frappe.call({
				method: "frappe.desk.doctype.tag.tag.get_tags_list_for_awesomebar",
				callback: function(r) {
					if (r && r.message) {
						frappe.tags.tags = $.extend([], r.message);
					}
				}
			});
		},

		get_tag_results: function(tag) {
			function get_results_sets(data) {
				var results_sets = [], result, set;
				function get_existing_set(doctype) {
					return results_sets.find(function(set) {
						return set.title === doctype;
					});
				}

				function make_description(content) {
					var field_length = 110;
					var field_value = null;
					if (content.length > field_length) {
						field_value = content.slice(0, field_length) + "...";
					} else {
						var length = content.length;
						field_value = content.slice(0, length) + "...";
					}
					return field_value;
				}

				data.forEach(function(d) {
					// more properties
					var description = "";
					if (d.content) {
						description = make_description(d.content);
					}
					result = {
						label: d.name,
						value: d.name,
						description: description,
						route: ['Form', d.doctype, d.name],

					};
					set = get_existing_set(d.doctype);
					if (set) {
						set.results.push(result);
					} else {
						set = {
							title: d.doctype,
							results: [result],
							fetch_type: "Global"
						};
						results_sets.push(set);
					}

				});
				return results_sets;
			}
			return new Promise(function(resolve) {
				frappe.call({
					method: "frappe.desk.doctype.tag.tag.get_documents_for_tag",
					args: {
						tag: tag
					},
					callback: function(r) {
						if (r.message) {
							resolve(get_results_sets(r.message));
						} else {
							resolve([]);
						}
					}
				});
			});
		},
	};

	frappe.templates['search'] = '<div class="row search-results">     <div class="col-md-2 col-sm-2 hidden-xs layout-side-section">         <ul class="module-sidebar-nav overlay-sidebar nav nav-pills nav-stacked search-sidebar"></ul>     </div>     <div class="col-md-10 col-sm-10 layout-main-section results-area"></div> </div>';

	frappe.templates['search_header'] = '<div class="search-header">  <i class="octicon octicon-search"></i>  <input type="text" class="form-control search-input" style="padding-left: 15px">  <p class="loading-state hide" style="margin: 0px 20px; color:#d4d9dd">{%= __("Searching")%}&nbsp...</p>  <a type="button" class="btn btn-default btn-sm btn-modal-minimize" style="margin-right: 2px;">   <i class="octicon octicon-chevron-down" style="padding: 1px 0px;"></i>  </a>  <a type="button" class="btn btn-default btn-sm btn-modal-close" data-dismiss="modal" aria-hidden="true">   <i class="octicon octicon-x visible-xs" style="padding: 1px 0px;"></i>   <span class="hidden-xs">Close</span>  </a> </div>';

	frappe.provide('frappe.search');

	frappe.search.utils = {
		setup_recent: function() {
			this.recent = JSON.parse(frappe.boot.user.recent || "[]") || [];
		},

		get_recent_pages: function(keywords) {
			if (keywords === null) { keywords = ''; }
			var me = this, values = [], options = [];

			function find(list, keywords, process) {
				list.forEach(function(item, i) {
					var _item = ($.isArray(item)) ? item[0] : item;
					_item = __(_item || '').toLowerCase().replace(/-/g, " ");

					if(keywords===_item || _item.indexOf(keywords) !== -1) {
						var option = process(item);

						if(option) {
							if($.isPlainObject(option)) {
								option = [option];
							}
							option.forEach(function(o) {
								o.match = item; o.recent = true;
							});

							options = option.concat(options);
						}
					}
				});
			}

			me.recent.forEach(function(doctype, i) {
				values.push([doctype[1], ['Form', doctype[0], doctype[1]]]);
			});

			values = values.reverse();

			frappe.route_history.forEach(function(route, i) {
				if(route[0]==='Form') {
					values.push([route[2], route]);
				} else if(['List', 'Tree', 'modules', 'query-report'].includes(route[0]) || route[2]==='Report') {
					if(route[1]) {
						values.push([route[1], route]);
					}
				} else if(route[0]) {
					values.push([frappe.route_titles[route.join('/')] || route[0], route]);
				}
			});

			find(values, keywords, function(match) {
				var out = {
					route: match[1]
				};
				if (match[1][0]==='Form') {
					if (match[1].length > 2 && match[1][1] !== match[1][2]) {
						out.label = __(match[1][1]) + " " + match[1][2].bold();
						out.value = __(match[1][1]) + " " + match[1][2];
					} else {
						out.label = __(match[1][1]).bold();
						out.value = __(match[1][1]);
					}
				} else if (['List', 'Tree', 'modules', 'query-report'].includes(match[1][0]) && (match[1].length > 1)) {
					var type = match[1][0], label = type;
					if(type==='modules') { label = 'Module'; }
					else if(type==='query-report' || match[1][2] ==='Report') { label = 'Report'; }
					out.label = __(match[1][1]).bold() + " " + __(label);
					out.value = __(match[1][1]) + " " + __(label);
				} else if (match[0]) {
					out.label = match[0].bold();
					out.value = match[0];
				} else {
					// eslint-disable-next-line
					console.log('Illegal match', match);
				}
				out.index = 80;
				return out;
			});

			return options;
		},

		get_frequent_links: function get_frequent_links() {
			var options = [];
			frappe.boot.frequently_visited_links.forEach(function (link) {
				var label = frappe.utils.get_route_label(link.route);
				options.push({
					'route': link.route,
					'label': label,
					'value': label,
					'index': link.count,
				});
			});
			if (!options.length) {
				return this.get_recent_pages('');
			}
			return options;
		},

		get_search_in_list: function(keywords) {
			var me = this;
			var out = [];
			if(in_list(keywords.split(" "), "in") && (keywords.slice(-2) !== "in")) {
				var parts = keywords.split(" in ");
				frappe.boot.user.can_read.forEach(function(item) {
					if(frappe.boot.user.can_search.includes(item)) {
						var level = me.fuzzy_search(parts[1], item);
						if(level) {
							out.push({
								type: "In List",
								label: __('Find {0} in {1}', [__(parts[0]), me.bolden_match_part(__(item), parts[1])]),
								value: __('Find {0} in {1}', [__(parts[0]), __(item)]),
								route_options: {"name": ["like", "%" + parts[0] + "%"]},
								index: 1 + level,
								route: ["List", item]
							});
						}
					}
				});
			}
			return out;
		},

		get_creatables: function(keywords) {
			var me = this;
			var out = [];
			var firstKeyword = keywords.split(" ")[0];
			if(firstKeyword.toLowerCase() === __("new")) {
				frappe.boot.user.can_create.forEach(function(item) {
					var level = me.fuzzy_search(keywords.substr(4), item);
					if(level) {
						out.push({
							type: "New",
							label: __("New {0}", [me.bolden_match_part(__(item), keywords.substr(4))]),
							value: __("New {0}", [__(item)]),
							index: 1 + level,
							match: item,
							onclick: function() {
								frappe.new_doc(item, true);
							}
						});
					}
				});
			}
			return out;
		},

		get_doctypes: function(keywords) {
			var me = this;
			var out = [];

			var level, target;
			var option = function(type, route, order) {
				// check to skip extra list in the text
				// eg. Price List List should be only Price List
				var skip_list = type === 'List' && target.endsWith('List');
				var label = me.bolden_match_part(__(target), keywords);
				label += skip_list ? '' : (" " + (__(type)));

				return {
					type: type,
					label: label,
					value: __(target + " " + type),
					index: level + order,
					match: target,
					route: route,
				};
			};
			frappe.boot.user.can_read.forEach(function(item) {
				level = me.fuzzy_search(keywords, item);
				if (level) {
					target = item;
					if (in_list(frappe.boot.single_types, item)) {
						out.push(option("", ["Form", item, item], 0.05));

					} else if (frappe.boot.user.can_search.includes(item)) {
						// include 'making new' option
						if (in_list(frappe.boot.user.can_create, item)) {
							var match = item;
							out.push({
								type: "New",
								label: __("New {0}", [me.bolden_match_part(__(item), keywords)]),
								value: __("New {0}", [__(item)]),
								index: level + 0.015,
								match: item,
								onclick: function() {
									frappe.new_doc(match, true);
								}
							});
						}
						if (in_list(frappe.boot.treeviews, item)) {
							out.push(option("Tree", ["Tree", item], 0.05));

						} else {
							out.push(option("List", ["List", item], 0.05));
							if (frappe.model.can_get_report(item)) {
								out.push(option("Report", ["List", item, "Report"], 0.04));
							}
						}
					}
				}
			});
			return out;
		},

		get_reports: function(keywords) {
			var me = this;
			var out = [];
			var route;
			Object.keys(frappe.boot.user.all_reports).forEach(function(item) {
				var level = me.fuzzy_search(keywords, item);
				if(level > 0) {
					var report = frappe.boot.user.all_reports[item];
					if(report.report_type == "Report Builder")
						{ route = ["List", report.ref_doctype, "Report", item]; }
					else
						{ route = ["query-report",  item]; }
					out.push({
						type: "Report",
						label: __("Report {0}" , [me.bolden_match_part(__(item), keywords)]),
						value: __("Report {0}" , [__(item)]),
						index: level,
						route: route
					});
				}
			});
			return out;
		},

		get_pages: function(keywords) {
			var me = this;
			var out = [];
			this.pages = {};
			$.each(frappe.boot.page_info, function(name, p) {
				me.pages[p.title] = p;
				p.name = name;
			});
			Object.keys(this.pages).forEach(function(item) {
				if(item == "Hub" || item == "hub") { return; }
				var level = me.fuzzy_search(keywords, item);
				if(level) {
					var page = me.pages[item];
					out.push({
						type: "Page",
						label: __("Open {0}", [me.bolden_match_part(__(item), keywords)]),
						value: __("Open {0}", [__(item)]),
						match: item,
						index: level,
						route: [page.route || page.name]
					});
				}
			});
			var target = 'Calendar';
			if(__('calendar').indexOf(keywords.toLowerCase()) === 0) {
				out.push({
					type: "Calendar",
					value: __("Open {0}", [__(target)]),
					index: me.fuzzy_search(keywords, 'Calendar'),
					match: target,
					route: ['List', 'Event', target],
				});
			}
			target = 'Hub';
			if(__('hub').indexOf(keywords.toLowerCase()) === 0) {
				out.push({
					type: "Hub",
					value: __("Open {0}", [__(target)]),
					index: me.fuzzy_search(keywords, 'Hub'),
					match: target,
					route: [target, 'Item'],
				});
			}
			if(__('email inbox').indexOf(keywords.toLowerCase()) === 0) {
				out.push({
					type: "Inbox",
					value: __("Open {0}", [__('Email Inbox')]),
					index: me.fuzzy_search(keywords, 'email inbox'),
					match: target,
					route: ['List', 'Communication', 'Inbox'],
				});
			}
			return out;
		},

		get_workspaces: function(keywords) {
			var me = this;
			var out = [];
			frappe.boot.allowed_workspaces.forEach(function(item) {
				var level = me.fuzzy_search(keywords, item.name);
				if (level > 0) {
					var ret = {
						type: "Workspace",
						label: __("Open {0}", [me.bolden_match_part(__(item.name), keywords)]),
						value: __("Open {0}", [__(item.name)]),
						index: level,
						route: ["workspace", item.name]
					};

					out.push(ret);
				}
			});
			return out;
		},

		get_dashboards: function(keywords) {
			var me = this;
			var out = [];
			frappe.boot.dashboards.forEach(function(item) {
				var level = me.fuzzy_search(keywords, item.name);
				if (level > 0) {
					var ret = {
						type: "Dashboard",
						label: __("{0} Dashboard", [me.bolden_match_part(__(item.name), keywords)]),
						value: __("{0} Dashboard", [__(item.name)]),
						index: level,
						route: ["dashboard", item.name]
					};

					out.push(ret);
				}
			});
			return out;
		},

		get_global_results: function(keywords, start, limit, doctype) {
			if ( doctype === void 0 ) doctype = "";

			var me = this;
			function get_results_sets(data) {
				var results_sets = [], result, set;
				function get_existing_set(doctype) {
					return results_sets.find(function(set) {
						return set.title === doctype;
					});
				}

				function make_description(content, doc_name) {
					var parts = content.split(" ||| ");
					var result_max_length = 300;
					var field_length = 120;
					var fields = [];
					var result_current_length = 0;
					var field_text = "";
					for(var i = 0; i < parts.length; i++) {
						var part = parts[i];
						if(part.toLowerCase().indexOf(keywords) !== -1) {
							// If the field contains the keyword
							if(part.indexOf(' &&& ') !== -1) {
								var colon_index = part.indexOf(' &&& ');
								var field_value = part.slice(colon_index + 5);
							} else {
								var colon_index = part.indexOf(' : ');
								var field_value = part.slice(colon_index + 3);
							}
							if(field_value.length > field_length) {
								// If field value exceeds field_length, find the keyword in it
								// and trim field value by half the field_length at both sides
								// ellipsify if necessary
								var field_data = "";
								var index = field_value.indexOf(keywords);
								field_data += index < field_length/2 ? field_value.slice(0, index)
									: '...' + field_value.slice(index - field_length/2, index);
								field_data += field_value.slice(index, index + field_length/2);
								field_data += index + field_length/2 < field_value.length ? "..." : "";
								field_value = field_data;
							}
							var field_name = part.slice(0, colon_index);

							// Find remaining result_length and add field length to result_current_length
							var remaining_length = result_max_length - result_current_length;
							result_current_length += field_name.length + field_value.length + 2;
							if(result_current_length < result_max_length) {
								// We have room, push the entire field
								field_text = '<span class="field-name text-muted">' +
									me.bolden_match_part(field_name, keywords) + ': </span> ' +
									me.bolden_match_part(field_value, keywords);
								if(fields.indexOf(field_text) === -1 && doc_name !== field_value) {
									fields.push(field_text);
								}
							} else {
								// Not enough room
								if(field_name.length < remaining_length){
									// Ellipsify (trim at word end) and push
									remaining_length -= field_name.length;
									field_text = '<span class="field-name text-muted">' +
										me.bolden_match_part(field_name, keywords) + ': </span> ';
									field_value = field_value.slice(0, remaining_length);
									field_value = field_value.slice(0, field_value.lastIndexOf(' ')) + ' ...';
									field_text += me.bolden_match_part(field_value, keywords);
									fields.push(field_text);
								} else {
									// No room for even the field name, skip
									fields.push('...');
								}
								break;
							}
						}
					}
					return fields.join(', ');
				}

				data.forEach(function(d) {
					// more properties
					result = {
						label: d.name,
						value: d.name,
						description: make_description(d.content, d.name),
						route: ['Form', d.doctype, d.name],
					};
					if(d.image || d.image === null){
						result.image = d.image;
					}
					set = get_existing_set(d.doctype);
					if(set) {
						set.results.push(result);
					} else {
						set = {
							title: d.doctype,
							results: [result],
							fetch_type: "Global"
						};
						results_sets.push(set);
					}

				});
				return results_sets;
			}
			return new Promise(function(resolve, reject) {
				frappe.call({
					method: "frappe.utils.global_search.search",
					args: {
						text: keywords,
						start: start,
						limit: limit,
						doctype: doctype
					},
					callback: function(r) {
						if(r.message) {
							resolve(get_results_sets(r.message));
						} else {
							resolve([]);
						}
					}
				});
			});
		},

		get_nav_results: function(keywords) {
			function sort_uniques(array) {
				var routes = [], out = [];
				array.forEach(function(d) {
					if(d.route) {
						if(d.route[0] === "List" && d.route[2]) {
							d.route.splice(2);
						}
						var str_route = d.route.join('/');
						if(routes.indexOf(str_route) === -1) {
							routes.push(str_route);
							out.push(d);
						} else {
							var old = routes.indexOf(str_route);
							if(out[old].index > d.index) {
								out[old] = d;
							}
						}
					} else {
						out.push(d);
					}
				});
				return out.sort(function(a, b) {
					return b.index - a.index;
				});
			}
			var lists = [], setup = [];
			var all_doctypes = sort_uniques(this.get_doctypes(keywords));
			all_doctypes.forEach(function(d) {
				if(d.type === "") {
					setup.push(d);
				} else {
					lists.push(d);
				}
			});
			var in_keyword = keywords.split(" in ")[0];
			return [{
				title: "Recents",
				fetch_type: "Nav",
				results: sort_uniques(this.get_recent_pages(keywords))
			},
			{
				title: "Create a new ...",
				fetch_type: "Nav",
				results: sort_uniques(this.get_creatables(keywords))
			},
			{
				title: "Lists",
				fetch_type: "Nav",
				results: lists
			},
			{
				title: "Reports",
				fetch_type: "Nav",
				results: sort_uniques(this.get_reports(keywords))
			},
			{
				title: "Administration",
				fetch_type: "Nav",
				results: sort_uniques(this.get_pages(keywords))
			},
			{
				title: "Workspace",
				fetch_type: "Nav",
				results: sort_uniques(this.get_workspaces(keywords))
			},
			{
				title: "Dashboard",
				fetch_type: "Nav",
				results: sort_uniques(this.get_dashboards(keywords))
			},
			{
				title: "Setup",
				fetch_type: "Nav",
				results: setup
			},
			{
				title: "Find '" + in_keyword + "' in ... ",
				fetch_type: "Nav",
				results: sort_uniques(this.get_search_in_list(keywords))
			}];
		},

		fuzzy_search: function(keywords, _item) {
			// Returns 10 for case-perfect contain, 0 for not found
			//  	9 for perfect contain,
			//  	0 - 6 for fuzzy contain

			// **Specific use-case step**
			keywords = keywords || '';
			var item = __(_item || '');
			var item_without_hyphen = item.replace(/-/g, " ");

			var item_length = item.length;
			var query_length = keywords.length;
			var length_ratio = query_length / item_length;
			var max_skips = 3, max_mismatch_len = 2;

			if (query_length > item_length) {
				return 0;
			}

			// check for perfect string matches or
			// matches that start with the keyword
			if ([item, item_without_hyphen].includes(keywords)
					|| [item, item_without_hyphen].some(function (txt) { return txt.toLowerCase().indexOf(keywords) === 0; })) {
				return 10 + length_ratio;
			}

			if (item.indexOf(keywords) !== -1 && keywords !== keywords.toLowerCase()) {
				return 9 + length_ratio;
			}

			item = item.toLowerCase();
			keywords = keywords.toLowerCase();

			if (item.indexOf(keywords) !== -1) {
				return 8 + length_ratio;
			}

			var skips = 0, mismatches = 0;
			outer: for (var i = 0, j = 0; i < query_length; i++) {
				if (mismatches !== 0) { skips++; }
				if (skips > max_skips) { return 0; }
				var k_ch = keywords.charCodeAt(i);
				mismatches = 0;
				while (j < item_length) {
					if (item.charCodeAt(j++) === k_ch) {
						continue outer;
					}
					if(++mismatches > max_mismatch_len)  { return 0 ; }
				}
				return 0;
			}

			// Since indexOf didn't pass, there will be atleast 1 skip
			// hence no divide by zero, but just to be safe
			if((skips + mismatches) > 0) {
				return (5 + length_ratio)/(skips + mismatches);
			} else {
				return 0;
			}
		},

		bolden_match_part: function(str, subseq) {
			var rendered = "";
			if(this.fuzzy_search(subseq, str) === 0) {
				return str;
			} else if(this.fuzzy_search(subseq, str) > 6) {
				var regEx = new RegExp("("+ subseq +")", "ig");
				return str.replace(regEx, '<b>$1</b>');
			} else {
				var str_orig = str;
				var str = str.toLowerCase();
				var str_len = str.length;
				var subseq = subseq.toLowerCase();

				outer: for(var i = 0, j = 0; i < subseq.length; i++) {
					var sub_ch = subseq.charCodeAt(i);
					while(j < str_len) {
						if(str.charCodeAt(j) === sub_ch) {
							var str_char = str_orig.charAt(j);
							if(str_char === str_char.toLowerCase()) {
								rendered += '<b>' + subseq.charAt(i) + '</b>';
							} else {
								rendered += '<b>' + subseq.charAt(i).toUpperCase() + '</b>';
							}
							j++;
							continue outer;
						}
						rendered += str_orig.charAt(j);
						j++;
					}
					return str_orig;
				}
				rendered += str_orig.slice(j);
				return rendered;
			}

		},

		get_executables: function get_executables(keywords) {
			var this$1 = this;

			var results = [];
			this.searchable_functions.forEach(function (item) {
				var target = item.label.toLowerCase();
				var txt = keywords.toLowerCase();
				if (txt === target || target.indexOf(txt) === 0) {
					results.push({
						type: "Executable",
						value:  this$1.bolden_match_part(__(item.label), txt),
						index: this$1.fuzzy_search(txt, target),
						match: item.label,
						onclick: function () { return item.action.apply(this$1, item.args); }
					});
				}
			});
			return results;
		},
		make_function_searchable: function make_function_searchable(_function, label, args) {
			if ( label === void 0 ) label=null;
			if ( args === void 0 ) args=null;

			if (typeof _function !== 'function') {
				throw new Error('First argument should be a function');
			}

			this.searchable_functions.push({
				'label': label || _function.name,
				'action': _function,
				'args': args,
			});
		},
		searchable_functions: [],
	};

	frappe.provide('frappe.ui.misc');
	frappe.ui.misc.about = function() {
		if(!frappe.ui.misc.about_dialog) {
			var d = new frappe.ui.Dialog({title: __('Frappe Framework')});

			$(d.body).html(repl("<div>\
		<p>"+__("Open Source Applications for the Web")+"</p>  \
		<p><i class='fa fa-globe fa-fw'></i>\
			Website: <a href='https://frappeframework.com' target='_blank'>https://frappeframework.com</a></p>\
		<p><i class='fa fa-github fa-fw'></i>\
			Source: <a href='https://github.com/frappe' target='_blank'>https://github.com/frappe</a></p>\
		<p><i class='fa fa-linkedin fa-fw'></i>\
			Linkedin: <a href='https://linkedin.com/company/frappe-tech' target='_blank'>https://linkedin.com/company/frappe-tech</a></p>\
		<p><i class='fa fa-facebook fa-fw'></i>\
			Facebook: <a href='https://facebook.com/erpnext' target='_blank'>https://facebook.com/erpnext</a></p>\
		<p><i class='fa fa-twitter fa-fw'></i>\
			Twitter: <a href='https://twitter.com/erpnext' target='_blank'>https://twitter.com/erpnext</a></p>\
		<hr>\
		<h4>Installed Apps</h4>\
		<div id='about-app-versions'>Loading versions...</div>\
		<hr>\
		<p class='text-muted'>&copy; Frappe Technologies Pvt. Ltd and contributors </p> \
		</div>", frappe.app));

			frappe.ui.misc.about_dialog = d;

			frappe.ui.misc.about_dialog.on_page_show = function() {
				if(!frappe.versions) {
					frappe.call({
						method: "frappe.utils.change_log.get_versions",
						callback: function(r) {
							show_versions(r.message);
						}
					});
				} else {
					show_versions(frappe.versions);
				}
			};

			var show_versions = function(versions) {
				var $wrap = $("#about-app-versions").empty();
				$.each(Object.keys(versions).sort(), function(i, key) {
					var v = versions[key];
					if(v.branch) {
						var text = $.format('<p><b>{0}:</b> v{1} ({2})<br></p>',
							[v.title, v.branch_version || v.version, v.branch]);
					} else {
						var text = $.format('<p><b>{0}:</b> v{1}<br></p>',
							[v.title, v.version]);
					}
					$(text).appendTo($wrap);
				});

				frappe.versions = versions;
			};

		}

		frappe.ui.misc.about_dialog.show();

	};

	frappe.templates['navbar'] = '<div class="navbar navbar-default navbar-fixed-top" role="navigation">  <div class="container">   <div class="navbar-header navbar-desk">    <a class="navbar-brand toggle-sidebar visible-xs visible-sm">     <i class="octicon octicon-three-bars"></i>    </a>    <a class="navbar-brand navbar-home hidden-xs hidden-sm" href="#">     <img class="app-logo" style="width: {{navbar_settings.logo_width || 24}}px" src="{{ frappe.app.logo_url }}">    </a>    <ul class="nav navbar-nav" id="navbar-breadcrumbs">    </ul>   </div>   <div class="navbar-center ellipsis" style="display: none;"></div>   <ul class="nav navbar-nav navbar-right">    <li class="visible-xs">     <a class="navbar-search-button" href="#" data-toggle="modal" data-target="#search-modal"><i class="octicon octicon-search"></i></a>    </li>    <li class="dropdown dropdown-navbar-user dropdown-mobile">     <a class="dropdown-toggle" data-toggle="dropdown" href="#"      onclick="return false;">     {{ avatar }}     <span class="ellipsis toolbar-user-fullname hidden-xs hidden-sm">      {%= __("Settings") %}</span>     <b class="caret hidden-xs hidden-sm"></b></a>     <ul class="dropdown-menu" id="toolbar-user" role="menu">      {% for item in navbar_settings.settings_dropdown %}       {% if (!item.hidden) { %}        {% if (item.route) { %}         <li>          <a href="{{ item.route }}">           {%= __(item.item_label) %}          </a>         </li>        {% } else if (item.action) { %}         <li>          <a onclick="return {{ item.action }}">           {%= __(item.item_label) %}          </a>         </li>        {% } else { %}         <li class="divider"></li>        {% } %}       {% } %}      {% endfor %}     </ul>    </li>     <li class="dropdown dropdown-help dropdown-mobile">     <a class="dropdown-toggle" data-toggle="dropdown" href="#"      onclick="return false;"  style="height: 40px;">      <span class="hidden-xs hidden-sm" style="line-height: 24px;">{{ __("Help") }} <b class="caret"></b></span>      <span class="visible-xs visible-sm standard-image help-icon">?</span>     </a>     <ul class="dropdown-menu" id="toolbar-help" role="menu">            <li id="help-links"></li>      <li class="divider documentation-links"></li>      {% for item in navbar_settings.help_dropdown %}       {% if (!item.hidden) { %}        {% if (item.route) { %}         <li>          <a href="{{ item.route }}">           {%= __(item.item_label) %}          </a>         </li>        {% } else if (item.action) { %}         <li>          <a onclick="return {{ item.action }}">           {%= __(item.item_label) %}          </a>         </li>        {% } else { %}         <li class="divider"></li>        {% } %}       {% } %}      {% endfor %}     </ul>    </li>             <li class="frappe-chat-dropdown"></li>         <li class="dropdown dropdown-notifications dropdown-mobile">     <span class="notifications-indicator"><i class="fa fa-circle"></i></span>     <a      class="dropdown-toggle notifications-icon"      data-toggle="dropdown"      aria-haspopup="true"      aria-expanded="true"      href="#"      onclick="return false;">      <span><i class="fa fa-bell" aria-hidden="true"></i></span>     </a>     <ul      class="dropdown-menu notifications-list"      role="menu">     </ul>    </li>   </ul>    <div id="search-modal" class="modal fade" role="dialog">    <div class="modal-dialog" style="height: 50px;">     <div class="modal-content">      <div class="modal-header">       <form role="search" onsubmit="return false;">        <div class="input-group" style="width: 100%">         <input id="modal-search" type="text" class="form-control"         placeholder="{%= __("Search or type a command") %}" aria-haspopup="true">         <button type="reset" class="close" data-dismiss="modal"><i class="octicon octicon-x"></i></button>        </div>       </form>      </div>     </div>    </div>   </div>    <div class="hidden-xs">    <form class="navbar-form navbar-right" role="search" onsubmit="return false;">      <div class="form-group form-group-sm ui-front">     <input id="navbar-search" type="text" class="form-control"      placeholder="{%= __("Search or type a command") %} {%= __("(Ctrl + G)") %}" aria-haspopup="true">     <span class="octicon octicon-search navbar-search-icon"></span>      </div>    </form>   </div>  </div> </div>';

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.ui.toolbar");
	frappe.provide('frappe.search');

	frappe.ui.toolbar.Toolbar = Class.extend({
		init: function() {
			$('header').append(frappe.render_template("navbar", {
				avatar: frappe.avatar(frappe.session.user),
				navbar_settings: frappe.boot.navbar_settings
			}));
			$('.dropdown-toggle').dropdown();

			var awesome_bar = new frappe.search.AwesomeBar();
			awesome_bar.setup("#navbar-search");
			awesome_bar.setup("#modal-search");

			this.setup_notifications();
			this.make();
		},

		make: function() {
			this.setup_sidebar();
			this.setup_help();

			this.bind_events();

			$(document).trigger('toolbar_setup');
		},

		bind_events: function() {
			// clear all custom menus on page change
			$(document).on("page-change", function() {
				$("header .navbar .custom-menu").remove();
			});

			//focus search-modal on show in mobile view
			$('#search-modal').on('shown.bs.modal', function() {
				var search_modal = $(this);
				setTimeout(function() {
					search_modal.find('#modal-search').focus();
				}, 300);
			});
			$('.navbar-toggle-full-width').click(function () {
				frappe.ui.toolbar.toggle_full_width();
			});
		},

		setup_sidebar: function() {
			var header = $('header');
			header.find(".toggle-sidebar").on("click", function() {
				var layout_side_section = $('.layout-side-section');
				var overlay_sidebar = layout_side_section.find('.overlay-sidebar');

				overlay_sidebar.addClass('opened');
				overlay_sidebar.find('.reports-dropdown')
					.removeClass('dropdown-menu')
					.addClass('list-unstyled');
				overlay_sidebar.find('.dropdown-toggle')
					.addClass('text-muted').find('.caret')
					.addClass('hidden-xs hidden-sm');

				$('<div class="close-sidebar">').hide().appendTo(layout_side_section).fadeIn();

				var scroll_container = $('html');
				scroll_container.css("overflow-y", "hidden");

				layout_side_section.find(".close-sidebar").on('click', close_sidebar);
				layout_side_section.on("click", "a:not(.dropdown-toggle)", close_sidebar);

				function close_sidebar(e) {
					scroll_container.css("overflow-y", "");

					layout_side_section.find("div.close-sidebar").fadeOut(function() {
						overlay_sidebar.removeClass('opened')
							.find('.dropdown-toggle')
							.removeClass('text-muted');
						overlay_sidebar.find('.reports-dropdown')
							.addClass('dropdown-menu');
					});
				}
			});
		},

		setup_help: function() {
			frappe.provide('frappe.help');
			frappe.help.show_results = show_results;

			this.search = new frappe.search.SearchDialog();
			frappe.provide('frappe.searchdialog');
			frappe.searchdialog.search = this.search;

			$(".dropdown-help .dropdown-toggle").on("click", function() {
				$(".dropdown-help input").focus();
			});

			$(".dropdown-help .dropdown-menu").on("click", "input, button", function(e) {
				e.stopPropagation();
			});

			$("#input-help").on("keydown", function(e) {
				if(e.which == 13) {
					$(this).val("");
				}
			});

			$(document).on("page-change", function () {
				var $help_links = $(".dropdown-help #help-links");
				$help_links.html("");

				var route = frappe.get_route_str();
				var breadcrumbs = route.split("/");

				var links = [];
				for (var i = 0; i < breadcrumbs.length; i++) {
					var r = route.split("/", i + 1);
					var key = r.join("/");
					var help_links = frappe.help.help_links[key] || [];
					links = $.merge(links, help_links);
				}

				if(links.length === 0) {
					$help_links.next().hide();
				} else {
					$help_links.next().show();
				}

				for (var i = 0; i < links.length; i++) {
					var link = links[i];
					var url = link.url;
					$("<a>", {
						href: link.url,
						text: link.label,
						target: "_blank"
					}).appendTo($help_links);
				}

				$('.dropdown-help .dropdown-menu').on('click', 'a', show_results);
			});

			var $result_modal = frappe.get_modal("", "");
			$result_modal.addClass("help-modal");

			$(document).on("click", ".help-modal a", show_results);

			function show_results(e) {
				//edit links
				var href = e.target.href;
				if(href.indexOf('blob') > 0) {
					window.open(href, '_blank');
				}
				var path = $(e.target).attr("data-path");
				if(path) {
					e.preventDefault();
				}
			}
		},

		setup_notifications: function() {
			this.notifications = new frappe.ui.Notifications();
		}

	});

	$.extend(frappe.ui.toolbar, {
		add_dropdown_button: function(parent, label, click, icon) {
			var menu = frappe.ui.toolbar.get_menu(parent);
			if(menu.find("li:not(.custom-menu)").length && !menu.find(".divider").length) {
				frappe.ui.toolbar.add_menu_divider(menu);
			}

			return $('<li class="custom-menu"><a><i class="fa-fw '
				+icon+'"></i> '+label+'</a></li>')
				.insertBefore(menu.find(".divider"))
				.find("a")
				.click(function() {
					click.apply(this);
				});
		},
		get_menu: function(label) {
			return $("#navbar-" + label.toLowerCase());
		},
		add_menu_divider: function(menu) {
			menu = typeof menu == "string" ?
				frappe.ui.toolbar.get_menu(menu) : menu;

			$('<li class="divider custom-menu"></li>').prependTo(menu);
		},
		add_icon_link: function add_icon_link(route, icon, index, class_name) {
			var parent_element = $(".navbar-right").get(0);
			var new_element = $(("<li class=\"" + class_name + "\">\n\t\t\t<a class=\"btn\" href=\"" + route + "\" title=\"" + (frappe.utils.to_title_case(class_name, true)) + "\" aria-haspopup=\"true\" aria-expanded=\"true\">\n\t\t\t\t<div>\n\t\t\t\t\t<i class=\"octicon " + icon + "\"></i>\n\t\t\t\t</div>\n\t\t\t</a>\n\t\t</li>")).get(0);

			parent_element.insertBefore(new_element, parent_element.children[index]);
		},
		toggle_full_width: function toggle_full_width() {
			var fullwidth = JSON.parse(localStorage.container_fullwidth || 'false');
			fullwidth = !fullwidth;
			localStorage.container_fullwidth = fullwidth;
			frappe.ui.toolbar.set_fullwidth_if_enabled();
			$(document.body).trigger('toggleFullWidth');
		},
		set_fullwidth_if_enabled: function set_fullwidth_if_enabled() {
			var fullwidth = JSON.parse(localStorage.container_fullwidth || 'false');
			$(document.body).toggleClass('full-width', fullwidth);
		},
		show_shortcuts: function show_shortcuts (e) {
			e.preventDefault();
			frappe.ui.keys.show_keyboard_shortcut_dialog();
			return false;
		},
	});

	frappe.ui.toolbar.clear_cache = frappe.utils.throttle(function() {
		frappe.assets.clear_local_storage();
		frappe.xcall('frappe.sessions.clear').then(function (message) {
			frappe.show_alert({
				message: message,
				indicator: 'green'
			});
			location.reload(true);
		});
	}, 10000);

	frappe.ui.toolbar.show_about = function() {
		try {
			frappe.ui.misc.about();
		} catch(e) {
			console.log(e);
		}
		return false;
	};

	frappe.ui.toolbar.route_to_user = function() {
		frappe.set_route('Form', 'User', frappe.session.user);
	};

	frappe.ui.toolbar.view_website = function() {
		var website_tab = window.open();
		website_tab.opener = null;
		website_tab.location = '/index';
	};

	frappe.ui.toolbar.setup_session_defaults = function() {
		var fields = [];
		frappe.call({
			method: 'frappe.core.doctype.session_default_settings.session_default_settings.get_session_default_values',
			callback: function (data) {
				fields = JSON.parse(data.message);
				var perms = frappe.perm.get_perm('Session Default Settings');
				//add settings button only if user is a System Manager or has permission on 'Session Default Settings'
				if ((in_list(frappe.user_roles, 'System Manager')) || (perms[0].read == 1))  {
					fields[fields.length] = {
						'fieldname': 'settings',
						'fieldtype': 'Button',
						'label': __('Settings'),
						'click': function () {
							frappe.set_route('Form', 'Session Default Settings', 'Session Default Settings');
						}
					};
				}
				frappe.prompt(fields, function(values) {
					//if default is not set for a particular field in prompt
					fields.forEach(function(d) {
						if (!values[d.fieldname]) {
							values[d.fieldname] = "";
						}
					});
					frappe.call({
						method: 'frappe.core.doctype.session_default_settings.session_default_settings.set_session_default_values',
						args: {
							default_values: values,
						},
						callback: function(data) {
							if (data.message == "success") {
								frappe.show_alert({
									'message': __('Session Defaults Saved'),
									'indicator': 'green'
								});
								frappe.ui.toolbar.clear_cache();
							}	else {
								frappe.show_alert({
									'message': __('An error occurred while setting Session Defaults'),
									'indicator': 'red'
								});
							}
						}
					});
				},
				__('Session Defaults'),
				__('Save')
				);
			}
		});
	};

	// Copyright (c) 2018, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.last_edited_communication = {};
	frappe.standard_replies = {};

	frappe.views.CommunicationComposer = Class.extend({
		init: function(opts) {
			$.extend(this, opts);
			this.make();
		},
		make: function() {
			var this$1 = this;

			var me = this;

			this.dialog = new frappe.ui.Dialog({
				title: (this.title || this.subject || __("New Email")),
				no_submit_on_enter: true,
				fields: this.get_fields(),
				primary_action_label: __("Send"),
				primary_action: function() {
					me.delete_saved_draft();
					me.send_action();
				},
				minimizable: true
			});

			['recipients', 'cc', 'bcc'].forEach(function (field) {
				this$1.dialog.fields_dict[field].get_data = function() {
					var data = me.dialog.fields_dict[field].get_value();
					var txt = data.match(/[^,\s*]*$/)[0] || '';
					var options = [];

					frappe.call({
						method: "frappe.email.get_contact_list",
						args: {
							txt: txt,
						},
						callback: function (r) {
							options = r.message;
							me.dialog.fields_dict[field].set_data(options);
						}
					});
					return options;
				};
			});

			this.prepare();
			this.dialog.show();

			if (this.frm) {
				$(document).trigger('form-typing', [this.frm]);
			}
		},

		get_fields: function() {
			var contactList = [];
			var fields= [
				{label:__("To"), fieldtype:"MultiSelect", reqd: 0, fieldname:"recipients",options:contactList},
				{fieldtype: "Section Break", collapsible: 1, label: __("CC, BCC & Email Template")},
				{label:__("CC"), fieldtype:"MultiSelect", fieldname:"cc",options:contactList},
				{label:__("BCC"), fieldtype:"MultiSelect", fieldname:"bcc",options:contactList},
				{label:__("Email Template"), fieldtype:"Link", options:"Email Template",
					fieldname:"email_template"},
				{fieldtype: "Section Break"},
				{label:__("Subject"), fieldtype:"Data", reqd: 1,
					fieldname:"subject", length:524288},
				{fieldtype: "Section Break"},
				{
					label:__("Message"),
					fieldtype:"Text Editor", reqd: 1,
					fieldname:"content",
					onchange: frappe.utils.debounce(this.save_as_draft.bind(this), 300)
				},

				{fieldtype: "Section Break"},
				{fieldtype: "Column Break"},
				{label:__("Send me a copy"), fieldtype:"Check",
					fieldname:"send_me_a_copy", 'default': frappe.boot.user.send_me_a_copy},
				{label:__("Send Read Receipt"), fieldtype:"Check",
					fieldname:"send_read_receipt"},
				{label:__("Attach Document Print"), fieldtype:"Check",
					fieldname:"attach_document_print"},
				{label:__("Select Print Format"), fieldtype:"Select",
					fieldname:"select_print_format"},
				{label:__("Select Languages"), fieldtype:"Select",
					fieldname:"language_sel"},
				{fieldtype: "Column Break"},
				{label:__("Select Attachments"), fieldtype:"HTML",
					fieldname:"select_attachments"}
			];

			// add from if user has access to multiple email accounts
			var email_accounts = frappe.boot.email_accounts.filter(function(account, idx){
				return !in_list(["All Accounts", "Sent", "Spam", "Trash"], account.email_account) &&
					account.enable_outgoing
			});
			if(frappe.boot.email_accounts && email_accounts.length > 1) {
				fields = [
					{label: __("From"), fieldtype: "Select", reqd: 1, fieldname: "sender",
						options: email_accounts.map(function(e) { return e.email_id; }) }
				].concat(fields);
			}

			return fields;
		},
		prepare: function() {
			this.setup_subject_and_recipients();
			this.setup_print_language();
			this.setup_print();
			this.setup_attach();
			this.setup_email();
			this.setup_last_edited_communication();
			this.setup_email_template();

			this.dialog.set_value("recipients", this.recipients || '');
			this.dialog.set_value("cc", this.cc || '');
			this.dialog.set_value("bcc", this.bcc || '');

			if(this.dialog.fields_dict.sender) {
				this.dialog.fields_dict.sender.set_value(this.sender || '');
			}
			this.dialog.fields_dict.subject.set_value(this.subject || '');

			this.setup_earlier_reply();
		},

		setup_subject_and_recipients: function() {
			this.subject = this.subject || "";

			if(!this.forward && !this.recipients && this.last_email) {
				this.recipients = this.last_email.sender;
				this.cc = this.last_email.cc;
				this.bcc = this.last_email.bcc;
			}

			if(!this.forward && !this.recipients) {
				this.recipients = this.frm && this.frm.timeline.get_recipient();
			}

			if(!this.subject && this.frm) {
				// get subject from last communication
				var last = this.frm.timeline.get_last_email();

				if(last) {
					this.subject = last.subject;
					if(!this.recipients) {
						this.recipients = last.sender;
					}

					// prepend "Re:"
					if(strip(this.subject.toLowerCase().split(":")[0])!="re") {
						this.subject = __("Re: {0}", [this.subject]);
					}
				}

				if (!this.subject) {
					this.subject = this.frm.doc.name;
					if (this.frm.meta.subject_field && this.frm.doc[this.frm.meta.subject_field]) {
						this.subject = this.frm.doc[this.frm.meta.subject_field];
					} else if (this.frm.meta.title_field && this.frm.doc[this.frm.meta.title_field]) {
						this.subject = this.frm.doc[this.frm.meta.title_field];
					}
				}

				// always add an identifier to catch a reply
				// some email clients (outlook) may not send the message id to identify
				// the thread. So as a backup we use the name of the document as identifier
				var identifier = "#" + (this.frm.doc.name);
				if (!this.subject.includes(identifier)) {
					this.subject = (this.subject) + " (" + identifier + ")";
				}
			}

			if (this.frm && !this.recipients) {
				this.recipients = this.frm.doc[this.frm.email_field];
			}
		},

		setup_email_template: function() {
			var me = this;

			this.dialog.fields_dict["email_template"].df.onchange = function () {
				var email_template = me.dialog.fields_dict.email_template.get_value();

				var prepend_reply = function(reply) {
					if(me.reply_added===email_template) {
						return;
					}
					var content_field = me.dialog.fields_dict.content;
					var subject_field = me.dialog.fields_dict.subject;
					var content = content_field.get_value() || "";
					var subject = subject_field.get_value() || "";

					var parts = content.split('<!-- salutation-ends -->');

					if(parts.length===2) {
						content = [reply.message, "<br>", parts[1]];
					} else {
						content = [reply.message, "<br>", content];
					}

					content_field.set_value(content.join(''));

					subject_field.set_value(reply.subject);

					me.reply_added = email_template;
				};

				frappe.call({
					method: 'frappe.email.doctype.email_template.email_template.get_email_template',
					args: {
						template_name: email_template,
						doc: me.frm.doc,
						_lang: me.dialog.get_value("language_sel")
					},
					callback: function(r) {
						prepend_reply(r.message);
					},
				});
			};
		},

		setup_last_edited_communication: function() {
			var me = this;
			if (!this.doc){
				if (cur_frm){
					this.doc = cur_frm.doctype;
				}else{
					this.doc = "Inbox";
				}
			}
			if (cur_frm && cur_frm.docname) {
				this.key = cur_frm.docname;
			} else {
				this.key = "Inbox";
			}
			if(this.last_email) {
				this.key = this.key + ":" + this.last_email.name;
			}
			if(this.subject){
				this.key = this.key + ":" + this.subject;
			}
			this.dialog.onhide = function() {
				var last_edited_communication = me.get_last_edited_communication();
				$.extend(last_edited_communication, {
					sender: me.dialog.get_value("sender"),
					recipients: me.dialog.get_value("recipients"),
					cc: me.dialog.get_value("cc"),
					bcc: me.dialog.get_value("bcc"),
					subject: me.dialog.get_value("subject"),
					content: me.dialog.get_value("content"),
				});

				if (me.frm) {
					$(document).trigger("form-stopped-typing", [me.frm]);
				}
			};

			this.dialog.on_page_show = function() {
				if (!me.txt) {
					var last_edited_communication = me.get_last_edited_communication();
					if(last_edited_communication.content) {
						me.dialog.set_value("sender", last_edited_communication.sender || "");
						me.dialog.set_value("subject", last_edited_communication.subject || "");
						me.dialog.set_value("recipients", last_edited_communication.recipients || "");
						me.dialog.set_value("cc", last_edited_communication.cc || "");
						me.dialog.set_value("bcc", last_edited_communication.bcc || "");
						me.dialog.set_value("content", last_edited_communication.content || "");
					}
				}

			};

		},

		get_last_edited_communication: function() {
			if (!frappe.last_edited_communication[this.doc]) {
				frappe.last_edited_communication[this.doc] = {};
			}

			if(!frappe.last_edited_communication[this.doc][this.key]) {
				frappe.last_edited_communication[this.doc][this.key] = {};
			}

			return frappe.last_edited_communication[this.doc][this.key];
		},

		selected_format: function() {
			return this.dialog.fields_dict.select_print_format.input.value || (this.frm && this.frm.meta.default_print_format) || "Standard";
		},

		get_print_format: function(format) {
			if (!format) {
				format = this.selected_format();
			}

			if (locals["Print Format"] && locals["Print Format"][format]) {
				return locals["Print Format"][format];
			} else {
				return {};
			}
		},

		setup_print_language: function() {
			var me = this;
			var doc = this.doc || cur_frm.doc;
			var fields = this.dialog.fields_dict;

			//Load default print language from doctype
			this.lang_code = doc.language;

			if (this.get_print_format().default_print_language) {
				var default_print_language_code = this.get_print_format().default_print_language;
				me.lang_code = default_print_language_code;
			} else {
				var default_print_language_code = null;
			}

			//On selection of language retrieve language code
			$(fields.language_sel.input).change(function(){
				me.lang_code = this.value;
			});

			// Load all languages in the select field language_sel
			$(fields.language_sel.input)
				.empty()
				.add_options(frappe.get_languages());

			if (default_print_language_code) {
				$(fields.language_sel.input).val(default_print_language_code);
			} else {
				$(fields.language_sel.input).val(doc.language);
			}
		},

		setup_print: function() {
			// print formats
			var fields = this.dialog.fields_dict;

			// toggle print format
			$(fields.attach_document_print.input).click(function() {
				$(fields.select_print_format.wrapper).toggle($(this).prop("checked"));
			});

			// select print format
			$(fields.select_print_format.wrapper).toggle(false);

			if (cur_frm) {
				$(fields.select_print_format.input)
					.empty()
					.add_options(cur_frm.print_preview.print_formats)
					.val(cur_frm.print_preview.print_formats[0]);
			} else {
				$(fields.attach_document_print.wrapper).toggle(false);
			}

		},
		setup_attach: function() {
			var this$1 = this;

			var fields = this.dialog.fields_dict;
			var attach = $(fields.select_attachments.wrapper);

			if (!this.attachments) {
				this.attachments = [];
			}

			var args = {
				folder: 'Home/Attachments',
				on_success: function (attachment) {
					this$1.attachments.push(attachment);
					this$1.render_attachment_rows(attachment);
				}
			};

			if (this.frm) {
				args = {
					doctype: this.frm.doctype,
					docname: this.frm.docname,
					folder: 'Home/Attachments',
					on_success: function (attachment) {
						this$1.frm.attachments.attachment_uploaded(attachment);
						this$1.render_attachment_rows(attachment);
					}
				};
			}

			$(("\n\t\t\t<h6 class='text-muted add-attachment' style='margin-top: 12px; cursor:pointer;'>\n\t\t\t\t" + (__("Select Attachments")) + "\n\t\t\t</h6>\n\t\t\t<div class='attach-list'></div>\n\t\t\t<p class='add-more-attachments'>\n\t\t\t\t<a class='text-muted small'>\n\t\t\t\t\t<i class='octicon octicon-plus' style='font-size: 12px'></i>\n\t\t\t\t\t" + (__("Add Attachment")) + "\n\t\t\t\t</a>\n\t\t\t</p>\n\t\t")).appendTo(attach.empty());

			attach
				.find(".add-more-attachments a")
				.on('click', function () { return new frappe.ui.FileUploader(args); });
			this.render_attachment_rows();
		},

		render_attachment_rows: function(attachment) {
			var this$1 = this;

			var select_attachments = this.dialog.fields_dict.select_attachments;
			var attachment_rows = $(select_attachments.wrapper).find(".attach-list");
			if (attachment) {
				attachment_rows.append(this.get_attachment_row(attachment, true));
			} else {
				var files = [];
				if (this.attachments && this.attachments.length) {
					files = files.concat(this.attachments);
				}
				if (this.frm) {
					files = files.concat(this.frm.get_files());
				}

				if (files.length) {
					$.each(files, function (i, f) {
						if (!f.file_name) { return; }
						if (!attachment_rows.find(("[data-file-name=\"" + (f.name) + "\"]")).length) {
							f.file_url = frappe.urllib.get_full_url(f.file_url);
							attachment_rows.append(this$1.get_attachment_row(f));
						}
					});
				}
			}
		},

		get_attachment_row: function get_attachment_row(attachment, checked) {
			return $(("<p class=\"checkbox\">\n\t\t\t<label>\n\t\t\t\t<span>\n\t\t\t\t\t<input\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\tdata-file-name=\"" + (attachment.name) + "\"\n\t\t\t\t\t\t" + (checked ? 'checked': '') + ">\n\t\t\t\t\t</input>\n\t\t\t\t</span>\n\t\t\t\t<span class=\"small\">" + (attachment.file_name) + "</span>\n\t\t\t\t<a href=\"" + (attachment.file_url) + "\" target=\"_blank\" class=\"text-muted small\">\n\t\t\t\t<i class=\"fa fa-share\" style=\"vertical-align: middle; margin-left: 3px;\"></i>\n\t\t\t</label>\n\t\t</p>"));
		},

		setup_email: function() {
			// email
			var fields = this.dialog.fields_dict;

			if(this.attach_document_print) {
				$(fields.attach_document_print.input).click();
				$(fields.select_print_format.wrapper).toggle(true);
			}

			$(fields.send_me_a_copy.input).on('click', function () {
				// update send me a copy (make it sticky)
				var val = fields.send_me_a_copy.get_value();
				frappe.db.set_value('User', frappe.session.user, 'send_me_a_copy', val);
				frappe.boot.user.send_me_a_copy = val;
			});

		},

		send_action: function() {
			var me = this;
			var btn = me.dialog.get_primary_btn();

			var form_values = this.get_values();
			if(!form_values) { return; }

			var selected_attachments =
				$.map($(me.dialog.wrapper).find("[data-file-name]:checked"), function (element) {
					return $(element).attr("data-file-name");
				});


			if(form_values.attach_document_print) {
				me.send_email(btn, form_values, selected_attachments, null, form_values.select_print_format || "");
			} else {
				me.send_email(btn, form_values, selected_attachments);
			}
		},

		get_values: function() {
			var form_values = this.dialog.get_values();

			// cc
			for ( var i=0, l=this.dialog.fields.length; i < l; i++ ) {
				var df = this.dialog.fields[i];

				if ( df.is_cc_checkbox ) {
					// concat in cc
					if ( form_values[df.fieldname] ) {
						form_values.cc = ( form_values.cc ? (form_values.cc + ", ") : "" ) + df.fieldname;
						form_values.bcc = ( form_values.bcc ? (form_values.bcc + ", ") : "" ) + df.fieldname;
					}

					delete form_values[df.fieldname];
				}
			}

			return form_values;
		},

		save_as_draft: function() {
			if (this.dialog && this.frm) {
				try {
					var message = this.dialog.get_value('content');
					message = message.split(frappe.separator_element)[0];
					localStorage.setItem(this.frm.doctype + this.frm.docname, message);
				} catch (e) {
					// silently fail
					console.log(e);
					console.warn('[Communication] localStorage is full. Cannot save message as draft');
				}
			}
		},

		delete_saved_draft: function delete_saved_draft() {
			if (this.dialog) {
				try {
					localStorage.removeItem(this.frm.doctype + this.frm.docname);
				} catch (e) {
					console.log(e);
					console.warn('[Communication] Cannot delete localStorage item'); // eslint-disable-line
				}
			}
		},

		send_email: function(btn, form_values, selected_attachments, print_html, print_format) {
			var me = this;
			me.dialog.hide();

			if(!form_values.recipients) {
				frappe.msgprint(__("Enter Email Recipient(s)"));
				return;
			}

			if(!form_values.attach_document_print) {
				print_html = null;
				print_format = null;
			}


			if(cur_frm && !frappe.model.can_email(me.doc.doctype, cur_frm)) {
				frappe.msgprint(__("You are not allowed to send emails related to this document"));
				return;
			}


			return frappe.call({
				method:"frappe.core.doctype.communication.email.make",
				args: {
					recipients: form_values.recipients,
					cc: form_values.cc,
					bcc: form_values.bcc,
					subject: form_values.subject,
					content: form_values.content,
					doctype: me.doc.doctype,
					name: me.doc.name,
					send_email: 1,
					print_html: print_html,
					send_me_a_copy: form_values.send_me_a_copy,
					print_format: print_format,
					sender: form_values.sender,
					sender_full_name: form_values.sender?frappe.user.full_name():undefined,
					email_template: form_values.email_template,
					attachments: selected_attachments,
					_lang : me.lang_code,
					read_receipt:form_values.send_read_receipt,
					print_letterhead: me.is_print_letterhead_checked(),
				},
				btn: btn,
				callback: function(r) {
					if(!r.exc) {
						frappe.utils.play_sound("email");

						if(r.message["emails_not_sent_to"]) {
							frappe.msgprint(__("Email not sent to {0} (unsubscribed / disabled)",
								[ frappe.utils.escape_html(r.message["emails_not_sent_to"]) ]) );
						}

						if ((frappe.last_edited_communication[me.doc] || {})[me.key]) {
							delete frappe.last_edited_communication[me.doc][me.key];
						}
						if (cur_frm) {
							// clear input
							cur_frm.timeline.input && cur_frm.timeline.input.val("");
							cur_frm.reload_doc();
						}

						// try the success callback if it exists
						if (me.success) {
							try {
								me.success(r);
							} catch (e) {
								console.log(e);
							}
						}

					} else {
						frappe.msgprint(__("There were errors while sending email. Please try again."));

						// try the error callback if it exists
						if (me.error) {
							try {
								me.error(r);
							} catch (e) {
								console.log(e);
							}
						}
					}
				}
			});
		},

		is_print_letterhead_checked: function() {
			if (this.frm && $(this.frm.wrapper).find('.form-print-wrapper').is(':visible')){
				return $(this.frm.wrapper).find('.print-letterhead').prop('checked') ? 1 : 0;
			} else {
				return (frappe.model.get_doc(":Print Settings", "Print Settings") ||
					{ with_letterhead: 1 }).with_letterhead ? 1 : 0;
			}
		},

		setup_earlier_reply: function() {
			var fields = this.dialog.fields_dict;
			var signature = frappe.boot.user.email_signature || "";

			if(!frappe.utils.is_html(signature)) {
				signature = signature.replace(/\n/g, "<br>");
			}

			if(this.txt) {
				this.message = this.txt + (this.message ? ("<br><br>" + this.message) : "");
			} else {
				// saved draft in localStorage
				var ref = this.frm || {};
				var doctype = ref.doctype;
				var docname = ref.docname;
				if (doctype && docname) {
					this.message = localStorage.getItem(doctype + docname) || '';
				}
			}

			if(this.real_name) {
				this.message = '<p>'+__('Dear') +' '
					+ this.real_name + ",</p><!-- salutation-ends --><br>" + (this.message || "");
			}

			if(this.message && signature && this.message.includes(signature)) {
				signature = "";
			}

			var reply = (this.message || "") + (signature ? ("<br>" + signature) : "");
			var content = '';

			if (this.is_a_reply === 'undefined') {
				this.is_a_reply = true;
			}

			if (this.is_a_reply) {
				var last_email = this.last_email;

				if (!last_email) {
					last_email = this.frm && this.frm.timeline.get_last_email(true);
				}

				if (!last_email) { return; }

				var last_email_content = last_email.original_comment || last_email.content;

				// convert the email context to text as we are enclosing
				// this inside <blockquote>
				last_email_content = this.html2text(last_email_content).replace(/\n/g, '<br>');

				// clip last email for a maximum of 20k characters
				// to prevent the email content from getting too large
				if (last_email_content.length > 20 * 1024) {
					last_email_content += '<div>' + __('Message clipped') + '</div>' + last_email_content;
					last_email_content = last_email_content.slice(0, 20 * 1024);
				}

				var communication_date = last_email.communication_date || last_email.creation;
				content = "\n\t\t\t\t<div><br></div>\n\t\t\t\t" + reply + "\n\t\t\t\t" + (frappe.separator_element) + "\n\t\t\t\t<p>" + (__("On {0}, {1} wrote:", [frappe.datetime.global_date_format(communication_date) , last_email.sender])) + "</p>\n\t\t\t\t<blockquote>\n\t\t\t\t" + last_email_content + "\n\t\t\t\t</blockquote>\n\t\t\t";
			} else {
				content = "<div><br></div>" + reply;
			}
			fields.content.set_value(content);
		},

		html2text: function(html) {
			// convert HTML to text and try and preserve whitespace
			var d = document.createElement( 'div' );
			d.innerHTML = html.replace(/<\/div>/g, '<br></div>')  // replace end of blocks
				.replace(/<\/p>/g, '<br></p>') // replace end of paragraphs
				.replace(/<br>/g, '\n');
			var text = d.textContent;

			// replace multiple empty lines with just one
			return text.replace(/\n{3,}/g, '\n\n');
		}
	});

	frappe.views.TranslationManager = class TranslationManager {
		constructor(opts) {
			Object.assign(this, opts);
			this.make();
		}

		make() {
			var this$1 = this;

			this.data = [];
			this.dialog = new frappe.ui.Dialog({
				fields: this.get_fields(),
				title: __('Translate {0}', [this.df.label]),
				no_submit_on_enter: true,
				primary_action_label: __('Update Translations'),
				primary_action:
					function (values) { return this$1.update_translations(values)
						.then(function () {
							this$1.dialog.hide();

							this$1.data = [];

							frappe.msgprint({
								title: __('Success'),
								message: __('Successfully updated translations'),
								indicator: 'green'
							});
						}); }
			});

			this.get_translations_data()
				.then(function (data) {
					var ref;

					(ref = this$1.data).push.apply(ref, (data || []));
					this$1.dialog.refresh();
					this$1.dialog.show();
				});
		}

		get_fields() {
			var this$1 = this;

			var fields = [
				{
					label: __('Source Text'),
					fieldname: 'source',
					fieldtype: 'Data',
					read_only: 1,
					bold: 1,
					default: this.source_text
				},
				{
					label: __('Translations'),
					fieldname: 'translation_data',
					fieldtype: 'Table',
					fields: [
						{
							label: 'Language',
							fieldname: 'language',
							fieldtype: 'Link',
							options: 'Language',
							in_list_view: 1,
							columns: 3
						},
						{
							label: 'Translation',
							fieldname: 'translation',
							fieldtype: 'Text',
							in_list_view: 1,
							columns: 7
						}
					],
					data: this.data,
					get_data: function () {
						return this$1.data;
					}
				}
			];
			return fields;
		}

		get_translations_data() {
			return frappe.db.get_list('Translation', {
				fields: ['name', 'language', 'translated_text as translation'],
				filters: {
					source_text: strip_html(this.source_text)
				}
			});
		}

		update_translations(ref) {
			var source = ref.source;
			var translation_data = ref.translation_data; if ( translation_data === void 0 ) translation_data = [];

			var translation_dict = {};
			translation_data.map(function (row) {
				translation_dict[row.language] = row.translation;
			});

			return frappe.call({
				method: 'frappe.translate.update_translations_for_source',
				btn: this.dialog.get_primary_btn(),
				args: {
					source: source,
					translation_dict: translation_dict
				}
			}).fail(function () {
				frappe.msgprint({
					title: __('Something went wrong'),
					message: __('Please try again'),
					indicator: 'red'
				});
			});
		}
	};

	class WidgetDialog {
		constructor(opts) {
			Object.assign(this, opts);
			this.editing = Boolean(this.values && Object.keys(this.values).length);
		}

		make() {
			this.make_dialog();
			this.setup_dialog_events();
			this.dialog.show();

			this.editing && this.set_default_values();
		}

		make_dialog() {
			var this$1 = this;

			this.dialog = new frappe.ui.Dialog({
				title: this.get_title(),
				fields: this.get_fields(),
				primary_action: function (data) {
					data = this$1.process_data(data);

					if (!this$1.editing && !data.name) {
						data.name = (this$1.type) + "-" + (this$1.label) + "-" + (frappe.utils.get_random(20));
					}

					this$1.dialog.hide();
					this$1.primary_action(data);
				},
				primary_action_label: this.primary_action_label || __("Add"),
			});
		}

		get_title() {
			// DO NOT REMOVE: Comment to load translation
			// __("New Chart") __("New Shortcut") __("Edit Chart") __("Edit Shortcut")

			var action = this.editing ? "Edit" : "Add";
			var label = action = action + " " + frappe.model.unscrub(this.type);
			return __(label);
		}

		get_fields() {
			//
		}

		set_default_values() {
			return this.dialog.set_values(this.values);
		}

		process_data(data) {
			return data;
		}

		setup_dialog_events() {
			//
		}

		hide_field(fieldname) {
			this.dialog.set_df_property(fieldname, "hidden", true);
		}

		show_field(fieldname) {
			this.dialog.set_df_property(fieldname, "hidden", false);
		}

		setup_filter(doctype) {
			var this$1 = this;

			if (this.filter_group) {
				this.filter_group.wrapper.empty();
				delete this.filter_group;
			}

			var $loading = this.dialog.get_field("filter_area_loading").$wrapper;
			$("<span class=\"text-muted\">Loading Filters...</span>").appendTo($loading);

			this.filters = [];

			if (this.values && this.values.stats_filter) {
				var filters_json = new Function(("return " + (this.values.stats_filter)))();
				this.filters = Object.keys(filters_json).map(function (filter) {
					var val = filters_json[filter];
					return [this$1.values.link_to, filter, val[0], val[1], false];
				});
			}

			this.filter_group = new frappe.ui.FilterGroup({
				parent: this.dialog.get_field("filter_area").$wrapper,
				doctype: doctype,
				on_change: function () {},
			});

			frappe.model.with_doctype(doctype, function () {
				this$1.filter_group.add_filters_to_filter_group(this$1.filters);
				this$1.hide_field("filter_area_loading");
				this$1.show_field("filter_area");
			});
		}
	}

	class ChartDialog extends WidgetDialog {
		constructor(opts) {
			super(opts);
		}

		get_fields() {
			return [
				{
					fieldtype: "Link",
					fieldname: "chart_name",
					label: "Chart Name",
					options: "Dashboard Chart",
					reqd: 1,
				},
				{
					fieldtype: "Data",
					fieldname: "label",
					label: "Label",
				} ];
		}

		process_data(data) {
			data.label = data.label ? data.label : data.chart_name;
			return data;
		}
	}

	class ShortcutDialog extends WidgetDialog {
		constructor(opts) {
			super(opts);
		}

		hide_filters() {
			this.hide_field("count_section_break");
			this.hide_field("filters_section_break");
		}

		show_filters() {
			this.show_field("count_section_break");
			this.show_field("filters_section_break");
		}

		get_fields() {
			var this$1 = this;

			return [
				{
					fieldtype: "Select",
					fieldname: "type",
					label: "Type",
					reqd: 1,
					options: "DocType\nReport\nPage\nDashboard",
					onchange: function () {
						if (this$1.dialog.get_value("type") == "DocType") {
							this$1.dialog.fields_dict.link_to.get_query = function () {
								return { filters: { istable: false } };
							};
						} else {
							this$1.dialog.fields_dict.link_to.get_query = null;
						}
					},
				},
				{
					fieldtype: "Data",
					fieldname: "label",
					label: "Label",
				},
				{
					fieldtype: "Column Break",
					fieldname: "column_break_4",
				},
				{
					fieldtype: "Dynamic Link",
					fieldname: "link_to",
					label: "Link To",
					reqd: 1,
					options: "type",
					onchange: function () {
						if (this$1.dialog.get_value("type") == "DocType") {
							var doctype = this$1.dialog.get_value("link_to");
							if (doctype && frappe.boot.single_types.includes(doctype)) {
								this$1.hide_filters();
							} else if (doctype) {
								this$1.setup_filter(doctype);
								this$1.show_filters();
							}

							var views = ["List", "Report Builder", "Dashboard", "New"];
							if (frappe.boot.treeviews.includes(doctype)) { views.push("Tree"); }
							if (frappe.boot.calendars.includes(doctype)) { views.push("Calendar"); }

							this$1.dialog.set_df_property("doc_view", "options", views.join("\n"));

						} else {
							this$1.hide_filters();
						}
					}
				},
				{
					fieldtype: "Select",
					fieldname: "doc_view",
					label: "DocType View",
					options: "List\nReport Builder\nDashboard\nTree\nNew\nCalendar",
					description: "Which view of the associated DocType should this shortcut take you to?",
					default: "List",
					depends_on: function (state) {
						if (this$1.dialog) {
							var doctype = this$1.dialog.get_value("link_to");
							var is_single = frappe.boot.single_types.includes(doctype);
							return state.type == "DocType" && !is_single;
						}

						return false;
					}
				},
				{
					fieldtype: "Section Break",
					fieldname: "filters_section_break",
					label: "Count Filter",
					hidden: 1,
				},
				{
					fieldtype: "HTML",
					fieldname: "filter_area_loading",
				},
				{
					fieldtype: "HTML",
					fieldname: "filter_area",
					hidden: 1,
				},
				{
					fieldtype: "Section Break",
					fieldname: "count_section_break",
					label: "Count Customizations",
					hidden: 1,
				},
				{
					fieldtype: "Color",
					fieldname: "color",
					label: "Color",
				},
				{
					fieldtype: "Column Break",
					fieldname: "column_break_3",
				},
				{
					fieldtype: "Data",
					fieldname: "format",
					label: "Format",
					description: "For Example: {} Open",
				} ];
		}

		set_default_values() {
			var this$1 = this;

			super.set_default_values().then(function () {
				this$1.dialog.fields_dict.link_to.df.onchange();
			});
		}

		process_data(data) {
			var stats_filter = {};

			if (this.dialog.get_value("type") == "DocType" && this.filter_group) {
				var filters = this.filter_group.get_filters();

				if (filters.length) {
					filters.forEach(function (arr) {
						stats_filter[arr[1]] = [arr[2], arr[3]];
					});

					data.stats_filter = JSON.stringify(stats_filter);
				}
			}

			data.label = data.label
				? data.label
				: frappe.model.unscrub(data.link_to);

			return data;
		}
	}

	class NumberCardDialog extends WidgetDialog {
		constructor(opts) {
			super(opts);
		}

		get_fields() {
			var this$1 = this;

			var fields;
			fields = [
				{
					fieldtype: 'Select',
					label: 'Choose Existing Card or create New Card',
					fieldname: 'new_or_existing',
					options: ['New Card', 'Existing Card']
				},
				{
					fieldtype: 'Link',
					fieldname: 'card',
					label: 'Number Cards',
					options: 'Number Card',
					get_query: function () {
						return {
							'query': 'frappe.desk.doctype.number_card.number_card.get_cards_for_user',
							filters: {
								document_type: this$1.document_type,
							}
						};
					},
					depends_on: 'eval: doc.new_or_existing == "Existing Card"'
				},
				{
					fieldtype: 'Section Break',
					fieldname: 'sb_1',
					depends_on: 'eval: doc.new_or_existing == "New Card"'
				},
				{
					label: 'Label',
					fieldname: 'label',
					fieldtype: 'Data',
					mandatory_depends_on: 'eval: doc.new_or_existing == "New Card"'
				},
				{
					label: 'Doctype',
					fieldname: 'document_type',
					fieldtype: 'Link',
					options: 'DocType',
					onchange: function () {
						this$1.document_type = this$1.dialog.get_value("document_type");
						this$1.set_aggregate_function_fields(this$1.dialog.get_values());
						this$1.setup_filter(this$1.document_type);
					},
					hidden: 1
				},
				{
					label: 'Color',
					fieldname: 'color',
					fieldtype: 'Color'
				},
				{
					fieldtype: "Column Break",
					fieldname: "cb_1",
				},
				{
					label: 'Function',
					fieldname: 'function',
					fieldtype: 'Select',
					options: ['Count', 'Sum', 'Average', 'Minimum', 'Maximum'],
					mandatory_depends_on: 'eval: doc.new_or_existing == "New Card"'
				},
				{
					label: 'Function Based On',
					fieldname: 'aggregate_function_based_on',
					fieldtype: 'Select',
					depends_on: "eval: doc.function !== 'Count'",
					mandatory_depends_on: 'eval: doc.function !== "Count" && doc.new_or_existing == "New Card"'
				},
				{
					fieldtype: "Section Break",
					fieldname: "sb_1",
					label: 'Add Filters',
					depends_on: 'eval: doc.new_or_existing == "New Card"'
				},
				{
					fieldtype: "HTML",
					fieldname: "filter_area_loading",
				},
				{
					fieldtype: "HTML",
					fieldname: "filter_area",
					hidden: 1,
				},
				{
					fieldtype: "Section Break",
					fieldname: "sb_1",
				} ];

			return fields;
		}

		setup_dialog_events() {
			if (!this.document_type) {
				if (this.default_values['doctype']) {
					this.document_type = this.default_values['doctype'];
					this.setup_filter(this.default_values['doctype']);
					this.set_aggregate_function_fields();
				} else {
					this.show_field('document_type');
				}
			}
		}

		set_aggregate_function_fields() {
			var aggregate_function_fields = [];
			if (this.document_type) {
				frappe.get_meta(this.document_type).fields.map(function (df) {
					if (frappe.model.numeric_fieldtypes.includes(df.fieldtype)) {
						if (df.fieldtype == 'Currency') {
							if (!df.options || df.options !== 'Company:company:default_currency') {
								return;
							}
						}
						aggregate_function_fields.push({label: df.label, value: df.fieldname});
					}
				});
			}
			this.dialog.set_df_property('aggregate_function_based_on', 'options', aggregate_function_fields);
		}

		process_data(data) {
			if (data.new_or_existing == 'Existing Card') {
				data.name = data.card;
			}
			data.stats_filter = JSON.stringify(this.filter_group.get_filters());
			data.document_type = this.document_type;

			return data;
		}
	}

	function get_dialog_constructor(type) {
		var widget_map = {
			chart: ChartDialog,
			shortcut: ShortcutDialog,
			number_card: NumberCardDialog,
		};

		return widget_map[type] || WidgetDialog;
	}

	class Widget {
		constructor(opts) {
			Object.assign(this, opts);
			this.make();
		}

		refresh() {
			this.set_title();
			this.set_actions();
			this.set_body();
			this.setup_events();
		}

		get_config() {
			return {
				name: this.name,
				label: this.label
			};
		}

		customize(options) {
			var this$1 = this;

			this.in_customize_mode = true;
			this.action_area.empty();

			options.allow_delete &&
				this.add_custom_button(
					'<i class="fa fa-trash" aria-hidden="true"></i>',
					function () { return this$1.delete(); },
					"",
					("" + (__('Delete')))
				);

			options.allow_sorting &&
				this.add_custom_button(
					'<i class="fa fa-arrows" aria-hidden="true"></i>',
					null,
					"drag-handle"
				);

			if (options.allow_hiding) {
				if (this.hidden) {
					this.widget.removeClass("hidden");
					this.body.css("opacity", 0.5);
					this.title_field.css("opacity", 0.5);
					this.footer.css("opacity", 0.5);
				}
				var classname = this.hidden ? 'fa fa-eye' : 'fa fa-eye-slash';
				var title = this.hidden ? ("" + (__('Show'))) : ("" + (__('Hide')));
				this.add_custom_button(
					("<i class=\"" + classname + "\" aria-hidden=\"true\"></i>"),
					function () { return this$1.hide_or_show(); },
					"show-or-hide-button",
					title
				);

				this.show_or_hide_button = this.action_area.find(
					".show-or-hide-button"
				);
			}

			options.allow_edit &&
				this.add_custom_button(
					'<i class="fa fa-pencil" aria-hidden="true"></i>',
					function () { return this$1.edit(); }
				);

			if (options.allow_resize) {
				var title$1 = this.width == 'Full'? ("" + (__('Collapse'))) : ("" + (__('Expand')));
				this.add_custom_button(
					'<i class="fa fa-expand" aria-hidden="true"></i>',
					function () { return this$1.toggle_width(); },
					"resize-button",
					title$1
				);

				this.resize_button = this.action_area.find(
					".resize-button"
				);
			}
		}

		make() {
			this.make_widget();
			this.widget.appendTo(this.container);
		}

		make_widget() {
			this.widget = $(("<div class=\"widget " + (this.hidden ? "hidden" : "") + "\" data-widget-name=\"" + (this.name ? this.name : '') + "\">\n\t\t\t<div class=\"widget-head\">\n\t\t\t\t<div class=\"widget-title ellipsis\"></div>\n\t\t\t\t<div class=\"widget-control\"></div>\n\t\t\t</div>\n\t\t\t<div class=\"widget-body\">\n\t\t    </div>\n\t\t    <div class=\"widget-footer\">\n\t\t    </div>\n\t\t</div>"));

			this.title_field = this.widget.find(".widget-title");
			this.body = this.widget.find(".widget-body");
			this.action_area = this.widget.find(".widget-control");
			this.head = this.widget.find(".widget-head");
			this.footer = this.widget.find(".widget-footer");
			this.refresh();
		}

		set_title(max_chars) {
			this.title_field[0].innerHTML = max_chars ? frappe.ellipsis(this.label, max_chars) : this.label;
			if (max_chars) {
				this.title_field[0].setAttribute('title', this.label);
			}
		}

		add_custom_button(html, action, class_name, title) {
			if ( class_name === void 0 ) class_name = "";
			if ( title === void 0 ) title="";

			var button = $(
				("<button class=\"btn btn-default btn-xs " + class_name + "\" title=\"" + title + "\">" + html + "</button>")
			);
			button.click(function (event) {
				event.stopPropagation();
				action && action();
			});
			button.appendTo(this.action_area);
		}

		delete(animate) {
			var this$1 = this;
			if ( animate === void 0 ) animate=true;

			var remove_widget = function (setup_new) {
				this$1.widget.remove();
				this$1.options.on_delete && this$1.options.on_delete(this$1.name, setup_new);
			};

			if (animate) {
				this.widget.addClass("zoomOutDelete");
				// wait for animation
				setTimeout(function () {
					remove_widget(true);
				}, 300);
			} else {
				remove_widget(false);
			}
		}

		edit() {
			var this$1 = this;

			var dialog_class = get_dialog_constructor(this.widget_type);

			this.edit_dialog = new dialog_class({
				label: this.label,
				type: this.widget_type,
				values: this.get_config(),
				primary_action: function (data) {
					Object.assign(this$1, data);
					data.name = this$1.name;

					this$1.refresh();
				},
				primary_action_label: __("Save")
			});

			this.edit_dialog.make();
		}

		toggle_width() {
			if (this.width == 'Full') {
				this.widget.removeClass("full-width");
				this.width = null;
				this.refresh();
			} else {
				this.widget.addClass("full-width");
				this.width = 'Full';
				this.refresh();
			}

			var title = this.width == 'Full' ? ("" + (__('Collapse'))) : ("" + (__('Expand')));
			this.resize_button.attr('title', title);
		}

		hide_or_show() {
			if (!this.hidden) {
				this.body.css("opacity", 0.5);
				this.title_field.css("opacity", 0.5);
				this.footer.css("opacity", 0.5);
				this.hidden = true;
			} else {
				this.body.css("opacity", 1);
				this.title_field.css("opacity", 1);
				this.footer.css("opacity", 1);
				this.hidden = false;
			}
			this.show_or_hide_button.empty();

			var classname = this.hidden ? 'fa fa-eye' : 'fa fa-eye-slash';
			var title = this.hidden ? ("" + (__('Show'))) : ("" + (__('Hide')));

			$(("<i class=\"" + classname + "\" aria-hidden=\"true\" title=\"" + title + "\"></i>")).appendTo(
				this.show_or_hide_button
			);
		}

		setup_events() {
			//
		}

		set_actions() {
			//
		}

		set_body() {
			//
		}
	}

	function generate_route(item) {
		var type = item.type.toLowerCase();
		if (type === "doctype") {
			item.doctype = item.name;
		}
		var route = "";
		if (!item.route) {
			if (item.link) {
				route = strip(item.link, "#");
			} else if (type === "doctype") {
				if (frappe.model.is_single(item.doctype)) {
					route = "Form/" + item.doctype;
				} else {
					if (!item.doc_view) {
						if (frappe.model.is_tree(item.doctype)) {
							item.doc_view = "Tree";
						} else {
							item.doc_view = "List";
						}
					}
					switch (item.doc_view) {
						case "List":
							if (item.filters) {
								frappe.route_options = item.filters;
							}
							route = "List/" + item.doctype;
							break;
						case "Tree":
							route = "Tree/" + item.doctype;
							break;
						case "Report Builder":
							route = "List/" + item.doctype + "/Report";
							break;
						case "Dashboard":
							route = "List/" + item.doctype + "/Dashboard";
							break;
						case "New":
							route = "Form/" + item.doctype + "/New " + item.doctype;
							break;
						case "Calendar":
							route = "List/" + item.doctype + "/Calendar/Default";
							break;
						default:
							frappe.throw({ message: __("Not a valid DocType view:") + item.doc_view, title: __("Unknown View") });
							route = "";
					}
				}
			} else if (type === "report" && item.is_query_report) {
				route = "query-report/" + item.name;
			} else if (type === "report") {
				route = "List/" + item.doctype + "/Report/" + item.name;
			} else if (type === "page") {
				route = item.name;
			} else if (type === "dashboard") {
				route = "dashboard/" + item.name;
			}

			route = "#" + route;
		} else {
			route = item.route;
		}

		if (item.route_options) {
			route +=
				"?" +
				$.map(item.route_options, function (value, key) {
					return (
						encodeURIComponent(key) + "=" + encodeURIComponent(value)
					);
				}).join("&");
		}

		// if(type==="page" || type==="help" || type==="report" ||
		// (item.doctype && frappe.model.can_read(item.doctype))) {
		//     item.shown = true;
		// }
		return route;
	}

	var build_summary_item = function (summary) {
		var df = { fieldtype: summary.datatype };
		var doc = null;

		if (summary.datatype == "Currency") {
			df.options = "currency";
			doc = { currency: summary.currency };
		}

		var value = frappe.format(summary.value, df, null, doc);
		var indicator = summary.indicator ? ("indicator " + (summary.indicator.toLowerCase())) : '';

		return $(("<div class=\"summary-item\">\n\t\t<span class=\"summary-label small text-muted " + indicator + "\">" + (summary.label) + "</span>\n\t\t<h1 class=\"summary-value\">" + value + "</h1>\n\t</div>"));
	};

	function shorten_number(number, country) {
		country = (country == 'India') ? country : '';
		var number_system = get_number_system(country);
		var x = Math.abs(Math.round(number));
		for (var i = 0, list = number_system; i < list.length; i += 1) {
			var map = list[i];

			var condition = map.condition ? map.condition(x) : x >= map.divisor;
			if (condition) {
				return (number/map.divisor).toFixed(2) + ' ' + map.symbol;
			}
		}
		return number.toFixed();
	}

	function get_number_system(country) {
		var number_system_map = {
			'India':
				[{
					divisor: 1.0e+7,
					symbol: 'Cr'
				},
				{
					divisor: 1.0e+5,
					symbol: 'Lakh'
				}],
			'':
				[{
					divisor: 1.0e+12,
					symbol: 'T'
				},
				{
					divisor: 1.0e+9,
					symbol: 'B'
				},
				{
					divisor: 1.0e+6,
					symbol: 'M'
				},
				{
					divisor: 1.0e+3,
					symbol: 'K',
					condition: function (num) { return num.toFixed().length > 5; }
				}]
		};
		return number_system_map[country];
	}

	frappe.provide("frappe.dashboards");
	frappe.provide("frappe.dashboards.chart_sources");

	class ChartWidget extends Widget {
		constructor(opts) {
			super(opts);
			this.height = this.height || 240;
		}

		get_config() {
			return {
				name: this.name,
				chart_name: this.chart_name,
				label: this.label,
				hidden: this.hidden,
				width: this.width,
			};
		}

		refresh() {
			delete this.dashboard_chart;
			this.set_body();
			this.make_chart();
		}

		set_chart_title() {
			var max_chars = this.widget.width() < 500 ? 20 : 60;
			this.set_title(max_chars);
		}

		set_body() {
			this.widget.addClass("dashboard-widget-box");
			if (this.width == "Full") {
				this.widget.addClass("full-width");
			}
		}

		setup_container() {
			this.body.empty();

			if (this.chart_doc.type == 'Heatmap') {
				this.setup_heatmap_container();
			}

			this.loading = $(
				("<div class=\"chart-loading-state text-muted\" style=\"height: " + (this.height) + "px;\">" + (__(
					"Loading..."
				)) + "</div>")
			);
			this.loading.appendTo(this.body);

			this.empty = $(
				("<div class=\"chart-loading-state text-muted\" style=\"height: " + (this.height) + "px;\">" + (__(
					"No Data..."
				)) + "</div>")
			);
			this.empty.hide().appendTo(this.body);

			this.chart_wrapper = $("<div></div>");
			this.chart_wrapper.appendTo(this.body);

			this.$heatmap_legend = null;
			this.set_chart_title();
		}

		setup_heatmap_container() {
			this.widget.addClass('heatmap-chart');
			this.widget.removeClass('full-width').addClass('full-width');
			this.width = 'Full';
		}

		set_summary() {
			var this$1 = this;

			if (!this.$summary) {
				this.$summary = $("<div class=\"report-summary\"></div>").hide();
				this.head.after(this.$summary);
			} else {
				this.$summary.empty();
			}

			this.summary.forEach(function (summary) {
				build_summary_item(summary).appendTo(this$1.$summary);
			});
			this.summary.length && this.$summary.show();
		}

		make_chart() {
			var this$1 = this;

			this.get_settings().then(function () {
				if (!this$1.settings) {
					this$1.deleted = true;
					this$1.widget.remove();
					return;
				}

				if (!this$1.chart_settings) {
					this$1.chart_settings = {};
				}
				this$1.setup_container();
				if (!this$1.in_customize_mode) {
					this$1.action_area.empty();
					this$1.prepare_chart_actions();
					this$1.setup_filter_button();

					if (
						this$1.chart_doc.timeseries &&
						this$1.chart_doc.chart_type !== "Custom"
					) {
						this$1.render_time_series_filters();
					}
				}
				frappe.run_serially([
					function () { return this$1.prepare_chart_object(); },
					function () { return this$1.fetch_and_update_chart(); } ]);
			});
		}

		render_time_series_filters() {
			var filters = this.get_time_series_filters();
			frappe.dashboard_utils.render_chart_filters(
				filters,
				"chart-actions",
				this.action_area,
				0
			);
		}

		get_time_series_filters() {
			var this$1 = this;

			var filters;
			if (this.chart_doc.type == 'Heatmap') {
				filters = [{
					label: this.chart_settings.heatmap_year || this.chart_doc.heatmap_year,
					options: frappe.dashboard_utils.get_years_since_creation(frappe.boot.user.creation),
					action: function (selected_item) {
						this$1.selected_heatmap_year = selected_item;
						this$1.save_chart_config_for_user({'heatmap_year': this$1.selected_heatmap_year});
						this$1.fetch_and_update_chart();
					}
				}];
			} else {
				filters = [
					{
						label: this.chart_settings.timespan || this.chart_doc.timespan,
						options: [
							"Select Date Range",
							"Last Year",
							"Last Quarter",
							"Last Month",
							"Last Week"
						],
						action: function (selected_item) {
							this$1.selected_timespan = selected_item;

							if (this$1.selected_timespan === "Select Date Range") {
								this$1.render_date_range_fields();
							} else {
								this$1.selected_from_date = null;
								this$1.selected_to_date = null;
								if (this$1.date_field_wrapper) {
									this$1.date_field_wrapper.hide();

									// Title maybe hidden becuase of date range fields
									// in half width chart
									this$1.title_field.show();
									this$1.head.css('flex-direction', "row");
								}

								this$1.save_chart_config_for_user({
									'timespan': this$1.selected_timespan,
									'from_date': null,
									'to_date': null

								});
								this$1.fetch_and_update_chart();
							}
						}
					},
					{
						label: this.chart_settings.time_interval || this.chart_doc.time_interval,
						options: ["Yearly", "Quarterly", "Monthly", "Weekly", "Daily"],
						action: function (selected_item) {
							this$1.selected_time_interval = selected_item;
							this$1.save_chart_config_for_user({'time_interval': this$1.selected_time_interval});
							this$1.fetch_and_update_chart();
						}
					}
				];
			}
			return filters;
		}

		fetch_and_update_chart() {
			var this$1 = this;

			this.args = {
				timespan: this.selected_timespan || this.chart_settings.timespan,
				time_interval: this.selected_time_interval || this.chart_settings.time_interval,
				from_date: this.selected_from_date || this.chart_settings.from_date,
				to_date: this.selected_to_date || this.chart_settings.to_date,
				heatmap_year: this.selected_heatmap_year || this.chart_settings.heatmap_year,
			};

			this.fetch(this.filters, true, this.args).then(function (data) {
				if (this$1.chart_doc.chart_type == "Report") {
					this$1.summary = data.report_summary;
					data = this$1.get_report_chart_data(data);
				}

				this$1.update_chart_object();
				this$1.data = data;
				this$1.render();
			});
		}

		render_date_range_fields() {
			var this$1 = this;

			if (
				!this.date_field_wrapper ||
				!this.date_field_wrapper.is(":visible")
			) {
				this.date_field_wrapper = $(
					"<div class=\"dashboard-date-field pull-right\"></div>"
				).appendTo(this.action_area);

				if (this.width != "Full" && this.widget.width() < 700) {
					this.title_field.hide();
					this.head.css('flex-direction', "row-reverse");
				}

				this.date_range_field = frappe.ui.form.make_control({
					df: {
						fieldtype: "DateRange",
						fieldname: "from_date",
						placeholder: "Date Range",
						input_class: "input-xs",
						default: [this.chart_settings.from_date, this.chart_settings.to_date],
						reqd: 1,
						change: function () {
							var selected_date_range = this$1.date_range_field.get_value();
							this$1.selected_from_date = selected_date_range[0];
							this$1.selected_to_date = selected_date_range[1];

							if (selected_date_range && selected_date_range.length == 2) {
								this$1.save_chart_config_for_user({
									'timespan': this$1.selected_timespan,
									'from_date': this$1.selected_from_date,
									'to_date': this$1.selected_to_date,
								});
								this$1.fetch_and_update_chart();
							}
						}
					},
					parent: this.date_field_wrapper,
					render_input: 1
				});
			}
		}

		get_report_chart_data(result) {
			if (result.chart && this.chart_doc.use_report_chart) {
				return result.chart.data;
			} else {
				var y_fields = [];
				this.chart_doc.y_axis.map(function (field) {
					y_fields.push(field.y_field);
				});

				var chart_fields = {
					y_fields: y_fields,
					x_field: this.chart_doc.x_field,
					chart_type: this.chart_doc.type,
					color: this.chart_doc.color
				};
				var columns = result.columns.map(function (col) {
					return frappe.report_utils.prepare_field_from_column(col);
				});

				var data = frappe.report_utils.make_chart_options(
					columns,
					result,
					chart_fields
				).data;
				return data;
			}
		}

		prepare_chart_actions() {
			var this$1 = this;

			var actions = [
				{
					label: __("Refresh"),
					action: "action-refresh",
					handler: function () {
						delete this$1.dashboard_chart;
						this$1.make_chart();
					}
				},
				{
					label: __("Edit"),
					action: "action-edit",
					handler: function () {
						frappe.set_route(
							"Form",
							"Dashboard Chart",
							this$1.chart_doc.name
						);
					}
				},
				{
					label: __("Reset Chart"),
					action: "action-reset",
					handler: function () {
						this$1.reset_chart();
						delete this$1.dashboard_chart;
						this$1.make_chart();
					}
				}
			];

			if (this.chart_doc.document_type) {
				actions.push({
					label: __("{0} List", [this.chart_doc.document_type]),
					action: "action-list",
					handler: function () {
						frappe.set_route("List", this$1.chart_doc.document_type);
					}
				});
			} else if (this.chart_doc.chart_type === "Report") {
				actions.push({
					label: __("{0} Report", [this.chart_doc.report_name]),
					action: "action-list",
					handler: function () {
						frappe.set_route(
							"query-report",
							this$1.chart_doc.report_name
						);
					}
				});
			}
			this.set_chart_actions(actions);
		}

		setup_filter_button() {
			var this$1 = this;

			this.is_document_type =
				this.chart_doc.chart_type !== "Report" &&
				this.chart_doc.chart_type !== "Custom";
			this.filter_button = $(
				("<div class=\"filter-chart btn btn-default btn-xs pull-right\">" + (__(
					"Filter"
				)) + "</div>")
			);
			this.filter_button.appendTo(this.action_area);

			this.filter_button.on("click", function () {
				var fields;

				frappe.dashboard_utils
					.get_filters_for_chart_type(this$1.chart_doc)
					.then(function (filters) {
						if (!this$1.is_document_type) {
							if (!filters) {
								fields = [
									{
										fieldtype: "HTML",
										options: __("No Filters Set")
									}
								];
							} else {
								fields = filters
									.filter(function (df) { return df.fieldname; })
									.map(function (df) {
										Object.assign(df, df.dashboard_config || {});
										return df;
									});
							}
						} else {
							fields = [
								{
									fieldtype: "HTML",
									fieldname: "filter_area"
								}
							];
						}

						this$1.setup_filter_dialog(fields);
					});
			});
		}

		setup_filter_dialog(fields) {
			var me = this;
			var dialog = new frappe.ui.Dialog({
				title: __("Set Filters for {0}", [this.chart_doc.chart_name]),
				fields: fields,
				primary_action: function() {
					var values = this.get_values();
					if (values) {
						this.hide();
						if (me.is_document_type) {
							me.filters = me.filter_group.get_filters();
						} else {
							me.filters = values;
						}
						me.save_chart_config_for_user({'filters': me.filters});
						me.fetch_and_update_chart();
					}
				},
				primary_action_label: "Set"
			});

			if (this.is_document_type) {
				this.create_filter_group_and_add_filters(
					dialog.get_field("filter_area").$wrapper
				);
			}

			dialog.show();

			if (this.chart_doc.chart_type == 'Report') {
				//Set query report object so that it can be used while fetching filter values in the report
				frappe.query_report = new frappe.views.QueryReport({'filters': dialog.fields_list});
				frappe.query_reports[this.chart_doc.report_name].onload
						&& frappe.query_reports[this.chart_doc.report_name].onload(frappe.query_report);
			}
			dialog.set_values(this.filters);
		}

		reset_chart() {
			this.save_chart_config_for_user(null, 1);
			this.chart_settings = {};
			this.filters = null;
			this.selected_time_interval = null;
			this.selected_timespan = null;
			this.selected_heatmap_year = null;
		}

		save_chart_config_for_user(config, reset) {
			if ( reset === void 0 ) reset=0;

			Object.assign(this.chart_settings, config);
			frappe.xcall('frappe.desk.doctype.dashboard_settings.dashboard_settings.save_chart_config', {
				'reset': reset,
				'config': this.chart_settings,
				'chart_name': this.chart_doc.chart_name
			});
		}

		create_filter_group_and_add_filters(parent) {
			var this$1 = this;

			this.filter_group = new frappe.ui.FilterGroup({
				parent: parent,
				doctype: this.chart_doc.document_type,
				on_change: function () {}
			});

			frappe.model.with_doctype(this.chart_doc.document_type, function () {
				this$1.filter_group.add_filters_to_filter_group(this$1.filters);
			});
		}

		set_chart_actions(actions) {
			/* eslint-disable indent */
			this.chart_actions = $(("<div class=\"chart-actions dropdown pull-right\">\n\t\t\t<a class=\"dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n\t\t\t\t<button class=\"btn btn-default btn-xs\"><span class=\"caret\"></span></button>\n\t\t\t</a>\n\t\t\t<ul class=\"dropdown-menu\" style=\"max-height: 300px; overflow-y: auto;\">\n\t\t\t\t" + (actions
						.map(
							function (action) { return ("<li><a data-action=\"" + (action.action) + "\">" + (action.label) + "</a></li>"); }
						)
						.join("")) + "\n\t\t\t</ul>\n\t\t</div>\n\t\t"));
			/* eslint-enable indent */

			this.chart_actions.find("a[data-action]").each(function (i, o) {
				var action = o.dataset.action;
				$(o).click(actions.find(function (a) { return a.action === action; }));
			});
			this.chart_actions.appendTo(this.action_area);
		}

		fetch(filters, refresh, args) {
			if ( refresh === void 0 ) refresh = false;

			var method = this.settings.method;

			if (this.chart_doc.chart_type == "Report") {
				args = {
					report_name: this.chart_doc.report_name,
					filters: filters,
					ignore_prepared_report: 1
				};
			} else {
				args = {
					chart_name: this.chart_doc.name,
					filters: filters,
					refresh: refresh ? 1 : 0,
					time_interval: args && args.time_interval ? args.time_interval : null,
					timespan: args && args.timespan ? args.timespan : null,
					from_date: args && args.from_date ? args.from_date : null,
					to_date: args && args.to_date ? args.to_date : null,
					heatmap_year: args && args.heatmap_year ?  args.heatmap_year : null,
				};
			}
			return frappe.xcall(method, args);
		}

		render() {
			if (!this.data || !this.data.labels || !Object.keys(this.data).length) {
				this.chart_wrapper.hide();
				this.loading.hide();
				this.$summary && this.$summary.hide();
				this.empty.show();
			} else {
				this.loading.hide();
				this.empty.hide();
				this.chart_wrapper.show();

				var chart_args = this.get_chart_args();

				if (!this.dashboard_chart) {
					this.dashboard_chart = new frappe.Chart(
						this.chart_wrapper[0],
						chart_args
					);
				} else {
					this.dashboard_chart.update(this.data);
				}

				this.width == "Full" && this.summary && this.set_summary();
				this.chart_doc.type == 'Heatmap' && this.render_heatmap_legend();
			}
		}

		get_chart_args() {
			var colors = this.get_chart_colors();

			var chart_type_map = {
				Line: "line",
				Bar: "bar",
				Percentage: "percentage",
				Pie: "pie",
				Donut: "donut",
				Heatmap: "heatmap"
			};

			var chart_args = {
				data: this.data,
				type: chart_type_map[this.chart_doc.type],
				colors: colors,
				height: this.height,
				axisOptions: {
					xIsSeries: this.chart_doc.timeseries,
					shortenYAxisNumbers: 1
				}
			};

			if (this.chart_doc.type == "Heatmap") {
				var heatmap_year = parseInt(this.selected_heatmap_year || this.chart_settings.heatmap_year || this.chart_doc.heatmap_year);
				chart_args.data.start = new Date((heatmap_year + "-01-01"));
				chart_args.data.end = new Date(((heatmap_year+1) + "-01-01"));
			}

			var set_options = function (options) {
				var custom_options = JSON.parse(options);
				for (var key in custom_options) {
					chart_args[key] = custom_options[key];
				}
			};

			if (this.custom_options) {
				set_options(this.custom_options);
			}

			if (this.chart_doc.custom_options) {
				set_options(this.chart_doc.custom_options);
			}

			return chart_args;
		}

		get_chart_colors() {
			var colors = [];
			if (this.chart_doc.y_axis.length) {
				this.chart_doc.y_axis.map(function (field) {
					colors.push(field.color);
				});
			} else if (["Line", "Bar"].includes(this.chart_doc.type)) {
				colors = [this.chart_doc.color || []];
			}  else if (this.chart_doc.type == "Heatmap") {
				colors = [];
			}

			return colors;
		}

		render_heatmap_legend() {
			if (!this.$heatmap_legend && this.widget.width() > 991) {
				this.$heatmap_legend =
					$(("\n\t\t\t\t<div class=\"heatmap-legend\">\n\t\t\t\t\t<ul class=\"legend-colors\">\n\t\t\t\t\t\t<li style=\"background-color: #ebedf0\"></li>\n\t\t\t\t\t\t<li style=\"background-color: #c6e48b\"></li>\n\t\t\t\t\t\t<li style=\"background-color: #7bc96f\"></li>\n\t\t\t\t\t\t<li style=\"background-color: #239a3b\"></li>\n\t\t\t\t\t\t<li style=\"background-color: #196127\"></li>\n\t\t\t\t\t</ul>\n\t\t\t\t\t<div class=\"legend-label\">\n\t\t\t\t\t\t<div style=\"margin-bottom: 45px\">" + (__("Less")) + "</div>\n\t\t\t\t\t\t<div>" + (__("More")) + "</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t"));
				this.body.append(this.$heatmap_legend);
			}
		}

		update_last_synced() {
			var last_synced_text = __("Last synced {0}", [comment_when(this.chart_doc.last_synced_on)]);
			this.footer.html(last_synced_text);
		}

		update_chart_object() {
			var this$1 = this;

			frappe.db.get_doc("Dashboard Chart", this.chart_doc.name).then(function (doc) {
				this$1.chart_doc = doc;
				this$1.prepare_chart_object();
				this$1.update_last_synced();
			});
		}

		prepare_chart_object() {
			if (this.chart_doc.type == 'Heatmap' && !this.chart_doc.heatmap_year) {
				this.chart_doc.heatmap_year = frappe.dashboard_utils.get_year(frappe.datetime.now_date());
			}

			return this.set_chart_filters();
		}

		set_chart_filters() {
			var this$1 = this;

			var user_saved_filters = this.chart_settings.filters || null;
			var chart_saved_filters = frappe.dashboard_utils.get_all_filters(this.chart_doc);

			if (this.chart_doc.chart_type == 'Report') {
				return frappe.dashboard_utils
					.get_filters_for_chart_type(this.chart_doc).then(function (filters) {
						chart_saved_filters = this$1.update_default_date_filters(filters, chart_saved_filters);
						this$1.filters =
							user_saved_filters || this$1.filters || chart_saved_filters;
					});
			} else {
				this.filters =
					user_saved_filters || this.filters || chart_saved_filters;
				return Promise.resolve();
			}
		}

		update_default_date_filters(report_filters, chart_filters) {
			if (report_filters) {
				report_filters.map(function (f) {
					if (['Date', 'DateRange'].includes(f.fieldtype) && f.default) {
						if (f.reqd || chart_filters[f.fieldname]) {
							chart_filters[f.fieldname] = f.default;
						}
					}
				});
			}
			return chart_filters;
		}

		get_settings() {
			var this$1 = this;

			return frappe.model
				.with_doc("Dashboard Chart", this.chart_name)
				.then(function (chart_doc) {
					if (chart_doc) {
						this$1.chart_doc = chart_doc;
						if (this$1.chart_doc.chart_type == "Custom") {
							// custom source
							if (
								frappe.dashboards.chart_sources[this$1.chart_doc.source]
							) {
								this$1.settings =
									frappe.dashboards.chart_sources[
										this$1.chart_doc.source
									];
								return Promise.resolve();
							} else {
								var method =
									"frappe.desk.doctype.dashboard_chart_source.dashboard_chart_source.get_config";
								return frappe
									.xcall(method, { name: this$1.chart_doc.source })
									.then(function (config) {
										frappe.dom.eval(config);
										this$1.settings =
											frappe.dashboards.chart_sources[
												this$1.chart_doc.source
											];
									});
							}
						} else if (this$1.chart_doc.chart_type == "Report") {
							this$1.settings = {
								method: "frappe.desk.query_report.run"
							};
							return Promise.resolve();
						} else {
							this$1.settings = {
								method: "frappe.desk.doctype.dashboard_chart.dashboard_chart.get"
							};
							return Promise.resolve();
						}
					}
				});
		}
	}

	class ShortcutWidget extends Widget {
		constructor(opts) {
			super(opts);
		}

		get_config() {
			return {
				name: this.name,
				icon: this.icon,
				label: this.label,
				format: this.format,
				link_to: this.link_to,
				doc_view: this.doc_view,
				color: this.color,
				restrict_to_domain: this.restrict_to_domain,
				stats_filter: this.stats_filter,
				type: this.type,
			};
		}

		setup_events() {
			var this$1 = this;

			this.widget.click(function () {
				if (this$1.in_customize_mode) { return; }

				var route = generate_route({
					route: this$1.route,
					name: this$1.link_to,
					type: this$1.type,
					is_query_report: this$1.is_query_report,
					doctype: this$1.ref_doctype,
					doc_view: this$1.doc_view
				});

				var filters = this$1.get_doctype_filter();
				if (this$1.type == "DocType" && filters) {
					frappe.route_options = filters;
				}
				frappe.set_route(route);
			});
		}

		set_actions() {
			var this$1 = this;

			if (this.in_customize_mode) { return; }

			this.widget.addClass("shortcut-widget-box");

			var filters = this.get_doctype_filter();
			if (this.type == "DocType" && filters) {
				frappe.db
					.count(this.link_to, {
						filters: filters,
					})
					.then(function (count) { return this$1.set_count(count); });
			}
		}

		get_doctype_filter() {
			var count_filter = new Function(("return " + (this.stats_filter)))();
			if (count_filter) {
				return count_filter;
			}

			return null;
		}

		set_title() {
			if (this.icon) {
				this.title_field[0].innerHTML = "<div>\n\t\t\t\t<i class=\"" + (this.icon) + "\" style=\"\"></i>\n\t\t\t\t" + (this.label || this.name) + "\n\t\t\t\t</div>";
			} else {
				super.set_title();
			}
		}

		set_count(count) {
			var this$1 = this;

			var get_label = function () {
				if (this$1.format) {
					return this$1.format.replace(/{}/g, count);
				}
				return count;
			};

			this.action_area.empty();
			var label = get_label();
			var buttons = $(("<div class=\"small pill\">" + label + "</div>"));
			if (this.color) {
				var bg_color = count ? this.color: '#EEEEEE';
				var text_color = count ? frappe.ui.color.get_contrast_color(bg_color): '#8D99A6';
				buttons.css("background-color", bg_color);
				buttons.css("color", text_color);
			}

			buttons.appendTo(this.action_area);
		}
	}

	class LinksWidget extends Widget {
		constructor(opts) {
			super(opts);
		}

		get_config() {
			return {
				name: this.name,
				links: JSON.stringify(this.links),
				label: this.label,
				hidden: this.hidden,
			};
		}

		set_body() {
			var this$1 = this;

			this.options = {};
			this.options.links = this.links;
			this.widget.addClass("links-widget-box");
			var is_link_disabled = function (item) {
				return item.dependencies && item.incomplete_dependencies;
			};
			var disabled_dependent = function (item) {
				return is_link_disabled(item) ? "disabled-link" : "";
			};

			var get_indicator_color = function (item) {
				if (item.open_count) {
					return "red";
				}
				if (item.onboard) {
					return item.count ? "blue" : "orange";
				}
				return "grey";
			};

			var get_link_for_item = function (item) {
				if (is_link_disabled(item)) {
					return ("<span class=\"link-content ellipsis disabled-link\">" + (item.label ? item.label : item.name) + "</span>\n\t\t\t\t\t\t<div class=\"module-link-popover popover fade top in\" role=\"tooltip\" style=\"display: none;\">\n\t\t\t\t\t\t\t<div class=\"arrow\"></div>\n\t\t\t\t\t\t\t<h3 class=\"popover-title\" style=\"display: none;\"></h3>\n\t\t\t\t\t\t\t<div class=\"popover-content\" style=\"padding: 12px;\">\n\t\t\t\t\t\t\t\t<div class=\"small text-muted\">" + (__("You need to create these first: ")) + "</div>\n\t\t \t\t\t\t\t\t<div class=\"small\">" + (item.incomplete_dependencies.join(", ")) + "</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>");
				}

				if (item.youtube_id)
					{ return ("<span class=\"link-content help-video-link ellipsis\" data-youtubeid=\"" + (item.youtube_id) + "\">\n\t\t\t\t\t\t" + (item.label ? item.label : item.name) + "</span>"); }

				return ("<a data-route=\"" + (generate_route(item)) + "\" class=\"link-content ellipsis\">\n\t\t\t\t\t" + (item.label ? item.label : item.name) + "</a>");
			};

			this.link_list = this.links.map(function (item) {
				return $(("<div class=\"link-item flush-top small " + (item.onboard ? "onboard-spotlight" : "") + " " + (disabled_dependent(item)) + "\" type=\"" + (item.type) + "\">\n\t\t\t\t\t<span class=\"indicator " + (get_indicator_color(item)) + "\"></span>\n\t\t\t\t\t" + (get_link_for_item(item)) + "\n\t\t\t</div>"));
			});

			this.link_list.forEach(function (link) { return link.appendTo(this$1.body); });
		}

		setup_events() {
			var this$1 = this;

			this.link_list.forEach(function (link) {
				// Bind Popver Event
				var link_label = link.find(".link-content");

				if (link.hasClass("disabled-link")) {
					var popover = link.find(".module-link-popover");

					link_label.mouseover(function () {
						if (this$1.in_customize_mode) { return; }
						popover.show();
					});
					link_label.mouseout(function () { return popover.hide(); });
				} else {
					link_label.click(function (event) {
						if (this$1.in_customize_mode) { return; }

						if (link_label.hasClass("help-video-link")) {
							var yt_id = event.target.dataset.youtubeid;
							frappe.help.show_video(yt_id);
						} else {
							var route = event.target.dataset.route;
							frappe.set_route(route);
						}
					});
				}
			});
		}
	}

	class OnboardingWidget extends Widget {
		constructor(opts) {
			super(opts);
		}

		make_body() {
			var this$1 = this;

			this.steps.forEach(function (step) {
				this$1.add_step(step);
			});
		}

		add_step(step) {
			var this$1 = this;

			// Make Step
			var status = "";
			var icon_class = "fa-circle-o";

			if (step.is_skipped) {
				status = "skipped";
				icon_class = "fa-check-circle-o";
			}

			if (step.is_complete) {
				status = "complete";
				icon_class = "fa-check-circle-o";
			}

			var $step = $(("<div class=\"onboarding-step " + status + "\">\n\t\t\t\t<i class=\"fa " + icon_class + "\" aria-hidden=\"true\" title=\"" + status + "\"></i>\n\t\t\t\t<span id=\"title\">" + (step.title) + "</span>\n\t\t\t</div>"));

			step.$step = $step;

			// Add skip button
			if (!step.is_mandatory && !step.is_complete) {
				var skip_html = $(
					"<span class=\"ml-5 small text-muted step-skip\">Skip</span>"
				);

				skip_html.appendTo($step);
				skip_html.on("click", function () {
					this$1.skip_step(step);
					event.stopPropagation();
				});
			}

			// Setup actions
			var actions = {
				"Watch Video": function () { return this$1.show_video(step); },
				"Create Entry": function () {
					if (step.is_complete) {
						frappe.set_route(("#List/" + (step.reference_document)));
					} else {
						if (step.show_full_form) {
							this$1.create_entry(step);
						} else {
							this$1.show_quick_entry(step);
						}
					}
				},
				"Show Form Tour": function () { return this$1.show_form_tour(step); },
				"Update Settings": function () { return this$1.update_settings(step); },
				"View Report": function () { return this$1.open_report(step); },
				"Go to Page": function () { return this$1.go_to_page(step); },
			};

			$step.find("#title").on("click", actions[step.action]);

			$step.appendTo(this.body);
			return $step;
		}

		go_to_page(step) {
			frappe.set_route(step.path).then(function () {
				if (step.callback_message) {
					var msg_dialog = frappe.msgprint({
						message: __(step.callback_message),
						title: __(step.callback_title),
						primary_action: {
							action: function () {
								msg_dialog.hide();
							},
							label: function () { return __("Continue"); },
						},
						wide: true,
					});
				}
			});
		}

		open_report(step) {
			var this$1 = this;

			var route = generate_route({
				name: step.reference_report,
				type: "report",
				is_query_report: ["Query Report", "Script Report"].includes(
					step.report_type
				),
				doctype: step.report_reference_doctype,
			});

			var current_route = frappe.get_route();

			frappe.set_route(route).then(function () {
				var msg_dialog = frappe.msgprint({
					message: __(step.report_description),
					title: __(step.reference_report),
					primary_action: {
						action: function () {
							frappe.set_route(current_route).then(function () {
								this$1.mark_complete(step);
							});
							msg_dialog.hide();
						},
						label: function () { return __("Continue"); },
					},
					secondary_action: {
						action: function () {
							msg_dialog.hide();
							frappe.set_route(current_route).then(function () {
								this$1.mark_complete(step);
							});
						},
						label: __("Go Back"),
					},
				});

				frappe.msg_dialog.custom_onhide = function () { return this$1.mark_complete(step); };
			});
		}

		show_form_tour(step) {
			var this$1 = this;

			var route;
			if (step.is_single) {
				route = "Form/" + (step.reference_document);
			} else {
				route = "Form/" + (step.reference_document) + "/" + (__('New')) + " " + (__(step.reference_document)) + " 1";
			}

			var current_route = frappe.get_route();

			frappe.route_hooks = {};
			frappe.route_hooks.after_load = function (frm) {
				frm.show_tour(function () {
					var msg_dialog = frappe.msgprint({
						message: __("Let's take you back to onboarding"),
						title: __("Great Job"),
						primary_action: {
							action: function () {
								frappe.set_route(current_route).then(function () {
									this$1.mark_complete(step);
								});
								msg_dialog.hide();
							},
							label: function () { return __("Continue"); },
						},
					});
				});
			};

			frappe.set_route(route);
		}

		update_settings(step) {
			var this$1 = this;

			var current_route = frappe.get_route();

			frappe.route_hooks = {};
			frappe.route_hooks.after_load = function (frm) {
				frm.scroll_to_field(step.field);
				frm.doc.__unsaved = true;
			};

			frappe.route_hooks.after_save = function (frm) {
				var success = false;
				var args = {};

				var value = frm.doc[step.field];
				var custom_onhide = null;

				if (value && step.value_to_validate == "%") { success = true; }
				if (value == step.value_to_validate) { success = true; }
				if (cstr(value) == cstr(step.value_to_validate)) { success = true; }

				if (success) {
					args.message = __("Let's take you back to onboarding");
					args.title = __("Looks Great");
					args.primary_action = {
						action: function () {
							frappe.set_route(current_route).then(function () {
								this$1.mark_complete(step);
							});
						},
						label: __("Continue"),
					};

					custom_onhide = function () { return args.primary_action.action(); };
				} else {
					args.message = __("Looks like you didn't change the value");
					args.title = __("Oops");
					args.secondary_action = {
						action: function () { return frappe.set_route(current_route); },
						label: __("Go Back"),
					};

					if (!step.is_mandatory) {
						args.primary_action = {
							action: function () {
								frappe.set_route(current_route).then(function () {
									setTimeout(function () {
										this$1.skip_step(step);
									}, 300);
								});
							},
							label: __("Skip Step"),
						};
					}

					custom_onhide = function () { return args.secondary_action.action(); };
				}

				frappe.msgprint(args);
				frappe.msg_dialog.custom_onhide = function () { return custom_onhide(); };
			};

			frappe.set_route("Form", step.reference_document);
		}

		create_entry(step) {
			var this$1 = this;

			var current_route = frappe.get_route();

			frappe.route_hooks = {};
			var callback = function () {
				frappe.msgprint({
					message: __("You're doing great, let's take you back to the onboarding page."),
					title: __("Good Work 🎉"),
					primary_action: {
						action: function () {
							frappe.set_route(current_route).then(function () {
								this$1.mark_complete(step);
							});
						},
						label: __("Continue"),
					},
				});

				frappe.msg_dialog.custom_onhide = function () {
					this$1.mark_complete(step);
				};
			};

			if (step.is_submittable) {
				frappe.route_hooks.after_save = function () {
					frappe.msgprint({
						message: __("Submit this document to complete this step."),
						title: __("Great")
					});
				};
				frappe.route_hooks.after_submit = callback;
			} else {
				frappe.route_hooks.after_save = callback;
			}

			frappe.set_route(("Form/" + (step.reference_document) + "/" + (__('New')) + " " + (__(step.reference_document)) + " 1"));
		}

		show_quick_entry(step) {
			var this$1 = this;

			var current_route = frappe.get_route_str();
			frappe.ui.form.make_quick_entry(
				step.reference_document,
				function () {
					if (frappe.get_route_str() != current_route) {
						var success_dialog = frappe.msgprint({
							message: __("Let's take you back to onboarding"),
							title: __("Looks Great"),
							primary_action: {
								action: function () {
									success_dialog.hide();
									frappe.set_route(current_route).then(function () {
										this$1.mark_complete(step);
									});
								},
								label: __("Continue"),
							},
						});

						frappe.msg_dialog.custom_onhide = function () {
							frappe.set_route(current_route).then(function () {
								this$1.mark_complete(step);
							});
						};
					} else {
						frappe.msgprint({
							message: __("You may continue with onboarding"),
							title: __("Looks Great")
						});
						this$1.mark_complete(step);
					}
				},
				null,
				null,
				true
			);
		}

		show_video(step) {
			frappe.help.show_video(step.video_url, step.title);
			this.mark_complete(step);
		}

		mark_complete(step) {
			var $step = step.$step;

			var callback = function () {
				step.is_complete = true;
				$step.removeClass("skipped");
				$step.addClass("complete");
			};

			this.update_step_status(step, "is_complete", 1, callback);
		}

		skip_step(step) {
			var $step = step.$step;

			var callback = function () {
				step.is_skipped = true;
				$step.removeClass("complete");
				$step.addClass("skipped");
			};

			this.update_step_status(step, "is_skipped", 1, callback);
		}

		update_step_status(step, status, value, callback) {
			var this$1 = this;

			var icon_class = {
				is_complete: "fa-check-circle-o",
				is_skipped: "fa-check-circle-o",
			};
			//  Clear any hooks
			frappe.route_hooks = {};

			frappe
				.call("frappe.desk.desktop.update_onboarding_step", {
					name: step.name,
					field: status,
					value: value,
				})
				.then(function () {
					callback();

					var icon = step.$step.find("i.fa");
					icon.removeClass();
					icon.addClass("fa");
					icon.addClass(icon_class[status]);

					var pending = this$1.steps.filter(function (step) {
						return !(step.is_complete || step.is_skipped);
					});

					if (pending.length == 0) {
						this$1.show_success();
					}
				});
		}

		show_success() {
			var this$1 = this;

			var success_message = this.success || __("You seem good to go!");
			var success_state_image =
				this.success_state_image ||
				"/assets/frappe/images/ui-states/success-color.png";
			var documentation = "";
			if (this.docs_url) {
				documentation = __(
					'Congratulations on completing the module setup. If you want to learn more you can refer to the documentation <a href="{0}">here</a>.',
					[this.docs_url]
				);
			}

			var success = $(("<div class=\"text-center onboarding-success\">\n\t\t\t\t\t<img src=\"" + success_state_image + "\" alt=\"Success State\" class=\"zoomIn success-state\">\n\t\t\t\t\t<h3>" + success_message + "</h3>\n\t\t\t\t\t<div class=\"text-muted\">" + documentation + "</div>\n\t\t\t</div>\n\t\t"));

			if (!this.success_dialog) {
				this.success_dialog = new frappe.ui.Dialog({
					primary_action: function () {
						this$1.success_dialog.hide();
						// Wait for modal to close before removing widget
						setTimeout(function () {
							this$1.delete();
						}, 300);
					},
					primary_action_label: __("Continue"),
				});

				this.success_dialog.set_title(__("Onboarding Complete"));
				this.success_dialog.header
					.find(".indicator")
					.removeClass("hidden")
					.addClass("green");

				success.appendTo(this.success_dialog.$body);
				this.success_dialog.show();
			}
		}

		set_body() {
			this.widget.addClass("onboarding-widget-box");
			if (this.is_dismissed()) {
				this.widget.hide();
			} else {
				this.make_body();
			}
		}

		is_dismissed() {
			var dismissed = JSON.parse(
				localStorage.getItem("dismissed-onboarding") || "{}"
			);
			if (Object.keys(dismissed).includes(this.label)) {
				var last_hidden = new Date(dismissed[this.label]);
				var today = new Date();
				var diff = frappe.datetime.get_hour_diff(today, last_hidden);
				return diff < 24;
			}
			return false;
		}

		set_title(title) {
			super.set_title(title);
			if (this.subtitle) {
				var subtitle = $(
					("<div class=\"widget-subtitle\">" + (this.subtitle) + "</div>")
				);
				subtitle.appendTo(this.title_field);
			}
		}

		set_actions() {
			var this$1 = this;

			this.action_area.empty();
			var dismiss = $(
				"<div class=\"small\" style=\"cursor:pointer;\">Dismiss</div>"
			);
			dismiss.on("click", function () {
				var dismissed = JSON.parse(
					localStorage.getItem("dismissed-onboarding") || "{}"
				);
				dismissed[this$1.label] = frappe.datetime.now_datetime();

				localStorage.setItem(
					"dismissed-onboarding",
					JSON.stringify(dismissed)
				);
				this$1.delete();
			});
			dismiss.appendTo(this.action_area);
		}
	}

	class NewWidget {
		constructor(opts) {
			Object.assign(this, opts);
			this.make();
		}

		customize() {
			return;
		}

		make() {
			this.make_widget();
			this.widget.appendTo(this.container);
			this.setup_events();
		}

		get_title() {
			// DO NOT REMOVE: Comment to load translation
			// __("New Chart") __("New Shortcut") __("New Number Card")
			var title = "New " + (frappe.model.unscrub(this.type));
			return __(title);
		}

		make_widget() {
			var new_widget_class = "new-" + (frappe.scrub(frappe.model.unscrub(this.type), '-')) + "-widget";
			this.widget = $(("<div class=\"widget new-widget " + new_widget_class + "\">\n\t\t\t\t+ " + (this.get_title()) + "\n\t\t\t</div>"));
			this.body = this.widget;
		}

		setup_events() {
			var this$1 = this;

			this.widget.on("click", function () {
				if (!this$1.custom_dialog) {
					this$1.open_dialog();
				} else {
					this$1.custom_dialog();
				}
			});
		}

		open_dialog() {
			var dialog_class = get_dialog_constructor(this.type);

			this.dialog = new dialog_class({
				label: this.label,
				type: this.type,
				values: false,
				default_values: this.default_values,
				primary_action: this.on_create,
			});

			this.dialog.make();
		}

		delete() {
			this.widget.remove();
		}
	}

	class NumberCardWidget extends Widget {
		constructor(opts) {
			super(opts);
		}

		get_config() {
			return {
				name: this.name,
				label: this.label,
				color: this.color,
				hidden: this.hidden,
			};
		}

		refresh() {
			this.set_body();
		}

		set_body() {
			this.widget.addClass("number-widget-box");
			this.make_card();
		}

		set_title() {
			$(this.title_field).html(("<div class=\"number-label\">" + (this.card_doc.label) + "</div>"));
		}

		make_card() {
			var this$1 = this;

			frappe.model.with_doc('Number Card', this.name).then(function (card) {
				if (!card) {
					if (this$1.document_type) {
						frappe.run_serially([
							function () { return this$1.create_number_card(); },
							function () { return this$1.render_card(); } ]);
					} else {
						// widget doesn't exist so delete
						this$1.delete(false);
						return;
					}
				} else {
					this$1.card_doc = card;
					this$1.render_card();
				}

				this$1.set_events();
			});
		}

		create_number_card() {
			var this$1 = this;

			this.set_doc_args();
			return frappe.xcall(
				'frappe.desk.doctype.number_card.number_card.create_number_card',
				{
					'args': this.card_doc
				}
			).then(function (doc) {
				this$1.name = doc.name;
				this$1.card_doc = doc;
				this$1.widget.attr('data-widget-name', this$1.name);
			});
		}

		set_events() {
			var this$1 = this;

			$(this.body).click(function () {
				if (this$1.in_customize_mode || this$1.card_doc.type == 'Custom') { return; }
				this$1.set_route();
			});
		}

		set_route() {
			var is_document_type = this.card_doc.type !== 'Report';
			var name = is_document_type ? this.card_doc.document_type : this.card_doc.report_name;
			var route = generate_route({
				name: name,
				type: is_document_type ? 'doctype' : 'report',
				is_query_report: !is_document_type,
			});

			if (is_document_type) {
				var filters = JSON.parse(this.card_doc.filters_json);
				frappe.route_options = filters.reduce(function (acc, filter) {
					var obj;

					return Object.assign(acc, ( obj = {}, obj[((filter[0]) + "." + (filter[1]))] = [filter[2], filter[3]], obj ));
				}, {});
			}

			frappe.set_route(route);
		}

		set_doc_args() {
			this.card_doc = Object.assign({}, {
				document_type: this.document_type,
				label: this.label,
				function: this.function,
				aggregate_function_based_on: this.aggregate_function_based_on,
				color: this.color,
				filters_json: this.stats_filter
			});
		}

		get_settings(type) {
			var this$1 = this;

			this.filters = this.get_filters();
			var settings_map = {
				'Custom': {
					method: this.card_doc.method,
					args: {
						filters: this.filters
					},
					get_number: function (res) { return this$1.get_number_for_custom_card(res); },
				},
				'Report': {
					method: 'frappe.desk.query_report.run',
					args: {
						report_name: this.card_doc.report_name,
						filters: this.filters,
						ignore_prepared_report: 1
					},
					get_number: function (res) { return this$1.get_number_for_report_card(res); },
				},
				'Document Type': {
					method: 'frappe.desk.doctype.number_card.number_card.get_result',
					args: {
						doc: this.card_doc,
						filters: this.filters,
					},
					get_number: function (res) { return this$1.get_number_for_doctype_card(res); },
				}
			};
			return settings_map[type];
		}

		get_filters() {
			var filters = frappe.dashboard_utils.get_all_filters(this.card_doc);
			return filters;
		}

		render_card() {
			var this$1 = this;

			this.prepare_actions();
			this.set_title();
			this.set_loading_state();

			if (!this.card_doc.type) {
				this.card_doc.type = 'Document Type';
			}

			this.settings = this.get_settings(this.card_doc.type);

			frappe.run_serially([
				function () { return this$1.render_number(); },
				function () { return this$1.render_stats(); } ]);
		}

		set_loading_state() {
			$(this.body).html(("<div class=\"number-card-loading text-muted\">\n\t\t\t" + (__('Loading...')) + "\n\t\t</div>"));
		}

		get_number() {
			var this$1 = this;

			return frappe.xcall(this.settings.method, this.settings.args).then(function (res) {
				return this$1.settings.get_number(res);
			});
		}

		get_number_for_custom_card(res) {
			if (typeof res === 'object') {
				this.number = res.value;
				this.get_formatted_number(res);
			} else {
				this.formatted_number = res;
			}
		}

		get_number_for_doctype_card(res) {
			var this$1 = this;

			this.number = res;
			if (this.card_doc.function !== 'Count') {
				return frappe.model.with_doctype(this.card_doc.document_type, function () {
					var based_on_df =
						frappe.meta.get_docfield(this$1.card_doc.document_type, this$1.card_doc.aggregate_function_based_on);
					this$1.get_formatted_number(based_on_df);
				});
			} else {
				this.formatted_number = res;
			}
		}

		get_number_for_report_card(res) {
			var field = this.card_doc.report_field;
			var vals = res.result.reduce(function (acc, col) {
				col[field] && acc.push(col[field]);
				return acc;
			}, []);
			var col = res.columns.find(function (col) { return col.fieldname == field; });
			this.number = frappe.report_utils.get_result_of_fn(this.card_doc.report_function, vals);
			this.get_formatted_number(col);
		}

		get_formatted_number(df) {
			var default_country = frappe.sys_defaults.country;
			var shortened_number = shorten_number(this.number, default_country);
			var number_parts = shortened_number.split(' ');

			var symbol = number_parts[1] || '';
			var formatted_number = $(frappe.format(number_parts[0], df)).text();

			this.formatted_number = formatted_number + ' ' + symbol;
		}

		render_number() {
			var this$1 = this;

			return this.get_number().then(function () {
				$(this$1.body).html(("<div class=\"widget-content\">\n\t\t\t\t<div class=\"number\" style=\"color:" + (this$1.card_doc.color) + "\">" + (this$1.formatted_number) + "</div>\n\t\t\t\t</div>"));
			});
		}

		render_stats() {
			var this$1 = this;

			if (this.card_doc.type !== 'Document Type') {
				return;
			}

			var caret_html = '';
			var color_class = '';

			return this.get_percentage_stats().then(function () {
				if (this$1.percentage_stat == undefined) { return; }

				if (this$1.percentage_stat == 0) {
					color_class = 'grey-stat';
				} else if (this$1.percentage_stat > 0) {
					caret_html = '<i class="fa fa-caret-up"></i>';
					color_class = 'green-stat';
				} else {
					caret_html = '<i class="fa fa-caret-down"></i>';
					color_class = 'red-stat';
				}

				var stats_qualifier_map = {
					'Daily': __('since yesterday'),
					'Weekly': __('since last week'),
					'Monthly': __('since last month'),
					'Yearly': __('since last year')
				};
				var stats_qualifier = stats_qualifier_map[this$1.card_doc.stats_time_interval];

				$(this$1.body).find('.widget-content').append(("<div class=\"card-stats " + color_class + "\">\n\t\t\t\t<span class=\"percentage-stat\">\n\t\t\t\t\t" + caret_html + "\n\t\t\t\t\t" + (Math.abs(this$1.percentage_stat)) + " %\n\t\t\t\t</span>\n\t\t\t\t<span class=\"stat-period text-muted\">\n\t\t\t\t\t" + stats_qualifier + "\n\t\t\t\t</span>\n\t\t\t</div>"));
			});
		}

		get_percentage_stats() {
			var this$1 = this;

			return frappe.xcall('frappe.desk.doctype.number_card.number_card.get_percentage_difference', {
				doc: this.card_doc,
				filters: this.filters,
				result: this.number
			}).then(function (res) {
				if (res !== undefined) {
					this$1.percentage_stat = +res.toFixed(2);
				}
			});
		}

		prepare_actions() {
			var this$1 = this;

			var actions = [
				{
					label: __('Refresh'),
					action: 'action-refresh',
					handler: function () {
						this$1.render_card();
					}
				},
				{
					label: __('Edit'),
					action: 'action-edit',
					handler: function () {
						frappe.set_route(
							'Form',
							'Number Card',
							this$1.name
						);
					}
				} ];

			this.set_card_actions(actions);
		}

		set_card_actions(actions) {
			/* eslint-disable indent */
			this.card_actions =
				$(("<div class=\"card-actions dropdown pull-right\">\n\t\t\t\t<a class=\"dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n\t\t\t\t\t<button class=\"btn btn-default btn-xs\"><span class=\"caret\"></span></button>\n\t\t\t\t</a>\n\t\t\t\t<ul class=\"dropdown-menu\" style=\"max-height: 300px; overflow-y: auto;\">\n\t\t\t\t\t" + (actions
							.map(
								function (action) { return ("<li>\n\t\t\t\t\t\t\t\t\t<a data-action=\"" + (action.action) + "\">" + (action.label) + "</a>\n\t\t\t\t\t\t\t\t</li>"); }
							).join('')) + "\n\t\t\t\t</ul>\n\t\t\t</div>"));
			/* eslint-disable indent */

			this.card_actions.find("a[data-action]").each(function (i, o) {
				var action = o.dataset.action;
				$(o).click(actions.find(function (a) { return a.action === action; }));
			});

			this.action_area.html(this.card_actions);
		}
	}

	frappe.provide("frappe.widget");

	frappe.widget.widget_factory = {
		chart: ChartWidget,
		base: Widget,
		shortcut: ShortcutWidget,
		links: LinksWidget,
		onboarding: OnboardingWidget,
		number_card: NumberCardWidget,
	};

	frappe.widget.make_widget = function (opts) {
		var widget_class = frappe.widget.widget_factory[opts.widget_type];
		if (widget_class) {
			return new widget_class(opts);
		} else {
			// eslint-disable-next-line
			console.warn("Invalid Widget Name: " + opts.widget_type);
		}
	};

	class WidgetGroup {
		constructor(opts) {
			Object.assign(this, opts);
			this.widgets_list = [];
			this.widgets_dict = {};
			this.widget_order = [];
			this.make();
		}

		make() {
			this.make_container();
			this.title && this.set_title();
			this.widgets && this.make_widgets();
		}

		make_container() {
			var widget_area = $(("<div class=\"widget-group\">\n\t\t\t\t<div class=\"widget-group-head\">\n\t\t\t\t\t<div class=\"widget-group-title h6 uppercase\"></div>\n\t\t\t\t\t<div class=\"widget-group-control h6 text-muted\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"widget-group-body grid-col-" + (this.columns) + "\">\n\t\t\t\t</div>\n\t\t\t</div>"));
			this.widget_area = widget_area;
			if (this.hidden) { this.widget_area.hide(); }
			this.title_area = widget_area.find(".widget-group-title");
			this.control_area = widget_area.find(".widget-group-control");
			this.body = widget_area.find(".widget-group-body");
			!this.widgets.length && this.widget_area.hide();
			widget_area.appendTo(this.container);
		}

		set_title() {
			this.title_area[0].innerText = this.title;
		}

		make_widgets() {
			var this$1 = this;

			this.body.empty();
			this.widgets.forEach(function (widget) {
				this$1.add_widget(widget);
			});
		}

		add_widget(widget) {
			var this$1 = this;

			var widget_object = frappe.widget.make_widget(Object.assign({}, widget,
				{widget_type: this.type,
				container: this.body,
				options: Object.assign({}, this.options,
					{on_delete: function (name) { return this$1.on_delete(name); }})}));

			this.widgets_list.push(widget_object);
			this.widgets_dict[widget.name] = widget_object;

			return widget_object;
		}

		remove_widget(widget_obj) {
			widget_obj.widget.remove();
			this.widgets_list.filter(function (widget) {
				if (widget.name == widget_obj.name) { return false; }
			});
			delete this.widgets_dict[widget_obj.name];
		}

		customize() {
			var this$1 = this;

			if (!this.hidden) { this.widget_area.show(); }
			this.widgets_list.forEach(function (wid) {
				wid.customize(this$1.options);
			});

			this.options.allow_create && this.setup_new_widget();
			this.options.allow_sorting && this.setup_sortable();
		}

		setup_new_widget() {
			var this$1 = this;

			var max = this.options
				? this.options.max_widget_count || Number.POSITIVE_INFINITY
				: Number.POSITIVE_INFINITY;

			if (this.widgets_list.length < max) {
				this.new_widget = new NewWidget({
					container: this.body,
					type: this.type,
					custom_dialog: this.custom_dialog,
					default_values: this.default_values,
					on_create: function (config) {
						// Remove new widget
						this$1.new_widget.delete();
						delete this$1.new_widget;

						config.in_customize_mode = 1;

						// Add new widget and customize it
						var wid = this$1.add_widget(config);
						wid.customize(this$1.options);

						// Put back the new widget if required
						if (this$1.widgets_list.length < max) {
							this$1.setup_new_widget();
						}
					},
				});
			}
		}

		on_delete(name, setup_new) {
			this.widgets_list = this.widgets_list.filter(function (wid) { return name != wid.name; });
			delete this.widgets_dict[name];
			this.update_widget_order();

			if (!this.new_widget && setup_new) { this.setup_new_widget(); }
		}

		update_widget_order() {
			var this$1 = this;

			this.widget_order = [];
			this.body.children().each(function (index, element) {
				var name = element.dataset.widgetName;
				if (name) {
					this$1.widget_order.push(name);
				}
			});
		}

		setup_sortable() {
			var this$1 = this;

			var container = this.body[0];
			this.sortable = new Sortable(container, {
				animation: 150,
				handle: ".drag-handle",
				onEnd: function () { return this$1.update_widget_order(); },
			});
		}

		get_widget_config() {
			this.update_widget_order();
			var prepared_dict = {};

			this.widgets_list.forEach(function (wid) {
				var config = wid.get_config();
				var name = config.docname ? config.docname : config.name;
				prepared_dict[name] = config;
			});

			return {
				order: this.widget_order,
				widgets: prepared_dict,
			};
		}
	}

	frappe.widget.WidgetGroup = WidgetGroup;

	frappe.templates['sort_selector'] = '<div class="sort-selector">  <div class="dropdown">   <a class="text-muted dropdown-toggle small"    data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">    <span class="dropdown-text">{{ __(sort_by_label) }}</span>   </a>   <ul class="dropdown-menu">    {% for value in options %}    <li>     <a class="option" data-value="{{ value.fieldname }}">      {{ __(value.label) }}     </a>    </li>    {% endfor %}   </ul>  </div>  <button class="btn btn-default btn-xs btn-order"   data-value="{{ sort_order }}">   <span class="octicon text-muted    octicon-arrow-{{ sort_order==="desc" ? "down " : "up " }}">   </span>  </button> </div>';

	frappe.ui.SortSelector = Class.extend({
		// parent:
		// change:
		// args:
		//		options: {fieldname:, label:}
		//		sort_by:
		//		sort_by_label:
		//		sort_order:
		//		doctype: (optional)
		init: function(opts) {
			$.extend(this, opts);
			this.labels = {};
			this.make();
		},
		make: function() {
			this.prepare_args();
			this.parent.find('.sort-selector').remove();
			this.wrapper = $(frappe.render_template('sort_selector', this.args)).appendTo(this.parent);
			this.bind_events();
		},
		bind_events: function() {
			var me = this;

			// order
			this.wrapper.find('.btn-order').on('click', function() {
				var btn = $(this);
				var order = $(this).attr('data-value')==='desc' ? 'asc' : 'desc';

				btn.attr('data-value', order);
				me.sort_order = order;
				btn.find('.octicon')
					.removeClass('octicon-arrow-' + (order==='asc' ? 'down' : 'up'))
					.addClass('octicon-arrow-' + (order==='desc' ? 'down' : 'up'));
				(me.onchange || me.change)(me.sort_by, me.sort_order);
			});

			// select field
			this.wrapper.find('.dropdown a.option').on('click', function() {
				me.sort_by = $(this).attr('data-value');
				me.wrapper.find('.dropdown .dropdown-text').html($(this).html());
				(me.onchange || me.change)(me.sort_by, me.sort_order);
			});

		},
		prepare_args: function() {
			var me = this;
			if(!this.args) {
				this.args = {};
			}

			// args as string
			if(this.args && typeof this.args === 'string') {
				var order_by = this.args;
				this.args = {};

				if (order_by.includes('`.`')) {
					// scrub table name (separated by dot), like `tabTime Log`.`modified` desc`
					order_by = order_by.split('.')[1];
				}

				var parts = order_by.split(' ');
				if (parts.length === 2) {
					var fieldname = strip(parts[0], '`');

					this.args.sort_by = fieldname;
					this.args.sort_order = parts[1];
				}
			}

			if(this.args.options) {
				this.args.options.forEach(function(o) {
					me.labels[o.fieldname] = o.label;
				});
			}

			this.setup_from_doctype();

			// if label is missing, add from options
			if(this.args.sort_by && !this.args.sort_by_label) {
				this.args.options.every(function(o) {
					if(o.fieldname===me.args.sort_by) {
						me.args.sort_by_label = o.label;
						return false;
					}
					return true;
				});
			}

		},
		setup_from_doctype: function() {
			var me = this;
			var meta = frappe.get_meta(this.doctype);
			if (!meta) { return; }

			var ref = this.get_meta_sort_field();
			var meta_sort_field = ref.meta_sort_field;
			var meta_sort_order = ref.meta_sort_order;

			if(!this.args.sort_by) {
				if(meta_sort_field) {
					this.args.sort_by = meta_sort_field;
					this.args.sort_order = meta_sort_order;
				} else {
					// default
					this.args.sort_by = 'modified';
					this.args.sort_order = 'desc';
				}
			}

			if(!this.args.sort_by_label) {
				this.args.sort_by_label = this.get_label(this.args.sort_by);
			}

			if(!this.args.options) {
				// default options
				var _options = [
					{'fieldname': 'modified'}
				];

				// title field
				if(meta.title_field) {
					_options.push({'fieldname': meta.title_field});
				}

				// bold or mandatory
				meta.fields.forEach(function(df) {
					if(df.mandatory || df.bold) {
						_options.push({fieldname: df.fieldname, label: df.label});
					}
				});

				// meta sort field
				if(meta_sort_field) { _options.push({ 'fieldname': meta_sort_field }); }

				// more default options
				_options.push(
					{'fieldname': 'name'},
					{'fieldname': 'creation'},
					{'fieldname': 'idx'}
				);

				// de-duplicate
				this.args.options = _options.uniqBy(function(obj) {
					return obj.fieldname;
				});

				// add missing labels
				this.args.options.forEach(function(o) {
					if(!o.label) {
						o.label = me.get_label(o.fieldname);
					}
				});
			}

			// set default
			this.sort_by = this.args.sort_by;
			this.sort_order = this.args.sort_order;
		},
		get_meta_sort_field: function() {
			var meta = frappe.get_meta(this.doctype);

			if (!meta) {
				return {
					meta_sort_field: null,
					meta_sort_order: null
				}
			}

			if(meta.sort_field && meta.sort_field.includes(',')) {
				var parts = meta.sort_field.split(',')[0].split(' ');
				return {
					meta_sort_field: parts[0],
					meta_sort_order: parts[1]
				}
			} else {
				return {
					meta_sort_field: meta.sort_field || 'modified',
					meta_sort_order: meta.sort_order ? meta.sort_order.toLowerCase() : ''
				}
			}
		},
		get_label: function(fieldname) {
			if(fieldname==='idx') {
				return __("Most Used");
			} else {
				return this.labels[fieldname]
					|| frappe.meta.get_label(this.doctype, fieldname);
			}
		},
		get_sql_string: function() {
			// build string like `tabTask`.`subject` desc
			return '`tab' + this.doctype + '`.`' + this.sort_by + '` ' +  this.sort_order;
		}
	});

	frappe.templates['change_log'] = '{% for (var i=0, l=change_log.length; i < l; i++) {     var app_info = change_log[i]; %}  {% if (i > 0) { %} <hr> {% } %}  <div class="text-left app-change-log">   <h2 style="margin-top: 10px;">             {{ app_info.title }}    <small>{{ __("updated to {0}", [app_info.version]) }}</small>   </h2>   <div class="app-change-log-body">   {% for (var x=0, y=app_info.change_log.length; x < y; x++) {             var version_info = app_info.change_log[x];             if(version_info) { %}        <p>{{ frappe.markdown(version_info[1]) }}</p>       {% }         } %}      </div>  </div> {% } %} ';

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt
	/* eslint-disable no-console */

	// __('Modules') __('Domains') __('Places') __('Administration') # for translation, don't remove

	frappe.start_app = function() {
		if (!frappe.Application)
			{ return; }
		frappe.assets.check();
		frappe.provide('frappe.app');
		frappe.provide('frappe.desk');
		frappe.app = new frappe.Application();
	};

	$(document).ready(function() {
		if (!frappe.utils.supportsES6) {
			frappe.msgprint({
				indicator: 'red',
				title: __('Browser not supported'),
				message: __('Some of the features might not work in your browser. Please update your browser to the latest version.')
			});
		}
		frappe.start_app();
	});

	frappe.Application = Class.extend({
		init: function() {
			this.startup();
		},

		startup: function() {
			var this$1 = this;

			frappe.socketio.init();
			frappe.model.init();

			if(frappe.boot.status==='failed') {
				frappe.msgprint({
					message: frappe.boot.error,
					title: __('Session Start Failed'),
					indicator: 'red',
				});
				throw 'boot failed';
			}

			this.setup_frappe_vue();
			this.load_bootinfo();
			this.load_user_permissions();
			this.set_app_logo_url()
				.then(function () {
					this$1.make_nav_bar();
				});
			this.set_favicon();
			this.setup_analytics();
			this.set_fullwidth_if_enabled();
			this.add_browser_class();
			this.setup_energy_point_listeners();

			frappe.ui.keys.setup();
			this.set_rtl();

			if(frappe.boot) {
				if(localStorage.getItem("session_last_route")) {
					window.location.hash = localStorage.getItem("session_last_route");
					localStorage.removeItem("session_last_route");
				}

			}

			// page container
			this.make_page_container();

			// route to home page
			frappe.route();

			// trigger app startup
			$(document).trigger('startup');

			$(document).trigger('app_ready');

			if (frappe.boot.messages) {
				frappe.msgprint(frappe.boot.messages);
			}

			if (frappe.user_roles.includes('System Manager')) {
				this.show_change_log();
				this.show_update_available();
			}

			if (!frappe.boot.developer_mode) {
				var console_security_message = __("Using this console may allow attackers to impersonate you and steal your information. Do not enter or paste code that you do not understand.");
				console.log(
					("%c" + console_security_message),
					"font-size: large"
				);
			}

			this.show_notes();

			if (frappe.ui.startup_setup_dialog && !frappe.boot.setup_complete) {
				frappe.ui.startup_setup_dialog.pre_show();
				frappe.ui.startup_setup_dialog.show();
			}

			frappe.realtime.on("version-update", function() {
				var dialog = frappe.msgprint({
					message:__("The application has been updated to a new version, please refresh this page"),
					indicator: 'green',
					title: __('Version Updated')
				});
				dialog.set_primary_action(__("Refresh"), function() {
					location.reload(true);
				});
				dialog.get_close_btn().toggle(false);
			});

			this.setup_social_listeners();

			// listen to build errors
			this.setup_build_error_listener();

			if (frappe.sys_defaults.email_user_password) {
				var email_list =  frappe.sys_defaults.email_user_password.split(',');
				for (var u in email_list) {
					if (email_list[u]===frappe.user.name) {
						this.set_password(email_list[u]);
					}
				}
			}
			this.link_preview = new frappe.ui.LinkPreview();

			if (!frappe.boot.developer_mode) {
				setInterval(function() {
					frappe.call({
						method: 'frappe.core.page.background_jobs.background_jobs.get_scheduler_status',
						callback: function(r) {
							if (r.message[0] == __("Inactive")) {
								frappe.call('frappe.utils.scheduler.activate_scheduler');
							}
						}
					});
				}, 300000); // check every 5 minutes

				if(frappe.user.has_role("System Manager")){
					setInterval(function() {
						frappe.call({
							method: 'frappe.core.doctype.log_settings.log_settings.has_unseen_error_log',
							args: {
								user: frappe.session.user
							},
							callback: function(r) {
								console.log(r);
								if(r.message.show_alert){
									frappe.show_alert({
										indicator: 'red',
										message: r.message.message
									});
								}
							}
						});
					}, 600000); // check every 10 minutes
				}
			}

			this.fetch_tags();
		},

		setup_frappe_vue: function setup_frappe_vue() {
			Vue.prototype.__ = window.__;
			Vue.prototype.frappe = window.frappe;
		},

		set_password: function(user) {
			var me=this;
			frappe.call({
				method: 'frappe.core.doctype.user.user.get_email_awaiting',
				args: {
					"user": user
				},
				callback: function(email_account) {
					email_account = email_account["message"];
					if (email_account) {
						var i = 0;
						if (i < email_account.length) {
							me.email_password_prompt( email_account, user, i);
						}
					}
				}
			});
		},

		email_password_prompt: function(email_account,user,i) {
			var me = this;
			var d = new frappe.ui.Dialog({
				title: __('Email Account setup please enter your password for: {0}', [email_account[i]["email_id"]]),
				fields: [
					{	'fieldname': 'password',
						'fieldtype': 'Password',
						'label': 'Email Account Password',
						'reqd': 1
					},
					{
						"fieldtype": "Button",
						"label": __("Submit")
					}
				]
			});
			d.get_input("submit").on("click", function() {
				//setup spinner
				d.hide();
				var s = new frappe.ui.Dialog({
					title: __("Checking one moment"),
					fields: [{
						"fieldtype": "HTML",
						"fieldname": "checking"
					}]
				});
				s.fields_dict.checking.$wrapper.html('<i class="fa fa-spinner fa-spin fa-4x"></i>');
				s.show();
				frappe.call({
					method: 'frappe.core.doctype.user.user.set_email_password',
					args: {
						"email_account": email_account[i]["email_account"],
						"user": user,
						"password": d.get_value("password")
					},
					callback: function(passed) {
						s.hide();
						d.hide();//hide waiting indication
						if (!passed["message"]) {
							frappe.show_alert("Login Failed please try again", 5);
							me.email_password_prompt(email_account, user, i);
						} else {
							if (i + 1 < email_account.length) {
								i = i + 1;
								me.email_password_prompt(email_account, user, i);
							}
						}

					}
				});
			});
			d.show();
		},
		load_bootinfo: function() {
			if(frappe.boot) {
				frappe.modules = {};
				frappe.boot.allowed_modules.forEach(function(m) {
					frappe.modules[m.module_name]=m;
				});
				frappe.model.sync(frappe.boot.docs);
				$.extend(frappe._messages, frappe.boot.__messages);
				this.check_metadata_cache_status();
				this.set_globals();
				this.sync_pages();
				moment.locale("en");
				moment.user_utc_offset = moment().utcOffset();
				if(frappe.boot.timezone_info) {
					moment.tz.add(frappe.boot.timezone_info);
				}
				if(frappe.boot.print_css) {
					frappe.dom.set_style(frappe.boot.print_css, "print-style");
				}
				frappe.user.name = frappe.boot.user.name;
			} else {
				this.set_as_guest();
			}
		},

		load_user_permissions: function() {
			frappe.defaults.update_user_permissions();

			frappe.realtime.on('update_user_permissions', frappe.utils.debounce(function () {
				frappe.defaults.update_user_permissions();
			}, 500));
		},

		check_metadata_cache_status: function() {
			if(frappe.boot.metadata_version != localStorage.metadata_version) {
				frappe.assets.clear_local_storage();
				frappe.assets.init_local_storage();
			}
		},

		set_globals: function() {
			frappe.session.user = frappe.boot.user.name;
			frappe.session.user_email = frappe.boot.user.email;
			frappe.session.user_fullname = frappe.user_info().fullname;

			frappe.user_defaults = frappe.boot.user.defaults;
			frappe.user_roles = frappe.boot.user.roles;
			frappe.sys_defaults = frappe.boot.sysdefaults;

			frappe.ui.py_date_format = frappe.boot.sysdefaults.date_format.replace('dd', '%d').replace('mm', '%m').replace('yyyy', '%Y');
			frappe.boot.user.last_selected_values = {};

			// Proxy for user globals
			Object.defineProperties(window, {
				'user': {
					get: function() {
						console.warn('Please use `frappe.session.user` instead of `user`. It will be deprecated soon.');
						return frappe.session.user;
					}
				},
				'user_fullname': {
					get: function() {
						console.warn('Please use `frappe.session.user_fullname` instead of `user_fullname`. It will be deprecated soon.');
						return frappe.session.user;
					}
				},
				'user_email': {
					get: function() {
						console.warn('Please use `frappe.session.user_email` instead of `user_email`. It will be deprecated soon.');
						return frappe.session.user_email;
					}
				},
				'user_defaults': {
					get: function() {
						console.warn('Please use `frappe.user_defaults` instead of `user_defaults`. It will be deprecated soon.');
						return frappe.user_defaults;
					}
				},
				'roles': {
					get: function() {
						console.warn('Please use `frappe.user_roles` instead of `roles`. It will be deprecated soon.');
						return frappe.user_roles;
					}
				},
				'sys_defaults': {
					get: function() {
						console.warn('Please use `frappe.sys_defaults` instead of `sys_defaults`. It will be deprecated soon.');
						return frappe.user_roles;
					}
				}
			});
		},
		sync_pages: function() {
			// clear cached pages if timestamp is not found
			if(localStorage["page_info"]) {
				frappe.boot.allowed_pages = [];
				var page_info = JSON.parse(localStorage["page_info"]);
				$.each(frappe.boot.page_info, function(name, p) {
					if(!page_info[name] || (page_info[name].modified != p.modified)) {
						delete localStorage["_page:" + name];
					}
					frappe.boot.allowed_pages.push(name);
				});
			} else {
				frappe.boot.allowed_pages = Object.keys(frappe.boot.page_info);
			}
			localStorage["page_info"] = JSON.stringify(frappe.boot.page_info);
		},
		set_as_guest: function() {
			frappe.session.user = 'Guest';
			frappe.session.user_email = '';
			frappe.session.user_fullname = 'Guest';

			frappe.user_defaults = {};
			frappe.user_roles = ['Guest'];
			frappe.sys_defaults = {};
		},
		make_page_container: function() {
			if($("#body_div").length) {
				$(".splash").remove();
				frappe.temp_container = $("<div id='temp-container' style='display: none;'>")
					.appendTo("body");
				frappe.container = new frappe.views.Container();
			}
		},
		make_nav_bar: function() {
			// toolbar
			if(frappe.boot && frappe.boot.home_page!=='setup-wizard') {
				frappe.frappe_toolbar = new frappe.ui.toolbar.Toolbar();
			}

		},
		logout: function() {
			var me = this;
			me.logged_out = true;
			return frappe.call({
				method:'logout',
				callback: function(r) {
					if(r.exc) {
						return;
					}
					me.redirect_to_login();
				}
			});
		},
		handle_session_expired: function() {
			if(!frappe.app.session_expired_dialog) {
				var dialog = new frappe.ui.Dialog({
					title: __('Session Expired'),
					keep_open: true,
					fields: [
						{ fieldtype:'Password', fieldname:'password',
							label: __('Please Enter Your Password to Continue') } ],
					onhide: function () {
						if (!dialog.logged_in) {
							frappe.app.redirect_to_login();
						}
					}
				});
				dialog.set_primary_action(__('Login'), function () {
					dialog.set_message(__('Authenticating...'));
					frappe.call({
						method: 'login',
						args: {
							usr: frappe.session.user,
							pwd: dialog.get_values().password
						},
						callback: function (r) {
							if (r.message==='Logged In') {
								dialog.logged_in = true;

								// revert backdrop
								$('.modal-backdrop').css({
									'opacity': '',
									'background-color': '#334143'
								});
							}
							dialog.hide();
						},
						statusCode: function () {
							dialog.hide();
						}
					});
				});
				frappe.app.session_expired_dialog = dialog;
			}
			if(!frappe.app.session_expired_dialog.display) {
				frappe.app.session_expired_dialog.show();
				// add backdrop
				$('.modal-backdrop').css({
					'opacity': 1,
					'background-color': '#4B4C9D'
				});
			}
		},
		redirect_to_login: function() {
			window.location.href = '/';
		},
		set_favicon: function() {
			var link = $('link[type="image/x-icon"]').remove().attr("href");
			$('<link rel="shortcut icon" href="' + link + '" type="image/x-icon">').appendTo("head");
			$('<link rel="icon" href="' + link + '" type="image/x-icon">').appendTo("head");
		},

		set_app_logo_url: function() {
			return frappe.call('frappe.core.doctype.navbar_settings.navbar_settings.get_app_logo')
				.then(function (r) {
					frappe.app.logo_url = r.message;
					if (window.cordova) {
						var host = frappe.request.url;
						host = host.slice(0, host.length - 1);
						frappe.app.logo_url = host + frappe.app.logo_url;
					}
				});
		},

		trigger_primary_action: function() {
			if(window.cur_dialog && cur_dialog.display) {
				// trigger primary
				cur_dialog.get_primary_btn().trigger("click");
			} else if(cur_frm && cur_frm.page.btn_primary.is(':visible')) {
				cur_frm.page.btn_primary.trigger('click');
			} else if(frappe.container.page.save_action) {
				frappe.container.page.save_action();
			}
		},

		set_rtl: function() {
			if (frappe.utils.is_rtl()) {
				var ls = document.createElement('link');
				ls.rel="stylesheet";
				ls.href= "assets/css/frappe-rtl.css";
				document.getElementsByTagName('head')[0].appendChild(ls);
				$('body').addClass('frappe-rtl');
			}
		},

		show_change_log: function() {
			var me = this;
			var change_log = frappe.boot.change_log;

			// frappe.boot.change_log = [{
			// 	"change_log": [
			// 		[<version>, <change_log in markdown>],
			// 		[<version>, <change_log in markdown>],
			// 	],
			// 	"description": "ERP made simple",
			// 	"title": "ERPNext",
			// 	"version": "12.2.0"
			// }];

			if (!Array.isArray(change_log) || !change_log.length || window.Cypress) {
				return;
			}

			// Iterate over changelog
			var change_log_dialog = frappe.msgprint({
				message: frappe.render_template("change_log", {"change_log": change_log}),
				title: __("Updated To A New Version 🎉"),
				wide: true,
				scroll: true
			});
			change_log_dialog.keep_open = true;
			change_log_dialog.custom_onhide = function() {
				frappe.call({
					"method": "frappe.utils.change_log.update_last_known_versions"
				});
				me.show_notes();
			};
		},

		show_update_available: function () {
			frappe.call({
				"method": "frappe.utils.change_log.show_update_popup"
			});
		},

		setup_analytics: function() {
			if(window.mixpanel) {
				window.mixpanel.identify(frappe.session.user);
				window.mixpanel.people.set({
					"$first_name": frappe.boot.user.first_name,
					"$last_name": frappe.boot.user.last_name,
					"$created": frappe.boot.user.creation,
					"$email": frappe.session.user
				});
			}
		},

		add_browser_class: function add_browser_class() {
			var browsers = ['Chrome', 'Firefox', 'Safari'];
			for (var i = 0, list = browsers; i < list.length; i += 1) {
				var browser = list[i];

				if (navigator.userAgent.includes(browser)) {
					$('html').addClass(browser.toLowerCase());
					return;
				}
			}
		},

		set_fullwidth_if_enabled: function set_fullwidth_if_enabled() {
			frappe.ui.toolbar.set_fullwidth_if_enabled();
		},

		show_notes: function() {
			var me = this;
			if(frappe.boot.notes.length) {
				frappe.boot.notes.forEach(function(note) {
					if(!note.seen || note.notify_on_every_login) {
						var d = frappe.msgprint({message:note.content, title:note.title});
						d.keep_open = true;
						d.custom_onhide = function() {
							note.seen = true;

							// Mark note as read if the Notify On Every Login flag is not set
							if (!note.notify_on_every_login) {
								frappe.call({
									method: "frappe.desk.doctype.note.note.mark_as_seen",
									args: {
										note: note.name
									}
								});
							}

							// next note
							me.show_notes();

						};
					}
				});
			}
		},

		setup_build_error_listener: function setup_build_error_listener() {
			if (frappe.boot.developer_mode) {
				frappe.realtime.on('build_error', function (data) {
					console.log(data);
				});
			}
		},

		setup_social_listeners: function setup_social_listeners() {
			frappe.realtime.on('mention', function (message) {
				if (frappe.get_route()[0] !== 'social') {
					frappe.show_alert(message);
				}
			});
		},

		setup_energy_point_listeners: function setup_energy_point_listeners() {
			frappe.realtime.on('energy_point_alert', function (message) {
				frappe.show_alert(message);
			});
		},

		fetch_tags: function fetch_tags() {
			frappe.tags.utils.fetch_tags();
		}
	});

	frappe.get_module = function(m, default_module) {
		var module = frappe.modules[m] || default_module;
		if (!module) {
			return;
		}

		if(module._setup) {
			return module;
		}

		if(module.type==="module" && !module.link) {
			module.link = "modules/" + module.module_name;
		}

		if(module.type==="list" && !module.link) {
			module.link = "List/" + module._doctype;
		}

		if (!module.link) { module.link = ""; }

		if (!module._id) {
			// links can have complex values that range beyond simple plain text names, and so do not make for robust IDs.
			// an example from python: "link": r"javascript:eval('window.open(\'timetracking\', \'_self\')')"
			// this snippet allows a module to open a custom html page in the same window.
			module._id = module.module_name.toLowerCase();
		}


		if(!module.label) {
			module.label = m;
		}

		if(!module._label) {
			module._label = __(module.label);
		}

		if(!module._doctype) {
			module._doctype = '';
		}

		module._setup = true;

		return module;
	};

	frappe.provide('frappe.utils');

	function get_url_arg(name) {
		return get_query_params()[name] || "";
	}

	function get_query_string(url) {
		if(url.includes("?")) {
			return url.slice(url.indexOf("?")+1);
		}else {
			return "";
		}
	}

	function get_query_params(query_string) {
		var query_params = {};
		if (!query_string) {
			query_string = location.search.substring(1);
		}

		var query_list = query_string.split("&");
		for (var i=0, l=query_list.length; i < l; i++ ){
			var pair = query_list[i].split(/=(.+)/);
			var key = pair[0];
			if (!key) {
				continue;
			}

			var value = pair[1];
			if (typeof value === "string") {
				value = value.replace(/\+/g, "%20");
				try {
					value = decodeURIComponent(value);
				} catch(e) {
					// if value contains %, it fails
				}
			}

			if (key in query_params) {
				if (typeof query_params[key] === "undefined") {
					query_params[key] = [];
				} else if (typeof query_params[key] === "string") {
					query_params[key] = [query_params[key]];
				}
				query_params[key].push(value);
			} else {
				query_params[key] = value;
			}
		}
		return query_params;
	}

	function make_query_string(obj, encode) {
		if ( encode === void 0 ) encode=true;

		var query_params = [];
		for (var key in obj) {
			var value = obj[key];
			if (value === undefined || value === '' || value === null) {
				continue;
			}
			if (typeof value === 'object') {
				value = JSON.stringify(value);
			}

			if (encode) {
				key = encodeURIComponent(key);
				value = encodeURIComponent(value);
			}

			query_params.push((key + "=" + value));
		}
		return '?' + query_params.join('&');
	}

	Object.assign(frappe.utils, {
		get_url_arg: get_url_arg,
		get_query_string: get_query_string,
		get_query_params: get_query_params,
		make_query_string: make_query_string
	});

	frappe.templates['rating_icons'] = '{% if show_label %}  {{ __("Rating: ") }} {% endif %} {% for(var i=1, l=6; i<l; i++) { %}  <i class="fa fa-fw {{ i<=rating? "fa-star": "fa-star-o" }} star-icon" data-idx=1></i> {% } %}';

	var fuse = createCommonjsModule(function (module, exports) {
	/*!
	 * Fuse.js v3.4.6 - Lightweight fuzzy-search (http://fusejs.io)
	 * 
	 * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
	 * All Rights Reserved. Apache Software License 2.0
	 * 
	 * http://www.apache.org/licenses/LICENSE-2.0
	 */
	!function(e,t){module.exports=t();}(commonjsGlobal,function(){return function(e){var t={};function n(r){if(t[r]){ return t[r].exports; }var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r});},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},n.t=function(e,t){if(1&t&&(e=n(e)),8&t){ return e; }if(4&t&&"object"==typeof e&&e&&e.__esModule){ return e; }var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e){ for(var o in e){ n.d(r,o,function(t){return e[t]}.bind(null,o)); } }return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=1)}([function(e,t){e.exports=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)};},function(e,t,n){function r(e){return (r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}var i=n(2),a=n(8),s=n(0),c=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.caseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m,S=n.id,x=void 0===S?null:S,b=n.keys,M=void 0===b?[]:b,_=n.shouldSort,L=void 0===_||_,w=n.getFn,A=void 0===w?a:w,C=n.sortFn,I=void 0===C?function(e,t){return e.score-t.score}:C,O=n.tokenize,j=void 0!==O&&O,P=n.matchAllTokens,F=void 0!==P&&P,T=n.includeMatches,z=void 0!==T&&T,E=n.includeScore,K=void 0!==E&&E,$=n.verbose,J=void 0!==$&&$;!function(e,t){if(!(e instanceof t)){ throw new TypeError("Cannot call a class as a function") }}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k,id:x,keys:M,includeMatches:z,includeScore:K,shouldSort:L,getFn:A,sortFn:I,verbose:J,tokenize:j,matchAllTokens:F},this.setCollection(t);}var t,n;return t=e,(n=[{key:"setCollection",value:function(e){return this.list=e,e}},{key:"search",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{limit:!1};this._log('---------\nSearch pattern: "'.concat(e,'"'));var n=this._prepareSearchers(e),r=n.tokenSearchers,o=n.fullSearcher,i=this._search(r,o),a=i.weights,s=i.results;return this._computeScore(a,s),this.options.shouldSort&&this._sort(s),t.limit&&"number"==typeof t.limit&&(s=s.slice(0,t.limit)),this._format(s)}},{key:"_prepareSearchers",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=[];if(this.options.tokenize){ for(var n=e.split(this.options.tokenSeparator),r=0,o=n.length;r<o;r+=1){ t.push(new i(n[r],this.options)); } }return {tokenSearchers:t,fullSearcher:new i(e,this.options)}}},{key:"_search",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0,n=this.list,r={},o=[];if("string"==typeof n[0]){for(var i=0,a=n.length;i<a;i+=1){ this._analyze({key:"",value:n[i],record:i,index:i},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t}); }return {weights:null,results:o}}for(var s={},c=0,h=n.length;c<h;c+=1){ for(var l=n[c],u=0,f=this.options.keys.length;u<f;u+=1){var d=this.options.keys[u];if("string"!=typeof d){if(s[d.name]={weight:1-d.weight||1},d.weight<=0||d.weight>1){ throw new Error("Key weight has to be > 0 and <= 1"); }d=d.name;}else { s[d]={weight:1}; }this._analyze({key:d,value:this.options.getFn(l,d),record:l,index:c},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t});} }return {weights:s,results:o}}},{key:"_analyze",value:function(e,t){var n=e.key,r=e.arrayIndex,o=void 0===r?-1:r,i=e.value,a=e.record,c=e.index,h=t.tokenSearchers,l=void 0===h?[]:h,u=t.fullSearcher,f=void 0===u?[]:u,d=t.resultMap,v=void 0===d?{}:d,p=t.results,g=void 0===p?[]:p;if(null!=i){var y=!1,m=-1,k=0;if("string"==typeof i){this._log("\nKey: ".concat(""===n?"-":n));var S=f.search(i);if(this._log('Full text: "'.concat(i,'", score: ').concat(S.score)),this.options.tokenize){for(var x=i.split(this.options.tokenSeparator),b=[],M=0;M<l.length;M+=1){var _=l[M];this._log('\nPattern: "'.concat(_.pattern,'"'));for(var L=!1,w=0;w<x.length;w+=1){var A=x[w],C=_.search(A),I={};C.isMatch?(I[A]=C.score,y=!0,L=!0,b.push(C.score)):(I[A]=1,this.options.matchAllTokens||b.push(1)),this._log('Token: "'.concat(A,'", score: ').concat(I[A]));}L&&(k+=1);}m=b[0];for(var O=b.length,j=1;j<O;j+=1){ m+=b[j]; }m/=O,this._log("Token score average:",m);}var P=S.score;m>-1&&(P=(P+m)/2),this._log("Score average:",P);var F=!this.options.tokenize||!this.options.matchAllTokens||k>=l.length;if(this._log("\nCheck Matches: ".concat(F)),(y||S.isMatch)&&F){var T=v[c];T?T.output.push({key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}):(v[c]={item:a,output:[{key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}]},g.push(v[c]));}}else if(s(i)){ for(var z=0,E=i.length;z<E;z+=1){ this._analyze({key:n,arrayIndex:z,value:i[z],record:a,index:c},{resultMap:v,results:g,tokenSearchers:l,fullSearcher:f}); } }}}},{key:"_computeScore",value:function(e,t){this._log("\n\nComputing score:\n");for(var n=0,r=t.length;n<r;n+=1){for(var o=t[n].output,i=o.length,a=1,s=1,c=0;c<i;c+=1){var h=e?e[o[c].key].weight:1,l=(1===h?o[c].score:o[c].score||.001)*h;1!==h?s=Math.min(s,l):(o[c].nScore=l,a*=l);}t[n].score=1===s?a:s,this._log(t[n]);}}},{key:"_sort",value:function(e){this._log("\n\nSorting...."),e.sort(this.options.sortFn);}},{key:"_format",value:function(e){var t=[];if(this.options.verbose){var n=[];this._log("\n\nOutput:\n\n",JSON.stringify(e,function(e,t){if("object"===r(t)&&null!==t){if(-1!==n.indexOf(t)){ return; }n.push(t);}return t})),n=null;}var o=[];this.options.includeMatches&&o.push(function(e,t){var n=e.output;t.matches=[];for(var r=0,o=n.length;r<o;r+=1){var i=n[r];if(0!==i.matchedIndices.length){var a={indices:i.matchedIndices,value:i.value};i.key&&(a.key=i.key),i.hasOwnProperty("arrayIndex")&&i.arrayIndex>-1&&(a.arrayIndex=i.arrayIndex),t.matches.push(a);}}}),this.options.includeScore&&o.push(function(e,t){t.score=e.score;});for(var i=0,a=e.length;i<a;i+=1){var s=e[i];if(this.options.id&&(s.item=this.options.getFn(s.item,this.options.id)[0]),o.length){for(var c={item:s.item},h=0,l=o.length;h<l;h+=1){ o[h](s,c); }t.push(c);}else { t.push(s.item); }}return t}},{key:"_log",value:function(){var e;this.options.verbose&&(e=console).log.apply(e,arguments);}}])&&o(t.prototype,n),e}();e.exports=c;},function(e,t,n){function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}var o=n(3),i=n(4),a=n(7),s=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.isCaseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m;!function(e,t){if(!(e instanceof t)){ throw new TypeError("Cannot call a class as a function") }}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k},this.pattern=this.options.isCaseSensitive?t:t.toLowerCase(),this.pattern.length<=u&&(this.patternAlphabet=a(this.pattern));}var t,n;return t=e,(n=[{key:"search",value:function(e){if(this.options.isCaseSensitive||(e=e.toLowerCase()),this.pattern===e){ return {isMatch:!0,score:0,matchedIndices:[[0,e.length-1]]}; }var t=this.options,n=t.maxPatternLength,r=t.tokenSeparator;if(this.pattern.length>n){ return o(e,this.pattern,r); }var a=this.options,s=a.location,c=a.distance,h=a.threshold,l=a.findAllMatches,u=a.minMatchCharLength;return i(e,this.pattern,this.patternAlphabet,{location:s,distance:c,threshold:h,findAllMatches:l,minMatchCharLength:u})}}])&&r(t.prototype,n),e}();e.exports=s;},function(e,t){var n=/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;e.exports=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:/ +/g,o=new RegExp(t.replace(n,"\\$&").replace(r,"|")),i=e.match(o),a=!!i,s=[];if(a){ for(var c=0,h=i.length;c<h;c+=1){var l=i[c];s.push([e.indexOf(l),l.length-1]);} }return {score:a?.5:1,isMatch:a,matchedIndices:s}};},function(e,t,n){var r=n(5),o=n(6);e.exports=function(e,t,n,i){for(var a=i.location,s=void 0===a?0:a,c=i.distance,h=void 0===c?100:c,l=i.threshold,u=void 0===l?.6:l,f=i.findAllMatches,d=void 0!==f&&f,v=i.minMatchCharLength,p=void 0===v?1:v,g=s,y=e.length,m=u,k=e.indexOf(t,g),S=t.length,x=[],b=0;b<y;b+=1){ x[b]=0; }if(-1!==k){var M=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});if(m=Math.min(M,m),-1!==(k=e.lastIndexOf(t,g+S))){var _=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});m=Math.min(_,m);}}k=-1;for(var L=[],w=1,A=S+y,C=1<<(S<=31?S-1:30),I=0;I<S;I+=1){for(var O=0,j=A;O<j;){r(t,{errors:I,currentLocation:g+j,expectedLocation:g,distance:h})<=m?O=j:A=j,j=Math.floor((A-O)/2+O);}A=j;var P=Math.max(1,g-j+1),F=d?y:Math.min(g+j,y)+S,T=Array(F+2);T[F+1]=(1<<I)-1;for(var z=F;z>=P;z-=1){var E=z-1,K=n[e.charAt(E)];if(K&&(x[E]=1),T[z]=(T[z+1]<<1|1)&K,0!==I&&(T[z]|=(L[z+1]|L[z])<<1|1|L[z+1]),T[z]&C&&(w=r(t,{errors:I,currentLocation:E,expectedLocation:g,distance:h}))<=m){if(m=w,(k=E)<=g){ break; }P=Math.max(1,2*g-k);}}if(r(t,{errors:I+1,currentLocation:g,expectedLocation:g,distance:h})>m){ break; }L=T;}return {isMatch:k>=0,score:0===w?.001:w,matchedIndices:o(x,p)}};},function(e,t){e.exports=function(e,t){var n=t.errors,r=void 0===n?0:n,o=t.currentLocation,i=void 0===o?0:o,a=t.expectedLocation,s=void 0===a?0:a,c=t.distance,h=void 0===c?100:c,l=r/e.length,u=Math.abs(s-i);return h?l+u/h:u?1:l};},function(e,t){e.exports=function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=[],r=-1,o=-1,i=0,a=e.length;i<a;i+=1){var s=e[i];s&&-1===r?r=i:s||-1===r||((o=i-1)-r+1>=t&&n.push([r,o]),r=-1);}return e[i-1]&&i-r>=t&&n.push([r,i-1]),n};},function(e,t){e.exports=function(e){for(var t={},n=e.length,r=0;r<n;r+=1){ t[e.charAt(r)]=0; }for(var o=0;o<n;o+=1){ t[e.charAt(o)]|=1<<n-o-1; }return t};},function(e,t,n){var r=n(0);e.exports=function(e,t){return function e(t,n,o){if(n){var i=n.indexOf("."),a=n,s=null;-1!==i&&(a=n.slice(0,i),s=n.slice(i+1));var c=t[a];if(null!=c){ if(s||"string"!=typeof c&&"number"!=typeof c){ if(r(c)){ for(var h=0,l=c.length;h<l;h+=1){ e(c[h],s,o); } }else { s&&e(c,s,o); } }else { o.push(c.toString()); } }}else { o.push(t); }return o}(e,t,[])};}])});
	});

	var Fuse = unwrapExports(fuse);
	var fuse_1 = fuse.Fuse;

	var hyper_min = createCommonjsModule(function (module) {
	!function(){function e(){}function t(t,n){
	var arguments$1 = arguments;
	var o,r,i,l,a=W;for(l=arguments.length;l-- >2;){ S.push(arguments$1[l]); }n&&null!=n.children&&(S.length||S.push(n.children),delete n.children);while(S.length){ if((r=S.pop())&&void 0!==r.pop){ for(l=r.length;l--;){ S.push(r[l]); } }else{ "boolean"==typeof r&&(r=null),(i="function"!=typeof t)&&(null==r?r="":"number"==typeof r?r+="":"string"!=typeof r&&(i=!1)),i&&o?a[a.length-1]+=r:a===W?a=[r]:a.push(r),o=i; } }var _=new e;return _.nodeName=t,_.children=a,_.attributes=null==n?void 0:n,_.key=null==n?void 0:n.key,_}function n(e,t){for(var n in t){ e[n]=t[n]; }return e}function o(e){!e.__d&&(e.__d=!0)&&1==A.push(e)&&(V)(r);}function r(){var e,t=A;A=[];while(e=t.pop()){ e.__d&&N(e); }}function i(e,t,n){return "string"==typeof t||"number"==typeof t?void 0!==e.splitText:"string"==typeof t.nodeName?!e._componentConstructor&&l(e,t.nodeName):n||e._componentConstructor===t.nodeName}function l(e,t){return e.__n===t||e.nodeName.toLowerCase()===t.toLowerCase()}function a(e){var t=n({},e.attributes);t.children=e.children;var o=e.nodeName.defaultProps;if(void 0!==o){ for(var r in o){ void 0===t[r]&&(t[r]=o[r]); } }return t}function _(e,t){var n=t?document.createElementNS("http://www.w3.org/2000/svg",e):document.createElement(e);return n.__n=e,n}function u(e){var t=e.parentNode;t&&t.removeChild(e);}function p(e,t,n,o,r){if("className"===t&&(t="class"),"key"===t);else if("ref"===t){ n&&n(null),o&&o(e); }else if("class"!==t||r){ if("style"===t){if(o&&"string"!=typeof o&&"string"!=typeof n||(e.style.cssText=o||""),o&&"object"==typeof o){if("string"!=typeof n){ for(var i in n){ i in o||(e.style[i]=""); } }for(var i in o){ e.style[i]="number"==typeof o[i]&&!1===P.test(i)?o[i]+"px":o[i]; }}}else if("html"===t){ o&&(e.innerHTML=o); }else if("o"==t[0]&&"n"==t[1]){var l=t!==(t=t.replace(/Capture$/,""));t=t.toLowerCase().substring(2),o?n||e.addEventListener(t,s,l):e.removeEventListener(t,s,l),(e.__l||(e.__l={}))[t]=o;}else if("list"!==t&&"type"!==t&&!r&&t in e){ c(e,t,null==o?"":o),null!=o&&!1!==o||e.removeAttribute(t); }else{var a=r&&t!==(t=t.replace(/^xlink\:?/,""));null==o||!1===o?a?e.removeAttributeNS("http://www.w3.org/1999/xlink",t.toLowerCase()):e.removeAttribute(t):"function"!=typeof o&&(a?e.setAttributeNS("http://www.w3.org/1999/xlink",t.toLowerCase(),o):e.setAttribute(t,o));} }else { e.className=o||""; }}function c(e,t,n){try{e[t]=n;}catch(e){}}function s(e){return this.__l[e.type](e)}function f(){var e;while(e=E.pop()){ e.on_mounted&&e.on_mounted(); }}function d(e,t,n,o,r,i){D++||(H=null!=r&&void 0!==r.ownerSVGElement,R=null!=e&&!("__hyperattr_"in e));var l=h(e,t,n,o,i);return r&&l.parentNode!==r&&r.appendChild(l),--D||(R=!1,i||f()),l}function h(e,t,n,o,r){var i=e,a=H;if(null!=t&&"boolean"!=typeof t||(t=""),"string"==typeof t||"number"==typeof t){ return e&&void 0!==e.splitText&&e.parentNode&&(!e._component||r)?e.nodeValue!=t&&(e.nodeValue=t):(i=document.createTextNode(t),e&&(e.parentNode&&e.parentNode.replaceChild(i,e),m(e,!0))),i.__hyperattr_=!0,i; }var u=t.nodeName;if("function"==typeof u){ return k(e,t,n,o); }if(H="svg"===u||"foreignObject"!==u&&H,u+="",(!e||!l(e,u))&&(i=_(u,H),e)){while(e.firstChild){ i.appendChild(e.firstChild); }e.parentNode&&e.parentNode.replaceChild(i,e),m(e,!0);}var p=i.firstChild,c=i.__hyperattr_,s=t.children;if(null==c){c=i.__hyperattr_={};for(var f=i.attributes,d=f.length;d--;){ c[f[d].name]=f[d].value; }}return !R&&s&&1===s.length&&"string"==typeof s[0]&&null!=p&&void 0!==p.splitText&&null==p.nextSibling?p.nodeValue!=s[0]&&(p.nodeValue=s[0]):(s&&s.length||null!=p)&&v(i,s,n,o,R||null!=c.html),y(i,t.attributes,c),H=a,i}function v(e,t,n,o,r){var l,a,_,p,c,s=e.childNodes,f=[],d={},v=0,b=0,y=s.length,g=0,w=t?t.length:0;if(0!==y){ for(var C=0;C<y;C++){var x=s[C],N=x.__hyperattr_,k=w&&N?x._component?x._component.__k:N.key:null;null!=k?(v++,d[k]=x):(N||(void 0!==x.splitText?!r||x.nodeValue.trim():r))&&(f[g++]=x);} }if(0!==w){ for(var C=0;C<w;C++){p=t[C],c=null;var k=p.key;if(null!=k){ v&&void 0!==d[k]&&(c=d[k],d[k]=void 0,v--); }else if(!c&&b<g){ for(l=b;l<g;l++){ if(void 0!==f[l]&&i(a=f[l],p,r)){c=a,f[l]=void 0,l===g-1&&g--,l===b&&b++;break} } }c=h(c,p,n,o),_=s[C],c&&c!==e&&c!==_&&(null==_?e.appendChild(c):c===_.nextSibling?u(_):e.insertBefore(c,_));} }if(v){ for(var C in d){ void 0!==d[C]&&m(d[C],!1); } }while(b<=g){ void 0!==(c=f[g--])&&m(c,!1); }}function m(e,t){var n=e._component;n?U(n):(null!=e.__hyperattr_&&e.__hyperattr_.ref&&e.__hyperattr_.ref(null),!1!==t&&null!=e.__hyperattr_||u(e),b(e));}function b(e){e=e.lastChild;while(e){var t=e.previousSibling;m(e,!0),e=t;}}function y(e,t,n){var o;for(o in n){ t&&null!=t[o]||null==n[o]||p(e,o,n[o],n[o]=void 0,H); }for(o in t){ "children"===o||"innerHTML"===o||o in n&&t[o]===("value"===o||"checked"===o?e[o]:n[o])||p(e,o,n[o],n[o]=t[o],H); }}function g(e){var t=e.constructor.name;(j[t]||(j[t]=[])).push(e);}function w(e,t,n){var o,r=j[e.name];if(e.prototype&&e.prototype.render?(o=new e(t,n),L.call(o,t,n)):(o=new L(t,n),o.constructor=e,o.render=C),r){ for(var i=r.length;i--;){ if(r[i].constructor===e){o.__b=r[i].__b,r.splice(i,1);break} } }return o}function C(e,t,n){return this.constructor(e,n)}function x(e,t,n,r,i){e.__x||(e.__x=!0,(e.__r=t.ref)&&delete t.ref,(e.__k=t.key)&&delete t.key,!e.base||i?e.on_mount&&e.on_mount():e.componentWillReceiveProps&&e.componentWillReceiveProps(t,r),r&&r!==e.context&&(e.__c||(e.__c=e.context),e.context=r),e.__p||(e.__p=e.props),e.props=t,e.__x=!1,0!==n&&(1!==n&&!1===M.syncComponentUpdates&&e.base?o(e):N(e,1,i)),e.__r&&e.__r(e));}function N(e,t,o,r){if(!e.__x){var i,l,_,u=e.props,p=e.state,c=e.context,s=e.__p||u,h=e.__s||p,v=e.__c||c,b=e.base,y=e.__b,g=b||y,C=e._component,k=!1;if(b&&(e.props=s,e.state=h,e.context=v,2!==t&&e.shouldComponentUpdate&&!1===e.shouldComponentUpdate(u,p,c)?k=!0:e.componentWillUpdate&&e.componentWillUpdate(u,p,c),e.props=u,e.state=p,e.context=c),e.__p=e.__s=e.__c=e.__b=null,e.__d=!1,!k){i=e.render(u,p,c),e.getChildContext&&(c=n(n({},c),e.getChildContext()));var L,T,S=i&&i.nodeName;if("function"==typeof S){var W=a(i);l=C,l&&l.constructor===S&&W.key==l.__k?x(l,W,1,c,!1):(L=l,e._component=l=w(S,W,c),l.__b=l.__b||y,l.__u=e,x(l,W,0,c,!1),N(l,1,o,!0)),T=l.base;}else { _=g,L=C,L&&(_=e._component=null),(g||1===t)&&(_&&(_._component=null),T=d(_,i,c,o||!b,g&&g.parentNode,!0)); }if(g&&T!==g&&l!==C){var P=g.parentNode;P&&T!==P&&(P.replaceChild(T,g),L||(g._component=null,m(g,!1)));}if(L&&U(L),e.base=T,T&&!r){var V=e,A=e;while(A=A.__u){ (V=A).base=T; }T._component=V,T._componentConstructor=V.constructor;}}if(!b||o?E.unshift(e):k||(e.on_updated&&e.on_updated(s,h,v),M.afterUpdate&&M.afterUpdate(e)),null!=e.__h){ while(e.__h.length){ e.__h.pop().call(e); } }D||r||f();}}function k(e,t,n,o){var r=e&&e._component,i=r,l=e,_=r&&e._componentConstructor===t.nodeName,u=_,p=a(t);while(r&&!u&&(r=r.__u)){ u=r.constructor===t.nodeName; }return r&&u&&(!o||r._component)?(x(r,p,3,n,o),e=r.base):(i&&!_&&(U(i),e=l=null),r=w(t.nodeName,p,n),e&&!r.__b&&(r.__b=e,l=null),x(r,p,1,n,o),e=r.base,l&&e!==l&&(l._component=null,m(l,!1))),e}function U(e){var t=e.base;e.__x=!0,e.componentWillUnmount&&e.componentWillUnmount(),e.base=null;var n=e._component;n?U(n):t&&(t.__hyperattr_&&t.__hyperattr_.ref&&t.__hyperattr_.ref(null),e.__b=t,u(t),g(e),b(t)),e.__r&&e.__r(null);}function L(e,t){this.__d=!0,this.context=t,this.props=e,this.state=this.state||{};}function T(e,t,n){return d(n,e,{},!1,t,!1)}var M={},S=[],W=[],P=/acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i,V="function"==typeof Promise?Promise.resolve().then.bind(Promise.resolve()):setTimeout,A=[],E=[],D=0,H=!1,R=!1,j={};n(L.prototype,{set_state:function(e,t){var r=this.state;this.__s||(this.__s=n({},r)),n(r,"function"==typeof e?e(r,this.props):e),t&&(this.__h=this.__h||[]).push(t),o(this);},forceUpdate:function(e){e&&(this.__h=this.__h||[]).push(e),N(this,2);},render:function(){}});var I={h:t,Component:L,render:T};module.exports=I;}();
	});

	// Frappe Chat

	/* eslint semi: "never" */
	// Fuck semicolons - https://mislav.net/2010/05/semicolons

	// frappe extensions

	/**
	 * @description The base class for all Frappe Errors.
	 *
	 * @example
	 * try
	 *      throw new frappe.Error("foobar")
	 * catch (e)
	 *      console.log(e.name)
	 * // returns "FrappeError"
	 *
	 * @see  https://stackoverflow.com/a/32749533
	 * @todo Requires "transform-builtin-extend" for Babel 6
	 */
	frappe.Error = Error;
	// class extends Error {
	// 	constructor (message) {
	// 		super (message)

	// 		this.name = 'FrappeError'

	// 		if ( typeof Error.captureStackTrace === 'function' )
	// 			Error.captureStackTrace(this, this.constructor)
	// 		else
	// 			this.stack = (new Error(message)).stack
	// 	}
	// }

	/**
	 * @description TypeError
	 */
	frappe.TypeError  = TypeError;
	// class extends frappe.Error {
	// 	constructor (message) {
	// 		super (message)

	// 		this.name = this.constructor.name
	// 	}
	// }

	/**
	 * @description ValueError
	 */
	frappe.ValueError = Error;
	// class extends frappe.Error {
	// 	constructor (message) {
	// 		super (message)

	// 		this.name = this.constructor.name
	// 	}
	// }

	/**
	 * @description ImportError
	 */
	frappe.ImportError = Error;
	// class extends frappe.Error {
	// 	constructor (message) {
	// 		super (message)

	// 		this.name  = this.constructor.name
	// 	}
	// }

	// frappe.datetime
	frappe.provide('frappe.datetime');

	/**
	 * @description Frappe's datetime object. (Inspired by Python's datetime object).
	 *
	 * @example
	 * const datetime = new frappe.datetime.datetime()
	 */
	frappe.datetime.datetime = class {
		/**
		 * @description Frappe's datetime Class's constructor.
		 */
		constructor (instance, format) {
		if ( format === void 0 ) format = null;

			if ( typeof moment === 'undefined' )
				{ throw new frappe.ImportError("Moment.js not installed.") }

			this.moment = instance ? moment(instance, format) : moment();
		}

		/**
		 * @description Returns a formatted string of the datetime object.
		 */
		format (format) {
			if ( format === void 0 ) format = null;

			var  formatted = this.moment.format(format);
			return formatted
		}
	};

	/**
	 * @description Frappe's daterange object.
	 *
	 * @example
	 * const range = new frappe.datetime.range(frappe.datetime.now(), frappe.datetime.now())
	 * range.contains(frappe.datetime.now())
	 */
	frappe.datetime.range   = class {
		constructor (start, end) {
			if ( typeof moment === undefined )
				{ throw new frappe.ImportError("Moment.js not installed.") }

			this.start = start;
			this.end   = end;
		}

		contains (datetime) {
			var  contains = datetime.moment.isBetween(this.start.moment, this.end.moment);
			return contains
		}
	};

	/**
	 * @description Returns the current datetime.
	 *
	 * @example
	 * const datetime = new frappe.datetime.now()
	 */
	frappe.datetime.now   = function () { return new frappe.datetime.datetime(); };

	frappe.datetime.equal = function (a, b, type) {
		a = a.moment;
		b = b.moment;

		var equal = a.isSame(b, type);

		return equal
	};

	/**
	 * @description Compares two frappe.datetime.datetime objects.
	 *
	 * @param   {frappe.datetime.datetime} a - A frappe.datetime.datetime/moment object.
	 * @param   {frappe.datetime.datetime} b - A frappe.datetime.datetime/moment object.
	 *
	 * @returns {number} 0 (if a and b are equal), 1 (if a is before b), -1 (if a is after b).
	 *
	 * @example
	 * frappe.datetime.compare(frappe.datetime.now(), frappe.datetime.now())
	 * // returns 0
	 * const then = frappe.datetime.now()
	 *
	 * frappe.datetime.compare(then, frappe.datetime.now())
	 * // returns 1
	 */
	frappe.datetime.compare = function (a, b) {
		a = a.moment;
		b = b.moment;

		if ( a.isBefore(b) )
			{ return  1 }
		else
		if ( b.isBefore(a) )
			{ return -1 }
		else
			{ return  0 }
	};

	// frappe.quick_edit
	frappe.quick_edit      = function (doctype, docname, fn) {
		return new Promise(function (resolve) {
			frappe.model.with_doctype(doctype, function () {
				frappe.db.get_doc(doctype, docname).then(function (doc)  {
					var meta     = frappe.get_meta(doctype);
					var fields   = meta.fields;
					var required = fields.filter(function (f) { return f.reqd || f.bold && !f.read_only; });

					required.map(function (f) {
						if(f.fieldname == 'content' && doc.type == 'File') {
							f['read_only'] = 1;
						}
					});

					var dialog   = new frappe.ui.Dialog({
						 title: __(("Edit " + doctype + " (" + docname + ")")),
						fields: required,
						action: {
							primary: {
								   label: __("Save"),
								onsubmit: function (values) {
									frappe.call('frappe.client.save',
										{ doc: Object.assign({}, {doctype: doctype, docname: docname}, doc, values) })
										  .then(function (r) {
											if ( fn )
												{ fn(r.message); }

											resolve(r.message);
										  });

									dialog.hide();
								}
							},
							secondary: {
								label: __("Discard")
							}
						}
					});
					dialog.set_values(doc);

					var $element = $(dialog.body);
					$element.append(("\n\t\t\t\t\t<div class=\"qe-fp\" style=\"padding-top: '15px'; padding-bottom: '15px'; padding-left: '7px'\">\n\t\t\t\t\t\t<button class=\"btn btn-default btn-sm\">\n\t\t\t\t\t\t\t" + (__("Edit in Full Page")) + "\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t"));
					$element.find('.qe-fp').click(function () {
						dialog.hide();
						frappe.set_route(("Form/" + doctype + "/" + docname));
					});

					dialog.show();
				});
			});
		})
	};

	// frappe._
	// frappe's utility namespace.
	frappe.provide('frappe._');

	// String Utilities

	/**
	 * @description Python-inspired format extension for string objects.
	 *
	 * @param  {string} string - A string with placeholders.
	 * @param  {object} object - An object with placeholder, value pairs.
	 *
	 * @return {string}        - The formatted string.
	 *
	 * @example
	 * frappe._.format('{foo} {bar}', { bar: 'foo', foo: 'bar' })
	 * // returns "bar foo"
	 */
	frappe._.format = function (string, object) {
		for (var key in object)
			{ string  = string.replace(("{" + key + "}"), object[key]); }

		return string
	};

	/**
	 * @description Fuzzy Search a given query within a dataset.
	 *
	 * @param  {string} query   - A query string.
	 * @param  {array}  dataset - A dataset to search within, can contain singletons or objects.
	 * @param  {object} options - Options as per fuze.js
	 *
	 * @return {array}          - The fuzzy matched index/object within the dataset.
	 *
	 * @example
	 * frappe._.fuzzy_search("foobar", ["foobar", "bartender"])
	 * // returns [0, 1]
	 *
	 * @see http://fusejs.io
	 */
	frappe._.fuzzy_search = function (query, dataset, options) {
		var DEFAULT     = {
					shouldSort: true,
					 threshold: 0.6,
					  location: 0,
					  distance: 100,
			minMatchCharLength: 1,
			  maxPatternLength: 32
		};
		options       = Object.assign({}, DEFAULT, options);

		var fuse    = new Fuse(dataset, options);
		var result  = fuse.search(query);

		return result
	};

	/**
	 * @description Pluralizes a given word.
	 *
	 * @param  {string} word  - The word to be pluralized.
	 * @param  {number} count - The count.
	 *
	 * @return {string}       - The pluralized string.
	 *
	 * @example
	 * frappe._.pluralize('member',  1)
	 * // returns "member"
	 * frappe._.pluralize('members', 0)
	 * // returns "members"
	 *
	 * @todo Handle more edge cases.
	 */
	frappe._.pluralize = function (word, count, suffix) {
		if ( count === void 0 ) count = 0;
		if ( suffix === void 0 ) suffix = 's';

		return ("" + word + (count === 1 ? '' : suffix));
	};

	/**
	 * @description Captializes a given string.
	 *
	 * @param   {word}  - The word to be capitalized.
	 *
	 * @return {string} - The capitalized word.
	 *
	 * @example
	 * frappe._.capitalize('foobar')
	 * // returns "Foobar"
	 */
	frappe._.capitalize = function (word) { return ("" + (word.charAt(0).toUpperCase()) + (word.slice(1))); };

	// Array Utilities

	/**
	 * @description Returns the first element of an array.
	 *
	 * @param   {array} array - The array.
	 *
	 * @returns - The first element of an array, undefined elsewise.
	 *
	 * @example
	 * frappe._.head([1, 2, 3])
	 * // returns 1
	 * frappe._.head([])
	 * // returns undefined
	 */
	frappe._.head = function (arr) { return frappe._.is_empty(arr) ? undefined : arr[0]; };

	/**
	 * @description Returns a copy of the given array (shallow).
	 *
	 * @param   {array} array - The array to be copied.
	 *
	 * @returns {array}       - The copied array.
	 *
	 * @example
	 * frappe._.copy_array(["foobar", "barfoo"])
	 * // returns ["foobar", "barfoo"]
	 *
	 * @todo Add optional deep copy.
	 */
	frappe._.copy_array = function (array) {
		if ( Array.isArray(array) )
			{ return array.slice() }
		else
			{ throw frappe.TypeError(("Expected Array, recieved " + (typeof array) + " instead.")) }
	};

	/**
	 * @description Check whether an array|string|object|jQuery is empty.
	 *
	 * @param   {any}     value - The value to be checked on.
	 *
	 * @returns {boolean}       - Returns if the object is empty.
	 *
	 * @example
	 * frappe._.is_empty([])      // returns true
	 * frappe._.is_empty(["foo"]) // returns false
	 *
	 * frappe._.is_empty("")      // returns true
	 * frappe._.is_empty("foo")   // returns false
	 *
	 * frappe._.is_empty({ })            // returns true
	 * frappe._.is_empty({ foo: "bar" }) // returns false
	 *
	 * frappe._.is_empty($('.papito'))   // returns false
	 *
	 * @todo Handle other cases.
	 */
	frappe._.is_empty = function (value) {
		var empty = false;

		if ( value === undefined || value === null )
			{ empty = true; }
		else
		if ( Array.isArray(value) || typeof value === 'string' || value instanceof $ )
			{ empty = value.length === 0; }
		else
		if ( typeof value === 'object' )
			{ empty = Object.keys(value).length === 0; }

		return empty
	};

	/**
	 * @description Converts a singleton to an array, if required.
	 *
	 * @param {object} item - An object
	 *
	 * @example
	 * frappe._.as_array("foo")
	 * // returns ["foo"]
	 *
	 * frappe._.as_array(["foo"])
	 * // returns ["foo"]
	 *
	 * @see https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-
	 */
	frappe._.as_array = function (item) { return Array.isArray(item) ? item : [item]; };

	/**
	 * @description Return a singleton if array contains a single element.
	 *
	 * @param   {array}        list - An array to squash.
	 *
	 * @returns {array|object}      - Returns an array if there's more than 1 object else the first object itself.
	 *
	 * @example
	 * frappe._.squash(["foo"])
	 * // returns "foo"
	 *
	 * frappe._.squash(["foo", "bar"])
	 * // returns ["foo", "bar"]
	 */
	frappe._.squash = function (list) { return Array.isArray(list) && list.length === 1 ? list[0] : list; };

	/**
	 * @description Returns true, if the current device is a mobile device.
	 *
	 * @example
	 * frappe._.is_mobile()
	 * // returns true|false
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
	 */
	frappe._.is_mobile = function () {
		var regex    = new RegExp("Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini", "i");
		var agent    = navigator.userAgent;
		var mobile   = regex.test(agent);

		return mobile
	};

	/**
	 * @description Removes falsey values from an array.
	 *
	 * @example
	 * frappe._.compact([1, 2, false, NaN, ''])
	 * // returns [1, 2]
	 */
	frappe._.compact   = function (array) { return array.filter(Boolean); };

	// extend utils to base.
	frappe.utils       = Object.assign({}, frappe.utils, frappe._);

	// frappe extensions

	// frappe.user extensions
	/**
	 * @description Returns the first name of a User.
	 *
	 * @param {string} user - User
	 *
	 * @returns The first name of the user.
	 *
	 * @example
	 * frappe.user.first_name("Rahul Malhotra")
	 * // returns "Rahul"
	 */
	frappe.provide('frappe.user');
	frappe.user.first_name = function (user) { return frappe._.head(frappe.user.full_name(user).split(" ")); };

	frappe.provide('frappe.ui.keycode');
	frappe.ui.keycode = { RETURN: 13 };

	/**
	 * @description Frappe's Store Class
	 */
	 // frappe.stores  - A registry for frappe stores.
	frappe.provide('frappe.stores');
	frappe.stores = [ ];
	frappe.Store  = class
	{
		/**
		 * @description Frappe's Store Class's constructor.
		 *
		 * @param {string} name - Name of the logger.
		 */
		constructor (name) {
			if ( typeof name !== 'string' )
				{ throw new frappe.TypeError(("Expected string for name, got " + (typeof name) + " instead.")) }
			this.name = name;
		}

		/**
		 * @description Get instance of frappe.Store (return registered one if declared).
		 *
		 * @param {string} name - Name of the store.
		 */
		static get (name) {
			if ( !(name in frappe.stores) )
				{ frappe.stores[name] = new frappe.Store(name); }
			return frappe.stores[name]
		}

		set (key, value) { localStorage.setItem(((this.name) + ":" + key), value); }
		get (key, value) { return localStorage.getItem(((this.name) + ":" + key)) }
	};

	// frappe.loggers - A registry for frappe loggers.
	frappe.provide('frappe.loggers');
	/**
	 * @description Frappe's Logger Class
	 *
	 * @example
	 * frappe.log       = frappe.Logger.get('foobar')
	 * frappe.log.level = frappe.Logger.DEBUG
	 *
	 * frappe.log.info('foobar')
	 * // prints '[timestamp] foobar: foobar'
	 */
	frappe.Logger = class {
		/**
		 * @description Frappe's Logger Class's constructor.
		 *
		 * @param {string} name - Name of the logger.
		 */
		constructor (name, level) {
			if ( typeof name !== 'string' )
				{ throw new frappe.TypeError(("Expected string for name, got " + (typeof name) + " instead.")) }

			this.name   = name;
			this.level  = level;

			if ( !this.level ) {
				if ( frappe.boot.developer_mode )
					{ this.level = frappe.Logger.ERROR; }
				else
					{ this.level = frappe.Logger.NOTSET; }
			}
			this.format = frappe.Logger.FORMAT;
		}

		/**
		 * @description Get instance of frappe.Logger (return registered one if declared).
		 *
		 * @param {string} name - Name of the logger.
		 */
		static get (name, level) {
			if ( !(name in frappe.loggers) )
				{ frappe.loggers[name] = new frappe.Logger(name, level); }
			return frappe.loggers[name]
		}

		debug (message) { this.log(message, frappe.Logger.DEBUG); }
		info  (message) { this.log(message, frappe.Logger.INFO);  }
		warn  (message) { this.log(message, frappe.Logger.WARN);  }
		error (message) { this.log(message, frappe.Logger.ERROR); }

		log (message, level) {
			var timestamp   = frappe.datetime.now();

			if ( level.value <= this.level.value ) {
				var format  = frappe._.format(this.format, {
					time: timestamp.format('HH:mm:ss'),
					name: this.name
				});
				console.log(("%c " + format + ":"), ("color: " + (level.color)), message);
			}
		}
	};

	frappe.Logger.DEBUG  = { value: 10, color: '#616161', name: 'DEBUG'  };
	frappe.Logger.INFO   = { value: 20, color: '#2196F3', name: 'INFO'   };
	frappe.Logger.WARN   = { value: 30, color: '#FFC107', name: 'WARN'   };
	frappe.Logger.ERROR  = { value: 40, color: '#F44336', name: 'ERROR'  };
	frappe.Logger.NOTSET = { value:  0,                   name: 'NOTSET' };

	frappe.Logger.FORMAT = '{time} {name}';

	// frappe.chat
	frappe.provide('frappe.chat');

	frappe.log = frappe.Logger.get('frappe.chat', frappe.Logger.NOTSET);

	// frappe.chat.profile
	frappe.provide('frappe.chat.profile');

	/**
	 * @description Create a Chat Profile.
	 *
	 * @param   {string|array} fields - (Optional) fields to be retrieved after creating a Chat Profile.
	 * @param   {function}     fn     - (Optional) callback with the returned Chat Profile.
	 *
	 * @returns {Promise}
	 *
	 * @example
	 * frappe.chat.profile.create(console.log)
	 *
	 * frappe.chat.profile.create("status").then(console.log) // { status: "Online" }
	 */
	frappe.chat.profile.create = function (fields, fn) {
		if ( typeof fields === "function" ) {
			fn     = fields;
			fields = null;
		} else
		if ( typeof fields === "string" )
			{ fields = frappe._.as_array(fields); }

		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_profile.chat_profile.create",
				{ user: frappe.session.user, exists_ok: true, fields: fields },
					function (response) {
						if ( fn )
							{ fn(response.message); }

						resolve(response.message);
					});
		})
	};

	/**
	 * @description Updates a Chat Profile.
	 *
	 * @param   {string} user   - (Optional) Chat Profile User, defaults to session user.
	 * @param   {object} update - (Required) Updates to be dispatched.
	 *
	 * @example
	 * frappe.chat.profile.update(frappe.session.user, { "status": "Offline" })
	 */
	frappe.chat.profile.update = function (user, update, fn) {
		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_profile.chat_profile.update",
				{ user: user || frappe.session.user, data: update },
					function (response) {
						if ( fn )
							{ fn(response.message); }

						resolve(response.message);
					});
		})
	};

	// frappe.chat.profile.on
	frappe.provide('frappe.chat.profile.on');

	/**
	 * @description Triggers on a Chat Profile update of a user (Only if there's a one-on-one conversation).
	 *
	 * @param   {function} fn - (Optional) callback with the User and the Chat Profile update.
	 *
	 * @returns {Promise}
	 *
	 * @example
	 * frappe.chat.profile.on.update(function (user, update)
	 * {
	 *      // do stuff
	 * })
	 */
	frappe.chat.profile.on.update = function (fn) {
		frappe.realtime.on("frappe.chat.profile:update", function (r) { return fn(r.user, r.data); });
	};
	frappe.chat.profile.STATUSES
	=
	[
		{
			name: "Online",
		   color: "green"
		},
		{
			 name: "Away",
			color: "yellow"
		},
		{
			 name: "Busy",
			color: "red"
		},
		{
			 name: "Offline",
			color: "darkgrey"
		}
	];

	// frappe.chat.room
	frappe.provide('frappe.chat.room');

	/**
	 * @description Creates a Chat Room.
	 *
	 * @param   {string}       kind  - (Required) "Direct", "Group" or "Visitor".
	 * @param   {string}       owner - (Optional) Chat Room owner (defaults to current user).
	 * @param   {string|array} users - (Required for "Direct" and "Visitor", Optional for "Group") User(s) within Chat Room.
	 * @param   {string}       name  - Chat Room name.
	 * @param   {function}     fn    - callback with created Chat Room.
	 *
	 * @returns {Promise}
	 *
	 * @example
	 * frappe.chat.room.create("Direct", frappe.session.user, "foo@bar.com", function (room) {
	 *      // do stuff
	 * })
	 * frappe.chat.room.create("Group",  frappe.session.user, ["santa@gmail.com", "banta@gmail.com"], "Santa and Banta", function (room) {
	 *      // do stuff
	 * })
	 */
	frappe.chat.room.create = function (kind, owner, users, name, fn) {
		if ( typeof name === "function" ) {
			fn   = name;
			name = null;
		}

		users    = frappe._.as_array(users);

		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_room.chat_room.create",
				{ kind: kind, token: owner || frappe.session.user, users: users, name: name },
				function (r) {
					var room = r.message;
					room     = Object.assign({}, room, {creation: new frappe.datetime.datetime(room.creation)});

					if ( fn )
						{ fn(room); }

					resolve(room);
				});
		})
	};

	/**
	 * @description Returns Chat Room(s).
	 *
	 * @param   {string|array} names   - (Optional) Chat Room(s) to retrieve.
	 * @param   {string|array} fields  - (Optional) fields to be retrieved for each Chat Room.
	 * @param   {function}     fn      - (Optional) callback with the returned Chat Room(s).
	 *
	 * @returns {Promise}
	 *
	 * @example
	 * frappe.chat.room.get(function (rooms) {
	 *      // do stuff
	 * })
	 * frappe.chat.room.get().then(function (rooms) {
	 *      // do stuff
	 * })
	 *
	 * frappe.chat.room.get(null, ["room_name", "avatar"], function (rooms) {
	 *      // do stuff
	 * })
	 *
	 * frappe.chat.room.get("CR00001", "room_name", function (room) {
	 *      // do stuff
	 * })
	 *
	 * frappe.chat.room.get(["CR00001", "CR00002"], ["room_name", "last_message"], function (rooms) {
	 *
	 * })
	 */
	frappe.chat.room.get = function (names, fields, fn) {
		if ( typeof names === "function" ) {
			fn     = names;
			names  = null;
			fields = null;
		}
		else
		if ( typeof names === "string" ) {
			names  = frappe._.as_array(names);

			if ( typeof fields === "function" ) {
				fn     = fields;
				fields = null;
			}
			else
			if ( typeof fields === "string" )
				{ fields = frappe._.as_array(fields); }
		}

		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_room.chat_room.get",
				{ user: frappe.session.user, rooms: names, fields: fields },
					function (response) {
						var rooms = response.message;
						if ( rooms ) { // frappe.api BOGZ! (emtpy arrays are falsified, not good design).
							rooms = frappe._.as_array(rooms);
							rooms = rooms.map(function (room) {
								return Object.assign({}, room, {creation: new frappe.datetime.datetime(room.creation),
									last_message: room.last_message ? Object.assign({}, room.last_message,
										{creation: new frappe.datetime.datetime(room.last_message.creation)}) : null})
							});
							rooms = frappe._.squash(rooms);
						}
						else
							{ rooms = [ ]; }

						if ( fn )
							{ fn(rooms); }

						resolve(rooms);
					});
		})
	};

	/**
	 * @description Subscribe current user to said Chat Room(s).
	 *
	 * @param {string|array} rooms - Chat Room(s).
	 *
	 * @example
	 * frappe.chat.room.subscribe("CR00001")
	 */
	frappe.chat.room.subscribe = function (rooms) {
		frappe.realtime.publish("frappe.chat.room:subscribe", rooms);
	};

	/**
	 * @description Get Chat Room history.
	 *
	 * @param   {string} name - Chat Room name
	 *
	 * @returns {Promise}     - Chat Message(s)
	 *
	 * @example
	 * frappe.chat.room.history(function (messages)
	 * {
	 *      // do stuff.
	 * })
	 */
	frappe.chat.room.history = function (name, fn) {
		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_room.chat_room.history",
				{ room: name, user: frappe.session.user },
					function (r) {
						var messages = r.message ? frappe._.as_array(r.message) : [ ]; // frappe.api BOGZ! (emtpy arrays are falsified, not good design).
						messages     = messages.map(function (m) {
							return Object.assign({}, m,
								{creation: new frappe.datetime.datetime(m.creation)})
						});

						if ( fn )
							{ fn(messages); }

						resolve(messages);
					});
		})
	};

	/**
	 * @description Searches Rooms based on a query.
	 *
	 * @param   {string} query - The query string.
	 * @param   {array}  rooms - A list of Chat Rooms.
	 *
	 * @returns {array}        - A fuzzy searched list of rooms.
	 */
	frappe.chat.room.search = function (query, rooms) {
		var dataset = rooms.map(function (r) {
			if ( r.room_name )
				{ return r.room_name }
			else
				if ( r.owner === frappe.session.user )
					{ return frappe.user.full_name(frappe._.squash(r.users)) }
				else
					{ return frappe.user.full_name(r.owner) }
		});
		var results = frappe._.fuzzy_search(query, dataset);
		rooms         = results.map(function (i) { return rooms[i]; });

		return rooms
	};

	/**
	 * @description Sort Chat Room(s) based on Last Message Timestamp or Creation Date.
	 *
	 * @param {array}   - A list of Chat Room(s)
	 * @param {compare} - (Optional) a comparision function.
	 */
	frappe.chat.room.sort = function (rooms, compare) {
		if ( compare === void 0 ) compare = null;

		compare = compare || function (a, b) {
			if ( a.last_message && b.last_message )
				{ return frappe.datetime.compare(a.last_message.creation, b.last_message.creation) }
			else
			if ( a.last_message )
				{ return frappe.datetime.compare(a.last_message.creation, b.creation) }
			else
			if ( b.last_message )
				{ return frappe.datetime.compare(a.creation, b.last_message.creation) }
			else
				{ return frappe.datetime.compare(a.creation, b.creation) }
		};
		rooms.sort(compare);

		return rooms
	};

	// frappe.chat.room.on
	frappe.provide('frappe.chat.room.on');

	/**
	 * @description Triggers on Chat Room updated.
	 *
	 * @param {function} fn - callback with the Chat Room and Update.
	 */
	frappe.chat.room.on.update = function (fn) {
		frappe.realtime.on("frappe.chat.room:update", function (r) {
			if ( r.data.last_message )
				// creation to frappe.datetime.datetime (easier to manipulate).
				{ r.data = Object.assign({}, r.data, {last_message: Object.assign({}, r.data.last_message, {creation: new frappe.datetime.datetime(r.data.last_message.creation)})}); }

			fn(r.room, r.data);
		});
	};

	/**
	 * @description Triggers on Chat Room created.
	 *
	 * @param {function} fn - callback with the created Chat Room.
	 */
	frappe.chat.room.on.create = function (fn) {
		frappe.realtime.on("frappe.chat.room:create", function (r) { return fn(Object.assign({}, r, {creation: new frappe.datetime.datetime(r.creation)})); }
		);
	};

	/**
	 * @description Triggers when a User is typing in a Chat Room.
	 *
	 * @param {function} fn - callback with the typing User within the Chat Room.
	 */
	frappe.chat.room.on.typing = function (fn) {
		frappe.realtime.on("frappe.chat.room:typing", function (r) { return fn(r.room, r.user); });
	};

	// frappe.chat.message
	frappe.provide('frappe.chat.message');

	frappe.chat.message.typing = function (room, user) {
		frappe.realtime.publish("frappe.chat.message:typing", { user: user || frappe.session.user, room: room });
	};

	frappe.chat.message.send   = function (room, message, type) {
		if ( type === void 0 ) type = "Content";

		frappe.call("frappe.chat.doctype.chat_message.chat_message.send",
			{ user: frappe.session.user, room: room, content: message, type: type });
	};

	frappe.chat.message.update = function (message, update, fn) {
		return new Promise(function (resolve) {
			frappe.call('frappe.chat.doctype.chat_message.chat_message.update',
				{ user: frappe.session.user, message: message, update: update },
				function (r) {
					if ( fn )
						{ fn(response.message); }

					resolve(response.message);
				});
		})
	};

	frappe.chat.message.sort   = function (messages) {
		if ( !frappe._.is_empty(messages) )
			{ messages.sort(function (a, b) { return frappe.datetime.compare(b.creation, a.creation); }); }

		return messages
	};

	/**
	 * @description Add user to seen (defaults to session.user)
	 */
	frappe.chat.message.seen   = function (mess, user) {
		frappe.call('frappe.chat.doctype.chat_message.chat_message.seen',
			{ message: mess, user: user || frappe.session.user });
	};

	frappe.provide('frappe.chat.message.on');
	frappe.chat.message.on.create = function (fn) {
		frappe.realtime.on("frappe.chat.message:create", function (r) { return fn(Object.assign({}, r, {creation: new frappe.datetime.datetime(r.creation)})); }
		);
	};

	frappe.chat.message.on.update = function (fn) {
		frappe.realtime.on("frappe.chat.message:update", function (r) { return fn(r.message, r.data); });
	};

	frappe.chat.pretty_datetime   = function (date) {
		var today    = moment();
		var instance = date.moment;

		if ( today.isSame(instance, "d") )
			{ return instance.format("hh:mm A") }
		else
		if ( today.isSame(instance, "week") )
			{ return instance.format("dddd") }
		else
			{ return instance.format("DD/MM/YYYY") }
	};

	// frappe.chat.sound
	frappe.provide('frappe.chat.sound');

	/**
	 * @description Plays a given registered sound.
	 *
	 * @param {value} - The name of the registered sound.
	 *
	 * @example
	 * frappe.chat.sound.play("message")
	 */
	frappe.chat.sound.play  = function (name, volume) {
		if ( volume === void 0 ) volume = 0.1;

		// frappe._.play_sound(`chat-${name}`)
		var $audio = $("<audio class=\"chat-audio\"/>");
		$audio.attr('volume', volume);

		if  ( frappe._.is_empty($audio) )
			{ $(document).append($audio); }

		if  ( !$audio.paused ) {
			frappe.log.info('Stopping sound playing.');
			$audio[0].pause();
			$audio.attr('currentTime', 0);
		}

		frappe.log.info('Playing sound.');
		$audio.attr('src', ((frappe.chat.sound.PATH) + "/chat-" + name + ".mp3"));
		$audio[0].play();
	};
	frappe.chat.sound.PATH  = '/assets/frappe/sounds';

	// frappe.chat.emoji
	frappe.chat.emojis = [ ];
	frappe.chat.emoji  = function (fn) {
		return new Promise(function (resolve) {
			if ( !frappe._.is_empty(frappe.chat.emojis) ) {
				if ( fn )
					{ fn(frappe.chat.emojis); }

				resolve(frappe.chat.emojis);
			}
			else
				{ $.get('https://cdn.rawgit.com/frappe/emoji/master/emoji', function (data) {
					frappe.chat.emojis = JSON.parse(data);

					if ( fn )
						{ fn(frappe.chat.emojis); }

					resolve(frappe.chat.emojis);
				}); }
		})
	};

	// Website Settings
	frappe.provide('frappe.chat.website.settings');
	frappe.chat.website.settings = function (fields, fn) {
		if ( typeof fields === "function" ) {
			fn     = fields;
			fields = null;
		} else
		if ( typeof fields === "string" )
			{ fields = frappe._.as_array(fields); }

		return new Promise(function (resolve) {
			frappe.call("frappe.chat.website.settings",
				{ fields: fields })
				.then(function (response) {
					var message = response.message;

					if ( message.enable_from )
						{ message   = Object.assign({}, message, {enable_from: new frappe.datetime.datetime(message.enable_from, 'HH:mm:ss')}); }
					if ( message.enable_to )
						{ message   = Object.assign({}, message, {enable_to:   new frappe.datetime.datetime(message.enable_to,   'HH:mm:ss')}); }

					if ( fn )
						{ fn(message); }

					resolve(message);
				});
		})
	};

	frappe.chat.website.token    = function (fn) {
		return new Promise(function (resolve) {
			frappe.call("frappe.chat.website.token")
				.then(function (response) {
					if ( fn )
						{ fn(response.message); }

					resolve(response.message);
				});
		})
	};

	var h = hyper_min.h;
	var Component = hyper_min.Component;

	// frappe.components
	// frappe's component namespace.
	frappe.provide('frappe.components');

	frappe.provide('frappe.chat.component');

	/**
	 * @description Button Component
	 *
	 * @prop {string}  type  - (Optional) "default", "primary", "info", "success", "warning", "danger" (defaults to "default")
	 * @prop {boolean} block - (Optional) Render a button block (defaults to false).
	 */
	frappe.components.Button
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var size      = frappe.components.Button.SIZE[props.size];

			return (
				h("button", Object.assign({}, props, {class: ("btn " + (size && size.class) + " btn-" + (props.type) + " " + (props.block ? "btn-block" : "") + " " + (props.class ? props.class : ""))}),
					props.children
				)
			)
		}
	};
	frappe.components.Button.SIZE
	=
	{
		small: {
			class: "btn-sm"
		},
		large: {
			class: "btn-lg"
		}
	};
	frappe.components.Button.defaultProps
	=
	{
		 type: "default",
		block: false
	};

	/**
	 * @description FAB Component
	 *
	 * @extends frappe.components.Button
	 */
	frappe.components.FAB
	=
	class extends frappe.components.Button {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var size      = frappe.components.FAB.SIZE[props.size];

			return (
				h(frappe.components.Button, Object.assign({}, props, {class: ((props.class) + " " + (size && size.class))}),
					h("i", { class: props.icon })
				)
			)
		}
	};
	frappe.components.FAB.defaultProps
	=
	{
		icon: "octicon octicon-plus"
	};
	frappe.components.FAB.SIZE
	=
	{
		small:
		{
			class: "frappe-fab-sm"
		},
		large:
		{
			class: "frappe-fab-lg"
		}
	};

	/**
	 * @description Octicon Component
	 *
	 * @prop color - (Required) color for the indicator
	 */
	frappe.components.Indicator
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return props.color ? h("span", Object.assign({}, props, {class: ("indicator " + (props.color))})) : null
		}
	};

	/**
	 * @description FontAwesome Component
	 */
	frappe.components.FontAwesome
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return props.type ? h("i", Object.assign({}, props, {class: ("fa " + (props.fixed ? "fa-fw" : "") + " fa-" + (props.type) + " " + (props.class))})) : null
		}
	};
	frappe.components.FontAwesome.defaultProps
	=
	{
		fixed: false
	};

	/**
	 * @description Octicon Component
	 *
	 * @extends frappe.Component
	 */
	frappe.components.Octicon
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return props.type ? h("i", Object.assign({}, props, {class: ("octicon octicon-" + (props.type))})) : null
		}
	};

	/**
	 * @description Avatar Component
	 *
	 * @prop {string} title - (Optional) title for the avatar.
	 * @prop {string} abbr  - (Optional) abbreviation for the avatar, defaults to the first letter of the title.
	 * @prop {string} size  - (Optional) size of the avatar to be displayed.
	 * @prop {image}  image - (Optional) image for the avatar, defaults to the first letter of the title.
	 */
	frappe.components.Avatar
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var abbr      = props.abbr || props.title.substr(0, 1);
			var size      = frappe.components.Avatar.SIZE[props.size] || frappe.components.Avatar.SIZE.medium;

			return (
				h("span", { class: ("avatar " + (size.class) + " " + (props.class ? props.class : "")) },
					props.image ?
						h("img", { class: "media-object", src: props.image })
						:
						h("div", { class: "standard-image" }, abbr)
				)
			)
		}
	};
	frappe.components.Avatar.SIZE
	=
	{
		small:
		{
			class: "avatar-small"
		},
		large:
		{
			class: "avatar-large"
		},
		medium:
		{
			class: "avatar-medium"
		}
	};

	/**
	 * @description Frappe Chat Object.
	 *
	 * @example
	 * const chat = new frappe.Chat(options) // appends to "body"
	 * chat.render()
	 * const chat = new frappe.Chat(".selector", options)
	 * chat.render()
	 *
	 * const chat = new frappe.Chat()
	 * chat.set_wrapper('.selector')
	 *     .set_options(options)
	 *     .render()
	 */
	frappe.Chat
	=
	class {
		/**
		 * @description Frappe Chat Object.
		 *
		 * @param {string} selector - A query selector, HTML Element or jQuery object.
		 * @param {object} options  - Optional configurations.
		 */
		constructor (selector, options) {
			if ( !(typeof selector === "string" || selector instanceof $ || selector instanceof HTMLElement) ) {
				options  = selector;
				selector = null;
			}

			this.options = frappe.Chat.OPTIONS;

			this.set_wrapper(selector ? selector : "body");
			this.set_options(options);

			// Load Emojis.
			frappe.chat.emoji();
		}

		/**
		 * Set the container on which the chat widget is mounted on.
		 * @param   {string|HTMLElement} selector - A query selector, HTML Element or jQuery object.
		 *
		 * @returns {frappe.Chat}                 - The instance.
		 *
		 * @example
		 * const chat = new frappe.Chat()
		 * chat.set_wrapper(".selector")
		 */
		set_wrapper (selector) {
			this.$wrapper = $(selector);

			return this
		}

		/**
		 * Set the configurations for the chat interface.
		 * @param   {object}      options - Optional Configurations.
		 *
		 * @returns {frappe.Chat}         - The instance.
		 *
		 * @example
		 * const chat = new frappe.Chat()
		 * chat.set_options({ layout: frappe.Chat.Layout.PAGE })
		 */
		set_options (options) {
			this.options = Object.assign({}, this.options, options);

			return this
		}

		/**
		 * @description Destory the chat widget.
		 *
		 * @returns {frappe.Chat} - The instance.
		 *
		 * @example
		 * const chat = new frappe.Chat()
		 * chat.render()
		 *     .destroy()
		 */
		destroy ( ) {
			var $wrapper = this.$wrapper;
			$wrapper.remove(".frappe-chat");

			return this
		}

		/**
		 * @description Render the chat widget component onto destined wrapper.
		 *
		 * @returns {frappe.Chat} - The instance.
		 *
		 * @example
		 * const chat = new frappe.Chat()
		 * chat.render()
		 */
		render (props) {
			if ( props === void 0 ) props = { };

			this.destroy();

			var $wrapper   = this.$wrapper;
			var options    = this.options;

			var component  = h(frappe.Chat.Widget, Object.assign({}, {layout: options.layout,
				target: options.target},
				props));

			hyper_min.render(component, $wrapper[0]);

			return this
		}
	};
	frappe.Chat.Layout
	=
	{
		PAGE: "page", POPPER: "popper"
	};
	frappe.Chat.OPTIONS
	=
	{
		layout: frappe.Chat.Layout.POPPER
	};

	/**
	 * @description The base Component for Frappe Chat
	 */
	frappe.Chat.Widget
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.setup(props);
			this.make();
		}

		setup (props) {
			var this$1 = this;

			// room actions
			this.room           = { };
			this.room.add       = function (rooms) {
				rooms           = frappe._.as_array(rooms);
				var names     = rooms.map(function (r) { return r.name; });

				frappe.log.info(("Subscribing " + (frappe.session.user) + " to Chat Rooms " + (names.join(", ")) + "."));
				frappe.chat.room.subscribe(names);

				var state     = [ ];

				for (var i = 0, list = rooms; i < list.length; i += 1)
					  {
					var room = list[i];

					if ( ["Group", "Visitor"].includes(room.type) || room.owner === frappe.session.user || room.last_message || room.users.includes(frappe.session.user)) {
						frappe.log.info(("Adding " + (room.name) + " to component."));
						state.push(room);
					}
				}

				this$1.set_state({ rooms: this$1.state.rooms.concat( state ) });
			};
			this.room.update    = function (room, update) {
				var ref = this$1;
				var state = ref.state;
				var   exists    = false;
				var rooms     = state.rooms.map(function (r) {
					if ( r.name === room ) {
						exists  = true;
						if ( update.typing ) {
							if ( !frappe._.is_empty(r.typing) ) {
								var usr = update.typing;
								if ( !r.typing.includes(usr) ) {
									update.typing = frappe._.copy_array(r.typing);
									update.typing.push(usr);
								}
							}
							else
								{ update.typing = frappe._.as_array(update.typing); }
						}

						return Object.assign({}, r, update)
					}

					return r
				});

				if ( frappe.session.user !== 'Guest' ) {
					if ( !exists )
						{ frappe.chat.room.get(room, function (room) { return this$1.room.add(room); }); }
					else
						{ this$1.set_state({ rooms: rooms }); }
				}

				if ( state.room.name === room ) {
					if ( update.typing ) {
						if ( !frappe._.is_empty(state.room.typing) ) {
							var usr = update.typing;
							if ( !state.room.typing.includes(usr) ) {
								update.typing = frappe._.copy_array(state.room.typing);
								update.typing.push(usr);
							}
						} else
							{ update.typing = frappe._.as_array(update.typing); }
					}

					var room$1  = Object.assign({}, state.room, update);

					this$1.set_state({ room: room$1 });
				}
			};
			this.room.select    = function (name) {
				frappe.chat.room.history(name, function (messages) {
					var ref = this$1;
					var state = ref.state;
					var room       = state.rooms.find(function (r) { return r.name === name; });

					this$1.set_state({
						room: Object.assign({}, state.room, room, {messages: messages})
					});
				});
			};

			this.state = Object.assign({}, frappe.Chat.Widget.defaultState, props);
		}

		make ( ) {
			var this$1 = this;

			if ( frappe.session.user !== 'Guest' ) {
				frappe.chat.profile.create([
					"status", "message_preview", "notification_tones", "conversation_tones"
				]).then(function (profile) {
					this$1.set_state({ profile: profile });

					frappe.chat.room.get(function (rooms) {
						rooms = frappe._.as_array(rooms);
						frappe.log.info(("User " + (frappe.session.user) + " is subscribed to " + (rooms.length) + " " + (frappe._.pluralize('room', rooms.length)) + "."));

						if ( !frappe._.is_empty(rooms) )
							{ this$1.room.add(rooms); }
					});

					this$1.bind();
				});
			} else {
				this.bind();
			}
		}

		bind ( ) {
			var this$1 = this;

			frappe.chat.profile.on.update(function (user, update) {
				frappe.log.warn(("TRIGGER: Chat Profile update " + (JSON.stringify(update)) + " of User " + user + "."));

				if ( 'status' in update ) {
					if ( user === frappe.session.user ) {
						this$1.set_state({
							profile: Object.assign({}, this$1.state.profile, {status: update.status})
						});
					} else {
						var status = frappe.chat.profile.STATUSES.find(function (s) { return s.name === update.status; });
						var color  = status.color;

						var alert  = "<span class=\"indicator " + color + "\"/> " + (frappe.user.full_name(user)) + " is currently <b>" + (update.status) + "</b>";
						frappe.show_alert(alert, 3);
					}
				}
			});

			frappe.chat.room.on.create(function (room) {
				frappe.log.warn(("TRIGGER: Chat Room " + (room.name) + " created."));
				this$1.room.add(room);
			});

			frappe.chat.room.on.update(function (room, update) {
				frappe.log.warn(("TRIGGER: Chat Room " + room + " update " + (JSON.stringify(update)) + " recieved."));
				this$1.room.update(room, update);
			});

			frappe.chat.room.on.typing(function (room, user) {
				if ( user !== frappe.session.user ) {
					frappe.log.warn(("User " + user + " typing in Chat Room " + room + "."));
					this$1.room.update(room, { typing: user });

					setTimeout(function () { return this$1.room.update(room, { typing: null }); }, 5000);
				}
			});

			frappe.chat.message.on.create(function (r) {
				var ref = this$1;
				var state = ref.state;

				// play sound.
				if ( state.room.name )
					{ state.profile.conversation_tones && frappe.chat.sound.play('message'); }
				else
					{ state.profile.notification_tones && frappe.chat.sound.play('notification'); }

				if ( r.user !== frappe.session.user && state.profile.message_preview && !state.toggle ) {
					var $element = $('body').find('.frappe-chat-alert');
					$element.remove();

					var  alert   = // TODO: ellipses content
					"\n\t\t\t\t<span data-action=\"show-message\" class=\"cursor-pointer\">\n\t\t\t\t\t<span class=\"indicator yellow\"/>\n\t\t\t\t\t\t<span class=\"avatar avatar-small\">\n\t\t\t\t\t\t\t<span class=\"avatar-frame\" style=\"background-image: url(" + (frappe.user.image(r.user)) + ")\"></span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<b>" + (frappe.user.first_name(r.user)) + "</b>: " + (r.content) + "\n\t\t\t\t</span>\n\t\t\t\t";
					frappe.show_alert(alert, 15, {
						"show-message": function (r) {
							this.room.select(r.room);
							this.base.firstChild._component.toggle();
						}.bind(this$1, r)
					});
					frappe.notify(("" + (frappe.user.first_name(r.user))), {
						body: r.content,
						icon: frappe.user.image(r.user),
						tag: r.user
					});
				}

				if ( r.room === state.room.name ) {
					var mess  = frappe._.copy_array(state.room.messages);
					mess.push(r);

					this$1.set_state({ room: Object.assign({}, state.room, {messages: mess}) });
				}
			});

			frappe.chat.message.on.update(function (message, update) {
				frappe.log.warn(("TRIGGER: Chat Message " + message + " update " + (JSON.stringify(update)) + " recieved."));
			});
		}

		render ( ) {
			var this$1 = this;

			var ref = this;
			var props = ref.props;
			var state = ref.state;
			var me               = this;

			var ActionBar        = h(frappe.Chat.Widget.ActionBar, {
				placeholder: __("Search or Create a New Chat"),
					  class: "level",
					 layout: props.layout,
					actions:
				frappe._.compact([
					{
						  label: __("New"),
						onclick: function ( ) {
							var dialog = new frappe.ui.Dialog({
								  title: __("New Chat"),
								 fields: [
									 {
											 label: __("Chat Type"),
										 fieldname: "type",
										 fieldtype: "Select",
										   options: ["Group", "Direct Chat"],
										   default: "Group",
										  onchange: function () {
												var type     = dialog.get_value("type");
												var is_group = type === "Group";

												dialog.set_df_property("group_name", "reqd",  is_group);
												dialog.set_df_property("user",       "reqd", !is_group);
										  }
									 },
									 {
											 label: __("Group Name"),
										 fieldname: "group_name",
										 fieldtype: "Data",
											  reqd: true,
										depends_on: "eval:doc.type == 'Group'"
									 },
									 {
											 label: __("Users"),
										 fieldname: "users",
										 fieldtype: "MultiSelect",
										   options: frappe.user.get_emails(),
										depends_on: "eval:doc.type == 'Group'"
									 },
									 {
											 label: __("User"),
										 fieldname: "user",
										 fieldtype: "Link",
										   options: "User",
										depends_on: "eval:doc.type == 'Direct Chat'"
									 }
								 ],
								action: {
									primary: {
										   label: __('Create'),
										onsubmit: function (values) {
											if ( values.type === "Group" ) {
												if ( !frappe._.is_empty(values.users) ) {
													var name  = values.group_name;
													var users = dialog.fields_dict.users.get_values();

													frappe.chat.room.create("Group",  null, users, name);
												}
											} else {
												var user      = values.user;

												frappe.chat.room.create("Direct", null, user);
											}
											dialog.hide();
										}
									}
								}
							});
							dialog.show();
						}
					},
					frappe._.is_mobile() && {
						   icon: "octicon octicon-x",
						   class: "frappe-chat-close",
						onclick: function () { return this$1.set_state({ toggle: false }); }
					}
				], Boolean),
				change: function (query) { me.set_state({ query: query }); },
				  span: function (span)  { me.set_state({ span: span  }); },
			});

			var   contacts   = [ ];
			if ( 'user_info' in frappe.boot ) {
				var emails = frappe.user.get_emails();
				for (var i$1 = 0, list$1 = emails; i$1 < list$1.length; i$1 += 1) {
					var email = list$1[i$1];

					var exists = false;

					for (var i = 0, list = state.rooms; i < list.length; i += 1) {
						var room = list[i];

						if ( room.type === 'Direct' ) {
							if ( room.owner === email || frappe._.squash(room.users) === email )
								{ exists = true; }
						}
					}

					if ( !exists )
						{ contacts.push({ owner: frappe.session.user, users: [email] }); }
				}
			}
			var rooms      = state.query ? frappe.chat.room.search(state.query, state.rooms.concat(contacts)) : frappe.chat.room.sort(state.rooms);

			var layout     = state.span  ? frappe.Chat.Layout.PAGE : frappe.Chat.Layout.POPPER;

			var RoomList   = frappe._.is_empty(rooms) && !state.query ?
				h("div", { class: "vcenter" },
					h("div", { class: "text-center text-extra-muted" },
						h("p","",__("You don't have any messages yet."))
					)
				)
				:
				h(frappe.Chat.Widget.RoomList, { rooms: rooms, click: function (room) {
					if ( room.name )
						{ this$1.room.select(room.name); }
					else
						{ frappe.chat.room.create("Direct", room.owner, frappe._.squash(room.users), function (ref) {
							var name = ref.name;

							return this$1.room.select(name);
					}); }
				}});
			var Room       = h(frappe.Chat.Widget.Room, Object.assign({}, state.room, {layout: layout, destroy: function () {
				this$1.set_state({
					room: { name: null, messages: [ ] }
				});
			}}));

			var component  = layout === frappe.Chat.Layout.POPPER ?
				h(frappe.Chat.Widget.Popper, { heading: ActionBar, page: state.room.name && Room, target: props.target,
					toggle: function (t) { return this$1.set_state({ toggle: t }); } },
					RoomList
				)
				:
				h("div", { class: "frappe-chat-popper" },
					h("div", { class: "frappe-chat-popper-collapse" },
						h("div", { class: "panel panel-default panel-span", style: { width: "25%" } },
							h("div", { class: "panel-heading" },
								ActionBar
							),
							RoomList
						),
						Room
					)
				);

			return (
				h("div", { class: "frappe-chat" },
					component
				)
			)
		}
	};
	frappe.Chat.Widget.defaultState =  {
		  query: "",
		profile: { },
		  rooms: [ ],
		   room: { name: null, messages: [ ], typing: [ ] },
		 toggle: false,
		   span: false
	};
	frappe.Chat.Widget.defaultProps = {
		layout: frappe.Chat.Layout.POPPER
	};

	/**
	 * @description Chat Widget Popper HOC.
	 */
	frappe.Chat.Widget.Popper
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.setup(props);
		}

		setup (props) {
			var this$1 = this;

			this.toggle = this.toggle.bind(this);

			this.state  = frappe.Chat.Widget.Popper.defaultState;

			if ( props.target )
				{ $(props.target).click(function () { return this$1.toggle(); }); }

			frappe.chat.widget = this;
		}

		toggle  (active) {
			var toggle;
			if ( arguments.length === 1 )
				{ toggle = active; }
			else
				{ toggle = this.state.active ? false : true; }

			this.set_state({ active: toggle });

			this.props.toggle(toggle);
		}

		on_mounted ( ) {
			var this$1 = this;

			$(document.body).on('click', '.page-container, .frappe-chat-close', function (ref) {
				var currentTarget = ref.currentTarget;

				this$1.toggle(false);
			});
		}

		render  ( )  {
			var this$1 = this;

			var ref = this;
			var props = ref.props;
			var state = ref.state;

			return !state.destroy ?
			(
				h("div", { class: "frappe-chat-popper", style: !props.target ? { "margin-bottom": "80px" } : null },
					!props.target ?
						h(frappe.components.FAB, {
							  class: "frappe-fab",
							   icon: state.active ? "fa fa-fw fa-times" : "font-heavy octicon octicon-comment",
							   size: frappe._.is_mobile() ? null : "large",
							   type: "primary",
							onclick: function () { return this$1.toggle(); },
						}) : null,
					state.active ?
						h("div", { class: "frappe-chat-popper-collapse" },
							props.page ? props.page : (
								h("div", { class: ("panel panel-default " + (frappe._.is_mobile() ? "panel-span" : "")) },
									h("div", { class: "panel-heading" },
										props.heading
									),
									props.children
								)
							)
					) : null
				)
			) : null
		}
	};
	frappe.Chat.Widget.Popper.defaultState
	=
	{
		 active: false,
		destroy: false
	};

	/**
	 * @description frappe.Chat.Widget ActionBar Component
	 */
	frappe.Chat.Widget.ActionBar
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.change = this.change.bind(this);
			this.submit = this.submit.bind(this);

			this.state  = frappe.Chat.Widget.ActionBar.defaultState;
		}

		change (e) {
			var obj;

			var ref = this;
			var props = ref.props;
			var state = ref.state;

			this.set_state(( obj = {}, obj[e.target.name] = e.target.value, obj ));

			props.change(state.query);
		}

		submit (e) {
			var ref = this;
			var props = ref.props;
			var state = ref.state;

			e.preventDefault();

			props.submit(state.query);
		}

		render ( ) {
			var me               = this;
			var ref = this;
			var props = ref.props;
			var state = ref.state;
			var actions = props.actions;

			return (
				h("div", { class: ("frappe-chat-action-bar " + (props.class ? props.class : "")) },
					h("form", { oninput: this.change, onsubmit: this.submit },
						h("input", { autocomplete: "off", class: "form-control input-sm", name: "query", value: state.query, placeholder: props.placeholder || "Search" })
					),
					!frappe._.is_empty(actions) ?
						actions.map(function (action) { return h(frappe.Chat.Widget.ActionBar.Action, Object.assign({}, action)); }) : null,
					!frappe._.is_mobile() ?
						h(frappe.Chat.Widget.ActionBar.Action, {
							icon: ("octicon octicon-screen-" + (state.span ? "normal" : "full")),
							onclick: function () {
								var span = !state.span;
								me.set_state({ span: span });
								props.span(span);
							}
						})
						:
						null
				)
			)
		}
	};
	frappe.Chat.Widget.ActionBar.defaultState
	=
	{
		query: null,
		 span: false
	};

	/**
	 * @description frappe.Chat.Widget ActionBar's Action Component.
	 */
	frappe.Chat.Widget.ActionBar.Action
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return (
				h(frappe.components.Button, Object.assign({}, {size: "small", class: "btn-action"}, props),
					props.icon ? h("i", { class: props.icon }) : null,
					("" + (props.icon ? " " : "") + (props.label ? props.label : ""))
				)
			)
		}
	};

	/**
	 * @description frappe.Chat.Widget RoomList Component
	 */
	frappe.Chat.Widget.RoomList
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var rooms     = props.rooms;

			return !frappe._.is_empty(rooms) ? (
				h("ul", { class: "frappe-chat-room-list nav nav-pills nav-stacked" },
					rooms.map(function (room) { return h(frappe.Chat.Widget.RoomList.Item, Object.assign({}, room, {click: props.click})); })
				)
			) : null
		}
	};

	/**
	 * @description frappe.Chat.Widget RoomList's Item Component
	 */
	frappe.Chat.Widget.RoomList.Item
	=
	class extends Component {
		render ( ) {
			var ref    = this;
			var props = ref.props;
			var item         = { };

			if ( props.type === "Group" ) {
				item.title     = props.room_name;
				item.image     = props.avatar;

				if ( !frappe._.is_empty(props.typing) ) {
					props.typing  = frappe._.as_array(props.typing); // HACK: (BUG) why does typing return a string?
					var names   = props.typing.map(function (user) { return frappe.user.first_name(user); });
					item.subtitle = (names.join(", ")) + " typing...";
				} else
				if ( props.last_message ) {
					var message = props.last_message;
					var content = message.content;

					if ( message.type === "File" ) {
						item.subtitle = "📁 " + (content.name);
					} else {
						item.subtitle = props.last_message.content;
					}
				}
			} else {
				var user     = props.owner === frappe.session.user ? frappe._.squash(props.users) : props.owner;

				item.title     = frappe.user.full_name(user);
				item.image     = frappe.user.image(user);
				item.abbr      = frappe.user.abbr(user);

				if ( !frappe._.is_empty(props.typing) )
					{ item.subtitle = 'typing...'; }
				else
				if ( props.last_message ) {
					var message$1 = props.last_message;
					var content$1 = message$1.content;

					if ( message$1.type === "File" ) {
						item.subtitle = "📁 " + (content$1.name);
					} else {
						item.subtitle = props.last_message.content;
					}
				}
			}

			var is_unread = false;
			if ( props.last_message ) {
				item.timestamp = frappe.chat.pretty_datetime(props.last_message.creation);
				is_unread = !props.last_message.seen.includes(frappe.session.user);
			}

			return (
				h("li", null,
					h("a", { class: props.active ? "active": "", onclick: function () {
						if (props.last_message) {
							frappe.chat.message.seen(props.last_message.name);
						}
						props.click(props);
					} },
						h("div", { class: "row" },
							h("div", { class: "col-xs-9" },
								h(frappe.Chat.Widget.MediaProfile, Object.assign({}, item))
							),
							h("div", { class: "col-xs-3 text-right" },
								[
									h("div", { class: "text-muted", style: { "font-size": "9px" } }, item.timestamp),
									is_unread ? h("span", { class: "indicator red" }) : null
								]
							)
						)
					)
				)
			)
		}
	};

	/**
	 * @description frappe.Chat.Widget's MediProfile Component.
	 */
	frappe.Chat.Widget.MediaProfile
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var position  = frappe.Chat.Widget.MediaProfile.POSITION[props.position || "left"];
			var avatar    = (
				h("div", { class: ((position.class) + " media-middle") },
					h(frappe.components.Avatar, Object.assign({}, props,
						{title: props.title,
						image: props.image,
						 size: props.size,
						 abbr: props.abbr}))
				)
			);

			return (
				h("div", { class: "media", style: position.class === "media-right" ? { "text-align": "right" } : null },
					position.class === "media-left"  ? avatar : null,
					h("div", { class: "media-body" },
						h("div", { class: "media-heading ellipsis small", style: ("max-width: " + (props.width_title || "100%") + " display: inline-block") }, props.title),
						props.content  ? h("div","",h("small","",props.content))  : null,
						props.subtitle ? h("div",{ class: "media-subtitle small" },h("small", { class: "text-muted" }, props.subtitle)) : null
					),
					position.class === "media-right" ? avatar : null
				)
			)
		}
	};
	frappe.Chat.Widget.MediaProfile.POSITION
	=
	{
		left: { class: "media-left" }, right: { class: "media-right" }
	};

	/**
	 * @description frappe.Chat.Widget Room Component
	 */
	frappe.Chat.Widget.Room
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var state = ref.state;
			var hints            =
			[
				{
					 match: /@(\w*)$/,
					search: function (keyword, callback) {
						if ( props.type === 'Group' ) {
							var query = keyword.slice(1);
							var users = [].concat(frappe._.as_array(props.owner), props.users);
							var grep  = users.filter(function (user) { return user !== frappe.session.user && user.indexOf(query) === 0; });

							callback(grep);
						}
					},
					component: function (item) {
						return (
							h(frappe.Chat.Widget.MediaProfile, {
								title: frappe.user.full_name(item),
								image: frappe.user.image(item),
								 size: "small"
							})
						)
					}
				},
				{
					match: /:([a-z]*)$/,
				   search: function (keyword, callback) {
						frappe.chat.emoji(function (emojis) {
							var query = keyword.slice(1);
							var items = [ ];
							for (var i$1 = 0, list$1 = emojis; i$1 < list$1.length; i$1 += 1)
								{
								var emoji = list$1[i$1];

								for (var i = 0, list = emoji.aliases; i < list.length; i += 1)
									{
										var alias = list[i];

										if ( alias.indexOf(query) === 0 )
										{ items.push({ name: alias, value: emoji.emoji });
									}
							} }

							callback(items);
						});
				   },
					 content: function (item) { return item.value; },
				   component: function (item) {
						return (
							h(frappe.Chat.Widget.MediaProfile, {
								title: item.name,
								 abbr: item.value,
								 size: "small"
							})
						)
				   }
			   }
			];

			var actions = frappe._.compact([
				!frappe._.is_mobile() && {
					 icon: "camera",
					label: "Camera",
					onclick: function ( ) {
						var capture = new frappe.ui.Capture({
							animate: false,
							  error: true
						});
						capture.show();

						capture.submit(function (data_url) {
							// data_url
						});
					}
				},
				{
					 icon: "file",
					label: "File",
					onclick: function ( ) {
						new frappe.ui.FileUploader({
							doctype: "Chat Room",
							docname: props.name,
							on_success: function on_success(file_doc) {
								var file_url = file_doc.file_url;
								var filename = file_doc.filename;
								frappe.chat.message.send(props.name, { path: file_url, name: filename }, "File");
							}
						});
					}
				}
			]);

			if ( frappe.session.user !== 'Guest' ) {
				if (props.messages) {
					props.messages = frappe._.as_array(props.messages);
					for (var i = 0, list = props.messages; i < list.length; i += 1)
						{
						var message = list[i];

						if ( !message.seen.includes(frappe.session.user) )
							{ frappe.chat.message.seen(message.name); }
						else
							{ break
					} }
				}
			}

			return (
				h("div", { class: ("panel panel-default\n\t\t\t\t" + (props.name ? "panel-bg" : "") + "\n\t\t\t\t" + (props.layout === frappe.Chat.Layout.PAGE || frappe._.is_mobile() ? "panel-span" : "")),
					style: props.layout === frappe.Chat.Layout.PAGE && { width: "75%", left: "25%", "box-shadow": "none" } },
					props.name && h(frappe.Chat.Widget.Room.Header, Object.assign({}, props, {on_back: props.destroy})),
					props.name ?
						!frappe._.is_empty(props.messages) ?
							h(frappe.chat.component.ChatList, {
								messages: props.messages
							})
							:
							h("div", { class: "panel-body", style: { "height": "100%" } },
								h("div", { class: "vcenter" },
									h("div", { class: "text-center text-extra-muted" },
										h(frappe.components.Octicon, { type: "comment-discussion", style: "font-size: 48px" }),
										h("p","",__("Start a conversation."))
									)
								)
							)
						:
						h("div", { class: "panel-body", style: { "height": "100%" } },
							h("div", { class: "vcenter" },
								h("div", { class: "text-center text-extra-muted" },
									h(frappe.components.Octicon, { type: "comment-discussion", style: "font-size: 125px" }),
									h("p","",__("Select a chat to start messaging."))
								)
							)
						),
					props.name ?
						h("div", { class: "chat-room-footer" },
							h(frappe.chat.component.ChatForm, { actions: actions,
								onchange: function () {
									frappe.chat.message.typing(props.name);
								},
								onsubmit: function (message) {
									frappe.chat.message.send(props.name, message);
								},
								hint: hints
							})
						)
						:
						null
				)
			)
		}
	};

	frappe.Chat.Widget.Room.Header
	=
	class extends Component {
		render ( ) {
			var ref     = this;
			var props = ref.props;

			var item          = { };

			if ( ["Group", "Visitor"].includes(props.type) ) {
				item.route      = "Form/Chat Room/" + (props.name);

				item.title      = props.room_name;
				item.image      = props.avatar;

				if ( !frappe._.is_empty(props.typing) ) {
					props.typing  = frappe._.as_array(props.typing); // HACK: (BUG) why does typing return as a string?
					var users   = props.typing.map(function (user) { return frappe.user.first_name(user); });
					item.subtitle = (users.join(", ")) + " typing...";
				} else
					{ item.subtitle = props.type === "Group" ?
						__(((props.users.length) + " " + (frappe._.pluralize('member', props.users.length))))
						:
						""; }
			}
			else {
				var user      = props.owner === frappe.session.user ? frappe._.squash(props.users) : props.owner;

				item.route      = "Form/User/" + user;

				item.title      = frappe.user.full_name(user);
				item.image      = frappe.user.image(user);

				if ( !frappe._.is_empty(props.typing) )
					{ item.subtitle = 'typing...'; }
			}

			var popper        = props.layout === frappe.Chat.Layout.POPPER || frappe._.is_mobile();

			return (
				h("div", { class: "panel-heading", style: { "height": "50px" } }, // sorry. :(
					h("div", { class: "level" },
						popper && frappe.session.user !== "Guest" ?
							h(frappe.components.Button,{class:"btn-back",onclick:props.on_back},
								h(frappe.components.Octicon, { type: "chevron-left" })
							) : null,
						h("div","",
							h("div", { class: "panel-title" },
								h("div", { class: "cursor-pointer", onclick: function () {
									frappe.session.user !== "Guest" ?
										frappe.set_route(item.route) : null;
								}},
									h(frappe.Chat.Widget.MediaProfile, Object.assign({}, item))
								)
							)
						),
						h("div", { class: popper ? "col-xs-2"  : "col-xs-3" },
							h("div", { class: "text-right" },
								frappe._.is_mobile() && h(frappe.components.Button, { class: "frappe-chat-close", onclick: props.toggle },
									h(frappe.components.Octicon, { type: "x" })
								)
							)
						)
					)
				)
			)
		}
	};

	/**
	 * @description ChatList Component
	 *
	 * @prop {array} messages - ChatMessage(s)
	 */
	frappe.chat.component.ChatList
	=
	class extends Component {
		on_mounted ( ) {
			this.$element  = $('.frappe-chat').find('.chat-list');
			this.$element.scrollTop(this.$element[0].scrollHeight);
		}

		on_updated ( ) {
			this.$element.scrollTop(this.$element[0].scrollHeight);
		}

		render ( ) {
			var messages = [ ];
			for (var i   = 0 ; i < this.props.messages.length ; ++i) {
				var   message   = this.props.messages[i];
				var me        = message.user === frappe.session.user;

				if ( i === 0 || !frappe.datetime.equal(message.creation, this.props.messages[i - 1].creation, 'day') )
					{ messages.push({ type: "Notification", content: message.creation.format('MMMM DD') }); }

				messages.push(message);
			}

			return (
				h("div",{class:"chat-list list-group"},
					!frappe._.is_empty(messages) ?
						messages.map(function (m) { return h(frappe.chat.component.ChatList.Item, Object.assign({}, m)); }) : null
				)
			)
		}
	};

	/**
	 * @description ChatList.Item Component
	 *
	 * @prop {string} name       - ChatMessage name
	 * @prop {string} user       - ChatMessage user
	 * @prop {string} room       - ChatMessage room
	 * @prop {string} room_type  - ChatMessage room_type ("Direct", "Group" or "Visitor")
	 * @prop {string} content    - ChatMessage content
	 * @prop {frappe.datetime.datetime} creation - ChatMessage creation
	 *
	 * @prop {boolean} groupable - Whether the ChatMessage is groupable.
	 */
	frappe.chat.component.ChatList.Item
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			var me        = props.user === frappe.session.user;
			var content   = props.content;

			return (
				h("div",{class: "chat-list-item list-group-item"},
					props.type === "Notification" ?
						h("div",{class:"chat-list-notification"},
							h("div",{class:"chat-list-notification-content"},
								content
							)
						)
						:
						h("div",{class:("" + (me ? "text-right" : ""))},
							props.room_type === "Group" && !me ?
								h(frappe.components.Avatar, {
									title: frappe.user.full_name(props.user),
									image: frappe.user.image(props.user)
								}) : null,
							h(frappe.chat.component.ChatBubble, props)
						)
				)
			)
		}
	};

	/**
	 * @description ChatBubble Component
	 *
	 * @prop {string} name       - ChatMessage name
	 * @prop {string} user       - ChatMessage user
	 * @prop {string} room       - ChatMessage room
	 * @prop {string} room_type  - ChatMessage room_type ("Direct", "Group" or "Visitor")
	 * @prop {string} content    - ChatMessage content
	 * @prop {frappe.datetime.datetime} creation - ChatMessage creation
	 *
	 * @prop {boolean} groupable - Whether the ChatMessage is groupable.
	 */
	frappe.chat.component.ChatBubble
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.onclick = this.onclick.bind(this);
		}

		onclick ( ) {
			var ref = this;
			var props = ref.props;
			if ( props.user === frappe.session.user ) {
				frappe.quick_edit("Chat Message", props.name, function (values) {

				});
			}
		}

		render  ( ) {
			var ref = this;
			var props = ref.props;
			var creation 	= props.creation.format('hh:mm A');

			var me        = props.user === frappe.session.user;
			var read      = !frappe._.is_empty(props.seen) && !props.seen.includes(frappe.session.user);

			var content   = props.content;

			return (
				h("div",{class:("chat-bubble " + (props.groupable ? "chat-groupable" : "") + " chat-bubble-" + (me ? "r" : "l")),
					onclick: this.onclick},
					props.room_type === "Group" && !me?
						h("div",{class:"chat-bubble-author"},
							h("a", { onclick: function () { frappe.set_route(("Form/User/" + (props.user))); } },
								frappe.user.full_name(props.user)
							)
						) : null,
					h("div",{class:"chat-bubble-content"},
							h("small","",
								props.type === "File" ?
									h("a", { class: "no-decoration", href: content.path, target: "_blank" },
										h(frappe.components.FontAwesome, { type: "file", fixed: true }), (" " + (content.name))
									)
									:
									content
							)
					),
					h("div",{class:"chat-bubble-meta"},
						h("span",{class:"chat-bubble-creation"},creation),
						me && read ?
							h("span",{class:"chat-bubble-check"},
								h(frappe.components.Octicon,{type:"check"})
							) : null
					)
				)
			)
		}
	};

	/**
	 * @description ChatForm Component
	 */
	frappe.chat.component.ChatForm
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.onchange   = this.onchange.bind(this);
			this.onsubmit   = this.onsubmit.bind(this);

			this.hint        = this.hint.bind(this);

			this.state       = frappe.chat.component.ChatForm.defaultState;
		}

		onchange (e) {
			var obj;

			var ref = this;
			var props = ref.props;
			var state = ref.state;
			var value            = e.target.value;

			this.set_state(( obj = {}, obj[e.target.name] = value, obj ));

			props.onchange(state);

			this.hint(value);
		}

		hint (value) {
			var this$1 = this;

			var ref = this;
			var props = ref.props;
			var state = ref.state;

			if ( props.hint ) {
				var tokens =  value.split(" ");
				var sliced = tokens.slice(0, tokens.length - 1);

				var token  = tokens[tokens.length - 1];

				if ( token ) {
					props.hint   = frappe._.as_array(props.hint);
					var hint   = props.hint.find(function (hint) { return hint.match.test(token); });

					if ( hint ) {
						hint.search(token, function (items) {
							var hints = items.map(function (item) {
								// You should stop writing one-liners! >_>
								var replace = token.replace(hint.match, hint.content ? hint.content(item) : item);
								var content = ((sliced.join(" ")) + " " + replace).trim();
								item          = { component: hint.component(item), content: content };

								return item
							}).slice(0, hint.max || 5);

							this$1.set_state({ hints: hints });
						});
					}
					else
						{ this.set_state({ hints: [ ] }); }
				} else
					{ this.set_state({ hints: [ ] }); }
			}
		}

		onsubmit (e) {
			e.preventDefault();

			if ( this.state.content ) {
				this.props.onsubmit(this.state.content);

				this.set_state({ content: null });
			}
		}

		render ( ) {
			var this$1 = this;

			var ref = this;
			var props = ref.props;
			var state = ref.state;

			return (
				h("div",{class:"chat-form"},
					state.hints.length ?
						h("ul", { class: "hint-list list-group" },
							state.hints.map(function (item) {
								return (
									h("li", { class: "hint-list-item list-group-item" },
										h("a", { href: "javascript:void(0)", onclick: function () {
											this$1.set_state({ content: item.content, hints: [ ] });
										}},
											item.component
										)
									)
								)
							})
						) : null,
					h("form", { oninput: this.onchange, onsubmit: this.onsubmit },
						h("div",{class:"input-group input-group-lg"},
							!frappe._.is_empty(props.actions) ?
								h("div",{class:"input-group-btn dropup"},
									h(frappe.components.Button,{ class: (frappe.session.user === "Guest" ? "disabled" : "dropdown-toggle"), "data-toggle": "dropdown"},
										h(frappe.components.FontAwesome, { class: "text-muted", type: "paperclip", fixed: true })
									),
									h("div",{ class:"dropdown-menu dropdown-menu-left", onclick: function (e) { return e.stopPropagation(); } },
										!frappe._.is_empty(props.actions) && props.actions.map(function (action) {
											return (
												h("li", null,
													h("a",{onclick:action.onclick},
														h(frappe.components.FontAwesome,{type:action.icon,fixed:true}), (" " + (action.label))
													)
												)
											)
										})
									)
								) : null,
							h("textarea", {
										class: "form-control",
										 name: "content",
										value: state.content,
								  placeholder: "Type a message",
									autofocus: true,
								   onkeypress: function (e) {
										if ( e.which === frappe.ui.keycode.RETURN && !e.shiftKey )
											{ this$1.onsubmit(e); }
								   }
							}),
							h("div",{class:"input-group-btn"},
								h(frappe.components.Button, { onclick: this.onsubmit },
									h(frappe.components.FontAwesome, { class: !frappe._.is_empty(state.content) ? "text-primary" : "text-muted", type: "send", fixed: true })
								)
							)
						)
					)
				)
			)
		}
	};
	frappe.chat.component.ChatForm.defaultState
	=
	{
		content: null,
		  hints: [ ],
	};

	/**
	 * @description EmojiPicker Component
	 *
	 * @todo Under Development
	 */
	frappe.chat.component.EmojiPicker
	=
	class extends Component  {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return (
				h("div", { class: ("frappe-chat-emoji dropup " + (props.class)) },
					h(frappe.components.Button, { type: "primary", class: "dropdown-toggle", "data-toggle": "dropdown" },
						h(frappe.components.FontAwesome, { type: "smile-o", fixed: true })
					),
					h("div", { class: "dropdown-menu dropdown-menu-right", onclick: function (e) { return e.stopPropagation(); } },
						h("div", { class: "panel panel-default" },
							h(frappe.chat.component.EmojiPicker.List)
						)
					)
				)
			)
		}
	};
	frappe.chat.component.EmojiPicker.List
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return (
				h("div", { class: "list-group" }

				)
			)
		}
	};

	/**
	 * @description Python equivalent to sys.platform
	 */
	frappe.provide('frappe._');
	frappe._.platform   = function () {
		var string    = navigator.appVersion;

		if ( string.includes("Win") ) 	{ return "Windows" }
		if ( string.includes("Mac") ) 	{ return "Darwin" }
		if ( string.includes("X11") ) 	{ return "UNIX" }
		if ( string.includes("Linux") ) { return "Linux" }

		return undefined
	};

	/**
	 * @description Frappe's Asset Helper
	 */
	frappe.provide('frappe.assets');
	frappe.assets.image = function (image, app) {
		if ( app === void 0 ) app = 'frappe';

		var  path     = "/assets/" + app + "/images/" + image;
		return path
	};

	/**
	 * @description Notify using Web Push Notifications
	 */
	frappe.provide('frappe.boot');
	frappe.provide('frappe.browser');
	frappe.browser.Notification = 'Notification' in window;

	frappe.notify     = function (string, options) {
		frappe.log    = frappe.Logger.get('frappe.notify');

		var OPTIONS = {
			icon: frappe.assets.image('favicon.png', 'frappe'),
			lang: frappe.boot.lang || "en"
		};
		options       = Object.assign({ }, OPTIONS, options);

		if ( !frappe.browser.Notification )
			{ frappe.log.error('ERROR: This browser does not support desktop notifications.'); }

		Notification.requestPermission(function (status) {
			if ( status === "granted" ) {
				var notification = new Notification(string, options);
			}
		});
	};

	frappe.chat.render = function (render, force) {
		if ( render === void 0 ) render = true;
		if ( force === void 0 ) force = false;

		frappe.log.info(((render ? "Enable" : "Disable") + " Chat for User."));

		var desk = 'desk' in frappe;
		if ( desk ) {
			// With the assumption, that there's only one navbar.
			var $placeholder = $('.navbar .frappe-chat-dropdown');

			// Render if frappe-chat-toggle doesn't exist.
			if ( frappe.utils.is_empty($placeholder.has('.frappe-chat-toggle')) ) {
				var $template = $("\n\t\t\t\t<a class=\"dropdown-toggle frappe-chat-toggle\" data-toggle=\"dropdown\">\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<i class=\"octicon octicon-comment-discussion\"/>\n\t\t\t\t\t</div>\n\t\t\t\t</a>\n\t\t\t");

				$placeholder.addClass('dropdown hidden');
				$placeholder.html($template);
			}

			if ( render ) {
				$placeholder.removeClass('hidden');
			} else {
				$placeholder.addClass('hidden');
			}
		}

		// Avoid re-renders. Once is enough.
		if ( !frappe.chatter || force ) {
			frappe.chatter = new frappe.Chat({
				target: desk ? '.frappe-chat-toggle' : null
			});

			if ( render ) {
				if ( frappe.session.user === 'Guest' && !desk ) {
					frappe.store = frappe.Store.get('frappe.chat');
					var token	 = frappe.store.get('guest_token');

					frappe.log.info(("Local Guest Token - " + token));

					var setup_room = function (token) {
						return new Promise(function (resolve) {
							frappe.chat.room.create("Visitor", token).then(function (room) {
								frappe.log.info(("Visitor Room Created: " + (room.name)));
								frappe.chat.room.subscribe(room.name);

								var reference = room;

								frappe.chat.room.history(room.name).then(function (messages) {
									var  room = Object.assign({}, reference, {messages: messages});
									return room
								}).then(function (room) {
									resolve(room);
								});
							});
						})
					};

					if ( !token ) {
						frappe.chat.website.token().then(function (token) {
							frappe.log.info(("Generated Guest Token - " + token));
							frappe.store.set('guest_token', token);

							setup_room(token).then(function (room) {
								frappe.chatter.render({ room: room });
							});
						});
					} else {
						setup_room(token).then(function (room) {
							frappe.chatter.render({ room: room });
						});
					}
				} else {
					frappe.chatter.render();
				}
			}
		}
	};

	frappe.chat.setup  = function () {
		frappe.log     = frappe.Logger.get('frappe.chat');

		frappe.log.info('Setting up frappe.chat');
		frappe.log.warn('TODO: frappe.chat.<object> requires a storage.');

		if ( frappe.session.user !== 'Guest' ) {
			// Create/Get Chat Profile for session User, retrieve enable_chat
			frappe.log.info('Creating a Chat Profile.');

			frappe.chat.profile.create('enable_chat').then(function (ref) {
				var enable_chat = ref.enable_chat;

				frappe.log.info(("Chat Profile created for User " + (frappe.session.user) + "."));

				if ( 'desk' in frappe && frappe.sys_defaults ) { // same as desk?
					var should_render = Boolean(parseInt(frappe.sys_defaults.enable_chat)) && enable_chat;
					frappe.chat.render(should_render);
				}
			});

			// Triggered when a User updates his/her Chat Profile.
			// Don't worry, enable_chat is broadcasted to this user only. No overhead. :)
			frappe.chat.profile.on.update(function (user, profile) {
				if ( user === frappe.session.user && 'enable_chat' in profile ) {
					frappe.log.warn(("Chat Profile update (Enable Chat - " + (Boolean(profile.enable_chat)) + ")"));
					var should_render = Boolean(parseInt(frappe.sys_defaults.enable_chat)) && profile.enable_chat;
					frappe.chat.render(should_render);
				}
			});
		} else {
			// Website Settings
			frappe.log.info('Retrieving Chat Website Settings.');
			frappe.chat.website.settings(["socketio", "enable", "enable_from", "enable_to"])
				.then(function (settings) {
					frappe.log.info(("Chat Website Setting - " + (JSON.stringify(settings))));
					frappe.log.info(("Chat Website Setting - " + (settings.enable ? "Enable" : "Disable")));

					var should_render = settings.enable;
					if ( settings.enable_from && settings.enable_to ) {
						frappe.log.info(("Enabling Chat Schedule - " + (settings.enable_from.format()) + " : " + (settings.enable_to.format())));

						var range   = new frappe.datetime.range(settings.enable_from, settings.enable_to);
						should_render = range.contains(frappe.datetime.now());
					}

					if ( should_render ) {
						frappe.log.info("Initializing Socket.IO");
						frappe.socketio.init(settings.socketio.port);
					}

					frappe.chat.render(should_render);
			});
		}
	};

	$(document).on('ready toolbar_setup', function () {
		frappe.chat.setup();
	});

	frappe.views.SocialFactory = class SocialFactory extends frappe.views.Factory {
		show() {
			if (frappe.pages.social) {
				frappe.container.change_to('social');
			} else {
				this.make('social');
			}
		}

		make(page_name) {
			var this$1 = this;

			var assets = [
				'/assets/js/social.min.js'
			];

			frappe.require(assets, function () {
				frappe.social.home = new frappe.social.Home({
					parent: this$1.make_page(true, page_name)
				});
			});
		}
	};

	// Copyright (c) 2019, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.energy_points');

	Object.assign(frappe.energy_points, {
		get_points: function get_points(points) {
			return ("<span class=\"bold\" style=\"color: " + (points >= 0 ? '#45A163': '#e42121') + "\">\n\t\t\t" + (points > 0 ? '+': '') + points + "\n\t\t</span>");
		},
		format_form_log: function format_form_log(log) {
			var separator = "<span>&nbsp;-&nbsp;</span>";
			var formatted_log = "<span>\n\t\t\t" + (this.get_points(log.points)) + "&nbsp;\n\t\t\t<a href=\"#Form/Energy Point Log/" + (log.name) + "\">" + (this.get_form_log_message(log)) + "</a>\n\t\t\t" + (log.reason ? separator + log.reason: '') + "\n\t\t</span>";
			return formatted_log;
		},
		format_history_log: function format_history_log(log) {
			// redundant code to honor readability and to avoid confusion
			var separator = "<span>&nbsp;-&nbsp;</span>";
			var route = frappe.utils.get_form_link(log.reference_doctype, log.reference_name);
			var formatted_log = "<span>\n\t\t\t" + (this.get_points(log.points)) + "&nbsp;\n\t\t\t<a href=\"" + route + "\" class=\"text-muted\">" + (this.get_history_log_message(log)) + "</a>\n\t\t\t" + (log.reason ? separator + log.reason: '') + "\n\t\t\t" + (separator + frappe.datetime.comment_when(log.creation)) + "\n\t\t</span>";
			return formatted_log;
		},
		get_history_log_message: function get_history_log_message(log) {
			var owner_name = frappe.user.full_name(log.owner).bold();
			var ref_doc = log.reference_name;

			if (log.type === 'Appreciation') {
				return __('{0} appreciated on {1}', [owner_name, ref_doc]);
			}
			if (log.type === 'Criticism') {
				return __('{0} criticized on {1}', [owner_name, ref_doc]);
			}
			if (log.type === 'Revert') {
				return __('{0} reverted {1}', [owner_name, log.revert_of]);
			}
			return __('via automatic rule {0} on {1}', [log.rule.bold(), ref_doc]);
		},
		get_form_log_message: function get_form_log_message(log) {
			// redundant code to honor readability and to avoid confusion
			var owner_name = frappe.user.full_name(log.owner).bold();
			var user = frappe.user.full_name(log.user).bold();
			if (log.type === 'Appreciation') {
				return __('{0} appreciated {1}', [owner_name, user]);
			}
			if (log.type === 'Criticism') {
				return __('{0} criticized {1}', [owner_name, user]);
			}
			if (log.type === 'Revert') {
				return __('{0} reverted {1}', [owner_name, log.revert_of]);
			}
			return __('gained by {0} via automatic rule {1}', [user, log.rule.bold()]);
		},
	});

	frappe.dashboard_utils = {
		render_chart_filters: function(filters, button_class, container, append) {
			filters.forEach(function (filter) {
				var chart_filter_html =
					"<div class=\"" + button_class + " btn-group dropdown pull-right\">\n\t\t\t\t\t<a class=\"dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n\t\t\t\t\t\t<button class=\"btn btn-default btn-xs\">\n\t\t\t\t\t\t\t<span class=\"filter-label\">" + (filter.label) + "</span>\n\t\t\t\t\t\t\t<span class=\"caret\"></span>\n\t\t\t\t\t\t</button>\n\t\t\t\t</a>";
				var options_html;

				if (filter.fieldnames) {
					options_html = filter.options.map(function (option, i) { return ("<li><a data-fieldname = \"" + (filter.fieldnames[i]) + "\">" + option + "</a></li>"); }).join('');
				} else {
					options_html = filter.options.map( function (option) { return ("<li><a>" + option + "</a></li>"); }).join('');
				}

				var dropdown_html = chart_filter_html + "<ul class=\"dropdown-menu\">" + options_html + "</ul></div>";
				var $chart_filter = $(dropdown_html);

				if (append) {
					$chart_filter.prependTo(container);
				} else { $chart_filter.appendTo(container); }

				$chart_filter.find('.dropdown-menu').on('click', 'li a', function (e) {
					var $el = $(e.currentTarget);
					var fieldname;
					if ($el.attr('data-fieldname')) {
						fieldname = $el.attr('data-fieldname');
					}

					var selected_item = $el.text();
					$el.parents(("." + button_class)).find('.filter-label').text(selected_item);
					filter.action(selected_item, fieldname);
				});
			});

		},

		get_filters_for_chart_type: function(chart) {
			if (chart.chart_type === 'Custom' && chart.source) {
				var method = 'frappe.desk.doctype.dashboard_chart_source.dashboard_chart_source.get_config';
				return frappe.xcall(method, {name: chart.source}).then(function (config) {
					frappe.dom.eval(config);
					return frappe.dashboards.chart_sources[chart.source].filters;
				});
			} else if (chart.chart_type === 'Report' && chart.report_name) {
				return frappe.report_utils.get_report_filters(chart.report_name).then(function (filters) {
					return filters;
				});
			} else {
				return Promise.resolve();
			}
		},

		get_dashboard_settings: function get_dashboard_settings() {
			var this$1 = this;

			return frappe.db.get_list('Dashboard Settings', {
				filters: {
					name: frappe.session.user
				},
				fields: ['*']
			}).then(function (settings) {
				if (!settings.length) {
					return this$1.create_dashboard_settings().then(function (settings) {
						return settings;
					});
				} else {
					return settings[0];
				}
			});
		},

		create_dashboard_settings: function create_dashboard_settings() {
			return frappe.xcall(
				'frappe.desk.doctype.dashboard_settings.dashboard_settings.create_dashboard_settings',
				{
					user: frappe.session.user
				}
			).then(function (settings) {
				return settings;
			});
		},

		get_years_since_creation: function get_years_since_creation(creation) {
			//Get years since user account created
			var creation_year = this.get_year(creation);
			var current_year = this.get_year(frappe.datetime.now_date());
			var years_list = [];
			for (var year = current_year; year >= creation_year; year--) {
				years_list.push(year);
			}
			return years_list;
		},

		get_year: function get_year(date_str) {
			return date_str.substring(0, date_str.indexOf('-'));
		},

		remove_common_static_filter_values: function remove_common_static_filter_values(static_filters, dynamic_filters) {
			if (dynamic_filters) {
				if ($.isArray(static_filters)) {
					static_filters = static_filters.filter(function (static_filter) {
						for (var i = 0, list = dynamic_filters; i < list.length; i += 1) {
							var dynamic_filter = list[i];

							if (static_filter[0] == dynamic_filter[0]
								&& static_filter[1] == dynamic_filter[1]) {
								return false;
							}
						}
						return true;
					});
				} else {
					for (var i = 0, list = Object.keys(dynamic_filters); i < list.length; i += 1) {
						var key = list[i];

						delete static_filters[key];
					}
				}
			}

			return static_filters;
		},

		get_fields_for_dynamic_filter_dialog: function get_fields_for_dynamic_filter_dialog(is_document_type, filters, dynamic_filters) {
			var fields = [
				{
					fieldtype: 'HTML',
					fieldname: 'description',
					options:
						"<div>\n\t\t\t\t\t\t<p>Set dynamic filter values in JavaScript for the required fields here.\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t<p>Ex:\n\t\t\t\t\t\t\t<code>frappe.defaults.get_user_default(\"Company\")</code>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>"
				}
			];

			if (is_document_type) {
				if (dynamic_filters) {
					filters = filters.concat( dynamic_filters);
				}
				filters.forEach(function (f) {
					for (var i = 0, list = fields; i < list.length; i += 1) {
						var field = list[i];

						if (field.fieldname == f[0] + ':' + f[1]) {
							return;
						}
					}
					if (f[2] == '=') {
						fields.push({
							label: ((f[1]) + " (" + (f[0]) + ")"),
							fieldname: f[0] + ':' + f[1],
							fieldtype: 'Data',
						});
					}
				});
			} else {
				filters = Object.assign({}, dynamic_filters, filters);
				for (var i = 0, list = Object.keys(filters); i < list.length; i += 1) {
					var key = list[i];

					fields.push({
						label: key,
						fieldname: key,
						fieldtype: 'Data',
					});
				}
			}

			return fields;
		},

		get_all_filters: function get_all_filters(doc) {
			var filters = JSON.parse(doc.filters_json || "null");
			var dynamic_filters = JSON.parse(doc.dynamic_filters_json || "null");

			if (!dynamic_filters) {
				return filters;
			}

			if ($.isArray(dynamic_filters)) {
				dynamic_filters.forEach(function (f) {
					try {
						f[3] = eval(f[3]);
					} catch (e) {
						frappe.throw(__("Invalid expression set in filter {0} ({1})", [f[1], f[0]]));
					}
				});
				filters = filters.concat( dynamic_filters);
			} else {
				for (var i = 0, list = Object.keys(dynamic_filters); i < list.length; i += 1) {
					var key = list[i];

					try {
						var val = eval(dynamic_filters[key]);
						dynamic_filters[key] = val;
					} catch (e) {
						frappe.throw(__("Invalid expression set in filter {0}", [key]));
					}
				}
				Object.assign(filters, dynamic_filters);
			}

			return filters;
		},

		get_dashboard_link_field: function get_dashboard_link_field() {
			var field = {
				label: __('Select Dashboard'),
				fieldtype: 'Link',
				fieldname: 'dashboard',
				options: 'Dashboard',
			};

			if (!frappe.boot.developer_mode) {
				field.get_query = function () {
					return {
						filters: {
							is_standard: 0
						}
					};
				};
			}

			return field;
		},

		get_add_to_dashboard_dialog: function get_add_to_dashboard_dialog(docname, doctype, method) {
			var field = this.get_dashboard_link_field();

			var dialog = new frappe.ui.Dialog({
				title: __('Add to Dashboard'),
				fields: [field],
				primary_action: function (values) {
					values.name = docname;
					values.set_standard = frappe.boot.developer_mode;
					frappe.xcall(
						method,
						{args: values}
					).then(function (){
						var dashboard_route_html =
							"<a href = \"#dashboard/" + (values.dashboard) + "\">" + (values.dashboard) + "</a>";
						var message =
							__("{0} {1} added to Dashboard {2}", [doctype, values.name, dashboard_route_html]);

						frappe.msgprint(message);
					});

					dialog.hide();
				}
			});

			return dialog;
		}

	};

	function styleInject(t,e){void 0===e&&(e={});var n=e.insertAt;if(t&&"undefined"!=typeof document){var i=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===n&&i.firstChild?i.insertBefore(a,i.firstChild):i.appendChild(a),a.styleSheet?a.styleSheet.cssText=t:a.appendChild(document.createTextNode(t));}}function $$1(t,e){return "string"==typeof t?(e||document).querySelector(t):t||null}function getOffset(t){var e=t.getBoundingClientRect();return {top:e.top+(document.documentElement.scrollTop||document.body.scrollTop),left:e.left+(document.documentElement.scrollLeft||document.body.scrollLeft)}}function isHidden(t){return null===t.offsetParent}function isElementInViewport(t){var e=t.getBoundingClientRect();return e.top>=0&&e.left>=0&&e.bottom<=(window.innerHeight||document.documentElement.clientHeight)&&e.right<=(window.innerWidth||document.documentElement.clientWidth)}function getElementContentWidth(t){var e=window.getComputedStyle(t),n=parseFloat(e.paddingLeft)+parseFloat(e.paddingRight);return t.clientWidth-n}function fire(t,e,n){var i=document.createEvent("HTMLEvents");i.initEvent(e,!0,!0);for(var a in n){ i[a]=n[a]; }return t.dispatchEvent(i)}function getTopOffset(t){return t.titleHeight+t.margins.top+t.paddings.top}function getLeftOffset(t){return t.margins.left+t.paddings.left}function getExtraHeight(t){return t.margins.top+t.margins.bottom+t.paddings.top+t.paddings.bottom+t.titleHeight+t.legendHeight}function getExtraWidth(t){return t.margins.left+t.margins.right+t.paddings.left+t.paddings.right}function _classCallCheck$4(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function floatTwo(t){return parseFloat(t.toFixed(2))}function fillArray(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];n||(n=i?t[0]:t[t.length-1]);var a=new Array(Math.abs(e)).fill(n);return t=i?a.concat(t):t.concat(a)}function getStringWidth(t,e){return (t+"").length*e}function getPositionByAngle(t,e){return {x:Math.sin(t*ANGLE_RATIO)*e,y:Math.cos(t*ANGLE_RATIO)*e}}function getBarHeightAndYAttr(t,e){var n=void 0,i=void 0;return t<=e?(n=e-t,i=t):(n=t-e,i=e),[n,i]}function equilizeNoOfElements(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e.length-t.length;return n>0?t=fillArray(t,n):e=fillArray(e,n),[t,e]}function truncateString(t,e){if(t){ return t.length>e?t.slice(0,e-3)+"...":t }}function shortenLargeNumber(t){var e=void 0;if("number"==typeof t){ e=t; }else if("string"==typeof t&&(e=Number(t),Number.isNaN(e))){ return t; }var n=Math.floor(Math.log10(Math.abs(e)));if(n<=2){ return e; }var i=Math.floor(n/3),a=Math.pow(10,n-3*i)*+(e/Math.pow(10,n)).toFixed(1);return Math.round(100*a)/100+" "+["","K","M","B","T"][i]}function getSplineCurvePointsStr(t,e){for(var n=[],i=0;i<t.length;i++){ n.push([t[i],e[i]]); }var a=function(t,e){var n=e[0]-t[0],i=e[1]-t[1];return {length:Math.sqrt(Math.pow(n,2)+Math.pow(i,2)),angle:Math.atan2(i,n)}},r=function(t,e,n,i){var r=a(e||t,n||t),s=r.angle+(i?Math.PI:0),o=.2*r.length;return [t[0]+Math.cos(s)*o,t[1]+Math.sin(s)*o]};return function(t,e){return t.reduce(function(t,n,i,a){return 0===i?n[0]+","+n[1]:t+" "+e(n,i,a)},"")}(n,function(t,e,n){var i=r(n[e-1],n[e-2],t),a=r(t,n[e-1],n[e+1],!0);return "C "+i[0]+","+i[1]+" "+a[0]+","+a[1]+" "+t[0]+","+t[1]})}function limitColor(t){return t>255?255:t<0?0:t}function lightenDarkenColor(t,e){var n=getColor(t),i=!1;"#"==n[0]&&(n=n.slice(1),i=!0);var a=parseInt(n,16),r=limitColor((a>>16)+e),s=limitColor((a>>8&255)+e),o=limitColor((255&a)+e);return (i?"#":"")+(o|s<<8|r<<16).toString(16)}function isValidColor(t){var e=/(^\s*)(rgb|hsl)(a?)[(]\s*([\d.]+\s*%?)\s*,\s*([\d.]+\s*%?)\s*,\s*([\d.]+\s*%?)\s*(?:,\s*([\d.]+)\s*)?[)]$/i;return /(^\s*)(#)((?:[A-Fa-f0-9]{3}){1,2})$/i.test(t)||e.test(t)}function $$1$1(t,e){return "string"==typeof t?(e||document).querySelector(t):t||null}function createSVG(t,e){var n=document.createElementNS("http://www.w3.org/2000/svg",t);for(var i in e){var a=e[i];if("inside"===i){ $$1$1(a).appendChild(n); }else if("around"===i){var r=$$1$1(a);r.parentNode.insertBefore(n,r),n.appendChild(r);}else{ "styles"===i?"object"===(void 0===a?"undefined":_typeof$1(a))&&Object.keys(a).map(function(t){n.style[t]=a[t];}):("className"===i&&(i="class"),"innerHTML"===i?n.textContent=a:n.setAttribute(i,a)); }}return n}function renderVerticalGradient(t,e){return createSVG("linearGradient",{inside:t,id:e,x1:0,x2:0,y1:0,y2:1})}function setGradientStop(t,e,n,i){return createSVG("stop",{inside:t,style:"stop-color: "+n,offset:e,"stop-opacity":i})}function makeSVGContainer(t,e,n,i){return createSVG("svg",{className:e,inside:t,width:n,height:i})}function makeSVGDefs(t){return createSVG("defs",{inside:t})}function makeSVGGroup(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,i={className:t,transform:e};return n&&(i.inside=n),createSVG("g",i)}function makePath(t){return createSVG("path",{className:arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",d:t,styles:{stroke:arguments.length>2&&void 0!==arguments[2]?arguments[2]:"none",fill:arguments.length>3&&void 0!==arguments[3]?arguments[3]:"none","stroke-width":arguments.length>4&&void 0!==arguments[4]?arguments[4]:2}})}function makeArcPathStr(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=n.x+t.x,o=n.y+t.y,l=n.x+e.x,u=n.y+e.y;return "M"+n.x+" "+n.y+"\n\t\tL"+s+" "+o+"\n\t\tA "+i+" "+i+" 0 "+r+" "+(a?1:0)+"\n\t\t"+l+" "+u+" z"}function makeCircleStr(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=n.x+t.x,o=n.y+t.y,l=n.x+e.x,u=2*n.y,c=n.y+e.y;return "M"+n.x+" "+n.y+"\n\t\tL"+s+" "+o+"\n\t\tA "+i+" "+i+" 0 "+r+" "+(a?1:0)+"\n\t\t"+l+" "+u+" z\n\t\tL"+s+" "+u+"\n\t\tA "+i+" "+i+" 0 "+r+" "+(a?1:0)+"\n\t\t"+l+" "+c+" z"}function makeArcStrokePathStr(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=n.x+t.x,o=n.y+t.y,l=n.x+e.x,u=n.y+e.y;return "M"+s+" "+o+"\n\t\tA "+i+" "+i+" 0 "+r+" "+(a?1:0)+"\n\t\t"+l+" "+u}function makeStrokeCircleStr(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=n.x+t.x,o=n.y+t.y,l=n.x+e.x,u=2*i+o,c=n.y+t.y;return "M"+s+" "+o+"\n\t\tA "+i+" "+i+" 0 "+r+" "+(a?1:0)+"\n\t\t"+l+" "+u+"\n\t\tM"+s+" "+u+"\n\t\tA "+i+" "+i+" 0 "+r+" "+(a?1:0)+"\n\t\t"+l+" "+c}function makeGradient(t,e){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i="path-fill-gradient-"+e+"-"+(n?"lighter":"default"),a=renderVerticalGradient(t,i),r=[1,.6,.2];return n&&(r=[.4,.2,0]),setGradientStop(a,"0%",e,r[0]),setGradientStop(a,"50%",e,r[1]),setGradientStop(a,"100%",e,r[2]),i}function percentageBar(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:PERCENTAGE_BAR_DEFAULT_DEPTH,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"none";return createSVG("rect",{className:"percentage-bar",x:t,y:e,width:n,height:i,fill:r,styles:{stroke:lightenDarkenColor(r,-25),"stroke-dasharray":"0, "+(i+n)+", "+n+", "+i,"stroke-width":a}})}function heatSquare(t,e,n,i,a){var r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"none",s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:{},o={className:t,x:e,y:n,width:i,height:i,rx:a,fill:r};return Object.keys(s).map(function(t){o[t]=s[t];}),createSVG("rect",o)}function legendBar(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"none",a=arguments[4];a=arguments.length>5&&void 0!==arguments[5]&&arguments[5]?truncateString(a,LABEL_MAX_CHARS):a;var r={className:"legend-bar",x:0,y:0,width:n,height:"2px",fill:i},s=createSVG("text",{className:"legend-dataset-text",x:0,y:0,dy:2*FONT_SIZE+"px","font-size":1.2*FONT_SIZE+"px","text-anchor":"start",fill:FONT_FILL,innerHTML:a}),o=createSVG("g",{transform:"translate("+t+", "+e+")"});return o.appendChild(createSVG("rect",r)),o.appendChild(s),o}function legendDot(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"none",a=arguments[4];a=arguments.length>5&&void 0!==arguments[5]&&arguments[5]?truncateString(a,LABEL_MAX_CHARS):a;var r={className:"legend-dot",cx:0,cy:0,r:n,fill:i},s=createSVG("text",{className:"legend-dataset-text",x:0,y:0,dx:FONT_SIZE+"px",dy:FONT_SIZE/3+"px","font-size":1.2*FONT_SIZE+"px","text-anchor":"start",fill:FONT_FILL,innerHTML:a}),o=createSVG("g",{transform:"translate("+t+", "+e+")"});return o.appendChild(createSVG("circle",r)),o.appendChild(s),o}function makeText(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},r=a.fontSize||FONT_SIZE;return createSVG("text",{className:t,x:e,y:n,dy:(void 0!==a.dy?a.dy:r/2)+"px","font-size":r+"px",fill:a.fill||FONT_FILL,"text-anchor":a.textAnchor||"start",innerHTML:i})}function makeVertLine(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};a.stroke||(a.stroke=BASE_LINE_COLOR);var r=createSVG("line",{className:"line-vertical "+a.className,x1:0,x2:0,y1:n,y2:i,styles:{stroke:a.stroke}}),s=createSVG("text",{x:0,y:n>i?n+LABEL_MARGIN:n-LABEL_MARGIN-FONT_SIZE,dy:FONT_SIZE+"px","font-size":FONT_SIZE+"px","text-anchor":"middle",innerHTML:e+""}),o=createSVG("g",{transform:"translate("+t+", 0)"});return o.appendChild(r),o.appendChild(s),o}function makeHoriLine(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};a.stroke||(a.stroke=BASE_LINE_COLOR),a.lineType||(a.lineType=""),a.shortenNumbers&&(e=shortenLargeNumber(e));var r=createSVG("line",{className:"line-horizontal "+a.className+("dashed"===a.lineType?"dashed":""),x1:n,x2:i,y1:0,y2:0,styles:{stroke:a.stroke}}),s=createSVG("text",{x:n<i?n-LABEL_MARGIN:n+LABEL_MARGIN,y:0,dy:FONT_SIZE/2-2+"px","font-size":FONT_SIZE+"px","text-anchor":n<i?"end":"start",innerHTML:e+""}),o=createSVG("g",{transform:"translate(0, "+t+")","stroke-opacity":1});return 0!==s&&"0"!==s||(o.style.stroke="rgba(27, 31, 35, 0.6)"),o.appendChild(r),o.appendChild(s),o}function yLine(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};i.pos||(i.pos="left"),i.offset||(i.offset=0),i.mode||(i.mode="span"),i.stroke||(i.stroke=BASE_LINE_COLOR),i.className||(i.className="");var a=-1*AXIS_TICK_LENGTH,r="span"===i.mode?n+AXIS_TICK_LENGTH:0;return "tick"===i.mode&&"right"===i.pos&&(a=n+AXIS_TICK_LENGTH,r=n),a+=i.offset,r+=i.offset,makeHoriLine(t,e,a,r,{stroke:i.stroke,className:i.className,lineType:i.lineType,shortenNumbers:i.shortenNumbers})}function xLine(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};i.pos||(i.pos="bottom"),i.offset||(i.offset=0),i.mode||(i.mode="span"),i.stroke||(i.stroke=BASE_LINE_COLOR),i.className||(i.className="");var a=n+AXIS_TICK_LENGTH,r="span"===i.mode?-1*AXIS_TICK_LENGTH:n;return "tick"===i.mode&&"top"===i.pos&&(a=-1*AXIS_TICK_LENGTH,r=0),makeVertLine(t,e,a,r,{stroke:i.stroke,className:i.className,lineType:i.lineType})}function yMarker(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};i.labelPos||(i.labelPos="right");var a=createSVG("text",{className:"chart-label",x:"left"===i.labelPos?LABEL_MARGIN:n-getStringWidth(e,5)-LABEL_MARGIN,y:0,dy:FONT_SIZE/-2+"px","font-size":FONT_SIZE+"px","text-anchor":"start",innerHTML:e+""}),r=makeHoriLine(t,"",0,n,{stroke:i.stroke||BASE_LINE_COLOR,className:i.className||"",lineType:i.lineType});return r.appendChild(a),r}function yRegion(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},r=t-e,s=createSVG("rect",{className:"bar mini",styles:{fill:"rgba(228, 234, 239, 0.49)",stroke:BASE_LINE_COLOR,"stroke-dasharray":n+", "+r},x:0,y:0,width:n,height:r});a.labelPos||(a.labelPos="right");var o=createSVG("text",{className:"chart-label",x:"left"===a.labelPos?LABEL_MARGIN:n-getStringWidth(i+"",4.5)-LABEL_MARGIN,y:0,dy:FONT_SIZE/-2+"px","font-size":FONT_SIZE+"px","text-anchor":"start",innerHTML:i+""}),l=createSVG("g",{transform:"translate(0, "+e+")"});return l.appendChild(s),l.appendChild(o),l}function datasetBar(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:{},l=getBarHeightAndYAttr(e,o.zeroLine),u=_slicedToArray(l,2),c=u[0],h=u[1];h-=s,0===c&&(c=o.minHeight,h-=o.minHeight);var d=createSVG("rect",{className:"bar mini",style:"fill: "+i,"data-point-index":r,x:t,y:h,width:n,height:c});if((a+="")||a.length){d.setAttribute("y",0),d.setAttribute("x",0);var f=createSVG("text",{className:"data-point-value",x:n/2,y:0,dy:FONT_SIZE/2*-1+"px","font-size":FONT_SIZE+"px","text-anchor":"middle",innerHTML:a}),p=createSVG("g",{"data-point-index":r,transform:"translate("+t+", "+h+")"});return p.appendChild(d),p.appendChild(f),p}return d}function datasetDot(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=createSVG("circle",{style:"fill: "+i,"data-point-index":r,cx:t,cy:e,r:n});if((a+="")||a.length){s.setAttribute("cy",0),s.setAttribute("cx",0);var o=createSVG("text",{className:"data-point-value",x:0,y:0,dy:FONT_SIZE/2*-1-n+"px","font-size":FONT_SIZE+"px","text-anchor":"middle",innerHTML:a}),l=createSVG("g",{"data-point-index":r,transform:"translate("+t+", "+e+")"});return l.appendChild(s),l.appendChild(o),l}return s}function getPaths(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},r=e.map(function(e,n){return t[n]+","+e}).join("L");i.spline&&(r=getSplineCurvePointsStr(t,e));var s=makePath("M"+r,"line-graph-path",n);if(i.heatline){var o=makeGradient(a.svgDefs,n);s.style.stroke="url(#"+o+")";}var l={path:s};if(i.regionFill){var u=makeGradient(a.svgDefs,n,!0),c="M"+t[0]+","+a.zeroLine+"L"+r+"L"+t.slice(-1)[0]+","+a.zeroLine;l.region=makePath(c,"region-fill","none","url(#"+u+")");}return l}function translate(t,e,n,i){var a="string"==typeof e?e:e.join(", ");return [t,{transform:n.join(", ")},i,STD_EASING,"translate",{transform:a}]}function translateVertLine(t,e,n){return translate(t,[n,0],[e,0],MARKER_LINE_ANIM_DUR)}function translateHoriLine(t,e,n){return translate(t,[0,n],[0,e],MARKER_LINE_ANIM_DUR)}function animateRegion(t,e,n,i){var a=e-n,r=t.childNodes[0];return [[r,{height:a,"stroke-dasharray":r.getAttribute("width")+", "+a},MARKER_LINE_ANIM_DUR,STD_EASING],translate(t,[0,i],[0,n],MARKER_LINE_ANIM_DUR)]}function animateBar(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=getBarHeightAndYAttr(n,(arguments.length>5&&void 0!==arguments[5]?arguments[5]:{}).zeroLine),s=_slicedToArray$2(r,2),o=s[0],l=s[1];return l-=a,"rect"!==t.nodeName?[[t.childNodes[0],{width:i,height:o},UNIT_ANIM_DUR,STD_EASING],translate(t,t.getAttribute("transform").split("(")[1].slice(0,-1),[e,l],MARKER_LINE_ANIM_DUR)]:[[t,{width:i,height:o,x:e,y:l},UNIT_ANIM_DUR,STD_EASING]]}function animateDot(t,e,n){return "circle"!==t.nodeName?[translate(t,t.getAttribute("transform").split("(")[1].slice(0,-1),[e,n],MARKER_LINE_ANIM_DUR)]:[[t,{cx:e,cy:n},UNIT_ANIM_DUR,STD_EASING]]}function animatePath(t,e,n,i,a){var r=[],s=n.map(function(t,n){return e[n]+","+t}).join("L");a&&(s=getSplineCurvePointsStr(e,n));var o=[t.path,{d:"M"+s},PATH_ANIM_DUR,STD_EASING];if(r.push(o),t.region){var l=e[0]+","+i+"L",u="L"+e.slice(-1)[0]+", "+i,c=[t.region,{d:"M"+l+s+u},PATH_ANIM_DUR,STD_EASING];r.push(c);}return r}function animatePathStr(t,e){return [t,{d:e},UNIT_ANIM_DUR,STD_EASING]}function _toConsumableArray$1(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function animateSVGElement(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"linear",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{},s=t.cloneNode(!0),o=t.cloneNode(!0);for(var l in e){var u=void 0;u="transform"===l?document.createElementNS("http://www.w3.org/2000/svg","animateTransform"):document.createElementNS("http://www.w3.org/2000/svg","animate");var c=r[l]||t.getAttribute(l),h=e[l],d={attributeName:l,from:c,to:h,begin:"0s",dur:n/1e3+"s",values:c+";"+h,keySplines:EASING[i],keyTimes:"0;1",calcMode:"spline",fill:"freeze"};a&&(d.type=a);for(var f in d){ u.setAttribute(f,d[f]); }s.appendChild(u),a?o.setAttribute(l,"translate("+h+")"):o.setAttribute(l,h);}return [s,o]}function transform(t,e){t.style.transform=e,t.style.webkitTransform=e,t.style.msTransform=e,t.style.mozTransform=e,t.style.oTransform=e;}function animateSVG(t,e){var n=[],i=[];e.map(function(t){var e=t[0],a=e.parentNode,r=void 0,s=void 0;t[0]=e;var o=animateSVGElement.apply(void 0,_toConsumableArray$1(t)),l=_slicedToArray$1(o,2);r=l[0],s=l[1],n.push(s),i.push([r,a]),a.replaceChild(r,e);});var a=t.cloneNode(!0);return i.map(function(t,i){t[1].replaceChild(n[i],t[0]),e[i][0]=n[i];}),a}function runSMILAnimation(t,e,n){if(0!==n.length){var i=animateSVG(e,n);e.parentNode==t&&(t.removeChild(e),t.appendChild(i)),setTimeout(function(){i.parentNode==t&&(t.removeChild(i),t.appendChild(e));},REPLACE_ALL_NEW_DUR);}}function downloadFile(t,e){var n=document.createElement("a");n.style="display: none";var i=new Blob(e,{type:"image/svg+xml; charset=utf-8"}),a=window.URL.createObjectURL(i);n.href=a,n.download=t,document.body.appendChild(n),n.click(),setTimeout(function(){document.body.removeChild(n),window.URL.revokeObjectURL(a);},300);}function prepareForExport(t){var e=t.cloneNode(!0);e.classList.add("chart-container"),e.setAttribute("xmlns","http://www.w3.org/2000/svg"),e.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink");var n=$$1.create("style",{innerHTML:CSSTEXT});e.insertBefore(n,e.firstChild);var i=$$1.create("div");return i.appendChild(e),i.innerHTML}function _classCallCheck$3(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _classCallCheck$2(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _possibleConstructorReturn$1(t,e){if(!t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return !e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits$1(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function, not "+typeof e); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}function treatAsUtc(t){var e=new Date(t);return e.setMinutes(e.getMinutes()-e.getTimezoneOffset()),e}function getYyyyMmDd(t){var e=t.getDate(),n=t.getMonth()+1;return [t.getFullYear(),(n>9?"":"0")+n,(e>9?"":"0")+e].join("-")}function clone(t){return new Date(t.getTime())}function getWeeksBetween(t,e){var n=setDayToSunday(t);return Math.ceil(getDaysBetween(n,e)/NO_OF_DAYS_IN_WEEK)}function getDaysBetween(t,e){var n=SEC_IN_DAY*NO_OF_MILLIS;return (treatAsUtc(e)-treatAsUtc(t))/n}function areInSameMonth(t,e){return t.getMonth()===e.getMonth()&&t.getFullYear()===e.getFullYear()}function getMonthName(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=MONTH_NAMES[t];return e?n.slice(0,3):n}function getLastDateInMonth(t,e){return new Date(e,t+1,0)}function setDayToSunday(t){var e=clone(t),n=e.getDay();return 0!==n&&addDays(e,-1*n),e}function addDays(t,e){t.setDate(t.getDate()+e);}function _classCallCheck$5(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function getComponent(t,e,n){var i=Object.keys(componentConfigs).filter(function(e){return t.includes(e)}),a=componentConfigs[i[0]];return Object.assign(a,{constants:e,getData:n}),new ChartComponent(a)}function _toConsumableArray(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function _classCallCheck$1(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _possibleConstructorReturn(t,e){if(!t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return !e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function, not "+typeof e); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}function _toConsumableArray$2(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function _classCallCheck$6(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _possibleConstructorReturn$2(t,e){if(!t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return !e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits$2(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function, not "+typeof e); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}function _toConsumableArray$4(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function normalize(t){if(0===t){ return [0,0]; }if(isNaN(t)){ return {mantissa:-6755399441055744,exponent:972}; }var e=t>0?1:-1;if(!isFinite(t)){ return {mantissa:4503599627370496*e,exponent:972}; }t=Math.abs(t);var n=Math.floor(Math.log10(t));return [e*(t/Math.pow(10,n)),n]}function getChartRangeIntervals(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Math.ceil(t),i=Math.floor(e),a=n-i,r=a,s=1;a>5&&(a%2!=0&&(a=++n-i),r=a/2,s=2),a<=2&&(s=a/(r=4)),0===a&&(r=5,s=1);for(var o=[],l=0;l<=r;l++){ o.push(i+s*l); }return o}function getChartIntervals(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=normalize(t),i=_slicedToArray$4(n,2),a=i[0],r=i[1],s=e?e/Math.pow(10,r):0,o=getChartRangeIntervals(a=a.toFixed(6),s);return o=o.map(function(t){return t*Math.pow(10,r)})}function calcChartIntervals(t){function e(t,e){for(var n=getChartIntervals(t),i=n[1]-n[0],a=0,r=1;a<e;r++){ a+=i,n.unshift(-1*a); }return n}var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=Math.max.apply(Math,_toConsumableArray$4(t)),a=Math.min.apply(Math,_toConsumableArray$4(t)),r=[];if(i>=0&&a>=0){ normalize(i)[1],r=n?getChartIntervals(i,a):getChartIntervals(i); }else if(i>0&&a<0){var s=Math.abs(a);i>=s?(normalize(i)[1],r=e(i,s)):(normalize(s)[1],r=e(s,i).map(function(t){return -1*t}));}else if(i<=0&&a<=0){var o=Math.abs(a),l=Math.abs(i);normalize(o)[1],r=(r=n?getChartIntervals(o,l):getChartIntervals(o)).reverse().map(function(t){return -1*t});}return r}function getZeroIndex(t){var e=getIntervalSize(t);return t.indexOf(0)>=0?t.indexOf(0):t[0]>0?-1*t[0]/e:-1*t[t.length-1]/e+(t.length-1)}function getIntervalSize(t){return t[1]-t[0]}function getValueRange(t){return t[t.length-1]-t[0]}function scale(t,e){return floatTwo(e.zeroLine-t*e.scaleMultiplier)}function getClosestInArray(t,e){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=e.reduce(function(e,n){return Math.abs(n-t)<Math.abs(e-t)?n:e},[]);return n?e.indexOf(i):i}function calcDistribution(t,e){for(var n=Math.max.apply(Math,_toConsumableArray$4(t)),i=1/(e-1),a=[],r=0;r<e;r++){var s=n*(i*r);a.push(s);}return a}function getMaxCheckpoint(t,e){return e.filter(function(e){return e<t}).length}function _toConsumableArray$3(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function _classCallCheck$7(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _possibleConstructorReturn$3(t,e){if(!t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return !e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits$3(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function, not "+typeof e); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}function _toConsumableArray$6(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function dataPrep(t,e){t.labels=t.labels||[];var n=t.labels.length,i=t.datasets,a=new Array(n).fill(0);return i||(i=[{values:a}]),i.map(function(t){if(t.values){var i=t.values;i=(i=i.map(function(t){return isNaN(t)?0:t})).length>n?i.slice(0,n):fillArray(i,n-i.length,0);}else { t.values=a; }t.chartType||(t.chartType=e);}),t.yRegions&&t.yRegions.map(function(t){if(t.end<t.start){var e=[t.end,t.start];t.start=e[0],t.end=e[1];}}),t}function zeroDataPrep(t){var e=t.labels.length,n=new Array(e).fill(0),i={labels:t.labels.slice(0,-1),datasets:t.datasets.map(function(t){return {name:"",values:n.slice(0,-1),chartType:t.chartType}})};return t.yMarkers&&(i.yMarkers=[{value:0,label:""}]),t.yRegions&&(i.yRegions=[{start:0,end:0,label:""}]),i}function getShortenedLabels(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],i=t/e.length;i<=0&&(i=1);var a=i/DEFAULT_CHAR_WIDTH,r=void 0;if(n){var s=Math.max.apply(Math,_toConsumableArray$6(e.map(function(t){return t.length})));r=Math.ceil(s/a);}return e.map(function(t,e){return (t+="").length>a&&(n?e%r!=0&&(t=""):t=a-3>0?t.slice(0,a-3)+" ...":t.slice(0,a)+".."),t})}function _toConsumableArray$5(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function _classCallCheck$8(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _possibleConstructorReturn$4(t,e){if(!t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return !e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits$4(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function, not "+typeof e); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}function _toConsumableArray$7(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function _classCallCheck$9(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _possibleConstructorReturn$5(t,e){if(!t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return !e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits$5(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function, not "+typeof e); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}function _classCallCheck(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function getChartByType(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"line",e=arguments[1],n=arguments[2];return "axis-mixed"===t?(n.type="line",new AxisChart(e,n)):chartTypes[t]?new chartTypes[t](e,n):void console.error("Undefined chart type: "+t)}var css_248z='.chart-container{position:relative;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif}.chart-container .axis,.chart-container .chart-label{fill:#555b51}.chart-container .axis line,.chart-container .chart-label line{stroke:#dadada}.chart-container .dataset-units circle{stroke:#fff;stroke-width:2}.chart-container .dataset-units path{fill:none;stroke-opacity:1;stroke-width:2px}.chart-container .dataset-path{stroke-width:2px}.chart-container .path-group path{fill:none;stroke-opacity:1;stroke-width:2px}.chart-container line.dashed{stroke-dasharray:5,3}.chart-container .axis-line .specific-value{text-anchor:start}.chart-container .axis-line .y-line{text-anchor:end}.chart-container .axis-line .x-line{text-anchor:middle}.chart-container .legend-dataset-text{fill:#6c7680;font-weight:600}.graph-svg-tip{position:absolute;z-index:99999;padding:10px;font-size:12px;color:#959da5;text-align:center;background:rgba(0,0,0,.8);border-radius:3px}.graph-svg-tip ol,.graph-svg-tip ul{padding-left:0;display:-webkit-box;display:-ms-flexbox;display:flex}.graph-svg-tip ul.data-point-list li{min-width:90px;-webkit-box-flex:1;-ms-flex:1;flex:1;font-weight:600}.graph-svg-tip strong{color:#dfe2e5;font-weight:600}.graph-svg-tip .svg-pointer{position:absolute;height:5px;margin:0 0 0 -5px;content:" ";border:5px solid transparent;border-top-color:rgba(0,0,0,.8)}.graph-svg-tip.comparison{padding:0;text-align:left;pointer-events:none}.graph-svg-tip.comparison .title{display:block;padding:10px;margin:0;font-weight:600;line-height:1;pointer-events:none}.graph-svg-tip.comparison ul{margin:0;white-space:nowrap;list-style:none}.graph-svg-tip.comparison li{display:inline-block;padding:5px 10px}';styleInject(css_248z);var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};$$1.create=function(t,e){var n=document.createElement(t);for(var i in e){var a=e[i];if("inside"===i){ $$1(a).appendChild(n); }else if("around"===i){var r=$$1(a);r.parentNode.insertBefore(n,r),n.appendChild(r);}else{ "styles"===i?"object"===(void 0===a?"undefined":_typeof(a))&&Object.keys(a).map(function(t){n.style[t]=a[t];}):i in n?n[i]=a:n.setAttribute(i,a); }}return n};var BASE_MEASURES={margins:{top:10,bottom:10,left:20,right:20},paddings:{top:20,bottom:40,left:30,right:10},baseHeight:240,titleHeight:20,legendHeight:30,titleFontSize:12},INIT_CHART_UPDATE_TIMEOUT=700,CHART_POST_ANIMATE_TIMEOUT=400,AXIS_LEGEND_BAR_SIZE=100,BAR_CHART_SPACE_RATIO=.5,MIN_BAR_PERCENT_HEIGHT=0,LINE_CHART_DOT_SIZE=4,DOT_OVERLAY_SIZE_INCR=4,PERCENTAGE_BAR_DEFAULT_HEIGHT=20,PERCENTAGE_BAR_DEFAULT_DEPTH=2,HEATMAP_DISTRIBUTION_SIZE=5,HEATMAP_SQUARE_SIZE=10,HEATMAP_GUTTER_SIZE=2,DEFAULT_CHAR_WIDTH=7,TOOLTIP_POINTER_TRIANGLE_HEIGHT=5,DEFAULT_CHART_COLORS=["light-blue","blue","violet","red","orange","yellow","green","light-green","purple","magenta","light-grey","dark-grey"],HEATMAP_COLORS_GREEN=["#ebedf0","#c6e48b","#7bc96f","#239a3b","#196127"],DEFAULT_COLORS={bar:DEFAULT_CHART_COLORS,line:DEFAULT_CHART_COLORS,pie:DEFAULT_CHART_COLORS,percentage:DEFAULT_CHART_COLORS,heatmap:HEATMAP_COLORS_GREEN,donut:DEFAULT_CHART_COLORS},ANGLE_RATIO=Math.PI/180,FULL_ANGLE=360,_createClass$3=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),SvgTip=function(){function t(e){var n=e.parent,i=void 0===n?null:n,a=e.colors,r=void 0===a?[]:a;_classCallCheck$4(this,t),this.parent=i,this.colors=r,this.titleName="",this.titleValue="",this.listValues=[],this.titleValueFirst=0,this.x=0,this.y=0,this.top=0,this.left=0,this.setup();}return _createClass$3(t,[{key:"setup",value:function(){this.makeTooltip();}},{key:"refresh",value:function(){this.fill(),this.calcPosition();}},{key:"makeTooltip",value:function(){var t=this;this.container=$$1.create("div",{inside:this.parent,className:"graph-svg-tip comparison",innerHTML:'<span class="title"></span>\n\t\t\t\t<ul class="data-point-list"></ul>\n\t\t\t\t<div class="svg-pointer"></div>'}),this.hideTip(),this.title=this.container.querySelector(".title"),this.dataPointList=this.container.querySelector(".data-point-list"),this.parent.addEventListener("mouseleave",function(){t.hideTip();});}},{key:"fill",value:function(){var t=this,e=void 0;this.index&&this.container.setAttribute("data-point-index",this.index),e=this.titleValueFirst?"<strong>"+this.titleValue+"</strong>"+this.titleName:this.titleName+"<strong>"+this.titleValue+"</strong>",this.title.innerHTML=e,this.dataPointList.innerHTML="",this.listValues.map(function(e,n){var i=t.colors[n]||"black",a=0===e.formatted||e.formatted?e.formatted:e.value,r=$$1.create("li",{styles:{"border-top":"3px solid "+i},innerHTML:'<strong style="display: block;">'+(0===a||a?a:"")+"</strong>\n\t\t\t\t\t"+(e.title?e.title:"")});t.dataPointList.appendChild(r);});}},{key:"calcPosition",value:function(){var t=this.container.offsetWidth;this.top=this.y-this.container.offsetHeight-TOOLTIP_POINTER_TRIANGLE_HEIGHT,this.left=this.x-t/2;var e=this.parent.offsetWidth-t,n=this.container.querySelector(".svg-pointer");if(this.left<0){ n.style.left="calc(50% - "+-1*this.left+"px)",this.left=0; }else if(this.left>e){var i="calc(50% + "+(this.left-e)+"px)";n.style.left=i,this.left=e;}else { n.style.left="50%"; }}},{key:"setValues",value:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:-1;this.titleName=n.name,this.titleValue=n.value,this.listValues=i,this.x=t,this.y=e,this.titleValueFirst=n.valueFirst||0,this.index=a,this.refresh();}},{key:"hideTip",value:function(){this.container.style.top="0px",this.container.style.left="0px",this.container.style.opacity="0";}},{key:"showTip",value:function(){this.container.style.top=this.top+"px",this.container.style.left=this.left+"px",this.container.style.opacity="1";}}]),t}(),PRESET_COLOR_MAP={"light-blue":"#7cd6fd",blue:"#5e64ff",violet:"#743ee2",red:"#ff5858",orange:"#ffa00a",yellow:"#feef72",green:"#28a745","light-green":"#98d85b",purple:"#b554ff",magenta:"#ffa3ef",black:"#36114C",grey:"#bdd3e6","light-grey":"#f0f4f7","dark-grey":"#b8c2cc"},getColor=function(t){return PRESET_COLOR_MAP[t]||t},_slicedToArray=function(){function t(t,e){var n=[],i=!0,a=!1,r=void 0;try{for(var s,o=t[Symbol.iterator]();!(i=(s=o.next()).done)&&(n.push(s.value),!e||n.length!==e);i=!0){ }}catch(t){a=!0,r=t;}finally{try{!i&&o.return&&o.return();}finally{if(a){ throw r }}}return n}return function(e,n){if(Array.isArray(e)){ return e; }if(Symbol.iterator in Object(e)){ return t(e,n); }throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_typeof$1="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},AXIS_TICK_LENGTH=6,LABEL_MARGIN=4,LABEL_MAX_CHARS=15,FONT_SIZE=10,BASE_LINE_COLOR="#dadada",FONT_FILL="#555b51",makeOverlay={bar:function(t){var e=void 0;"rect"!==t.nodeName&&(e=t.getAttribute("transform"),t=t.childNodes[0]);var n=t.cloneNode();return n.style.fill="#000000",n.style.opacity="0.4",e&&n.setAttribute("transform",e),n},dot:function(t){var e=void 0;"circle"!==t.nodeName&&(e=t.getAttribute("transform"),t=t.childNodes[0]);var n=t.cloneNode(),i=t.getAttribute("r"),a=t.getAttribute("fill");return n.setAttribute("r",parseInt(i)+DOT_OVERLAY_SIZE_INCR),n.setAttribute("fill",a),n.style.opacity="0.6",e&&n.setAttribute("transform",e),n},heat_square:function(t){var e=void 0;"circle"!==t.nodeName&&(e=t.getAttribute("transform"),t=t.childNodes[0]);var n=t.cloneNode(),i=t.getAttribute("r"),a=t.getAttribute("fill");return n.setAttribute("r",parseInt(i)+DOT_OVERLAY_SIZE_INCR),n.setAttribute("fill",a),n.style.opacity="0.6",e&&n.setAttribute("transform",e),n}},updateOverlay={bar:function(t,e){var n=void 0;"rect"!==t.nodeName&&(n=t.getAttribute("transform"),t=t.childNodes[0]);var i=["x","y","width","height"];Object.values(t.attributes).filter(function(t){return i.includes(t.name)&&t.specified}).map(function(t){e.setAttribute(t.name,t.nodeValue);}),n&&e.setAttribute("transform",n);},dot:function(t,e){var n=void 0;"circle"!==t.nodeName&&(n=t.getAttribute("transform"),t=t.childNodes[0]);var i=["cx","cy"];Object.values(t.attributes).filter(function(t){return i.includes(t.name)&&t.specified}).map(function(t){e.setAttribute(t.name,t.nodeValue);}),n&&e.setAttribute("transform",n);},heat_square:function(t,e){var n=void 0;"circle"!==t.nodeName&&(n=t.getAttribute("transform"),t=t.childNodes[0]);var i=["cx","cy"];Object.values(t.attributes).filter(function(t){return i.includes(t.name)&&t.specified}).map(function(t){e.setAttribute(t.name,t.nodeValue);}),n&&e.setAttribute("transform",n);}},_slicedToArray$2=function(){function t(t,e){var n=[],i=!0,a=!1,r=void 0;try{for(var s,o=t[Symbol.iterator]();!(i=(s=o.next()).done)&&(n.push(s.value),!e||n.length!==e);i=!0){ }}catch(t){a=!0,r=t;}finally{try{!i&&o.return&&o.return();}finally{if(a){ throw r }}}return n}return function(e,n){if(Array.isArray(e)){ return e; }if(Symbol.iterator in Object(e)){ return t(e,n); }throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),UNIT_ANIM_DUR=350,PATH_ANIM_DUR=350,MARKER_LINE_ANIM_DUR=UNIT_ANIM_DUR,REPLACE_ALL_NEW_DUR=250,STD_EASING="easein",_slicedToArray$1=function(){function t(t,e){var n=[],i=!0,a=!1,r=void 0;try{for(var s,o=t[Symbol.iterator]();!(i=(s=o.next()).done)&&(n.push(s.value),!e||n.length!==e);i=!0){ }}catch(t){a=!0,r=t;}finally{try{!i&&o.return&&o.return();}finally{if(a){ throw r }}}return n}return function(e,n){if(Array.isArray(e)){ return e; }if(Symbol.iterator in Object(e)){ return t(e,n); }throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),EASING={ease:"0.25 0.1 0.25 1",linear:"0 0 1 1",easein:"0.1 0.8 0.2 1",easeout:"0 0 0.58 1",easeinout:"0.42 0 0.58 1"},CSSTEXT=".chart-container{position:relative;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Fira Sans','Droid Sans','Helvetica Neue',sans-serif}.chart-container .axis,.chart-container .chart-label{fill:#555b51}.chart-container .axis line,.chart-container .chart-label line{stroke:#dadada}.chart-container .dataset-units circle{stroke:#fff;stroke-width:2}.chart-container .dataset-units path{fill:none;stroke-opacity:1;stroke-width:2px}.chart-container .dataset-path{stroke-width:2px}.chart-container .path-group path{fill:none;stroke-opacity:1;stroke-width:2px}.chart-container line.dashed{stroke-dasharray:5,3}.chart-container .axis-line .specific-value{text-anchor:start}.chart-container .axis-line .y-line{text-anchor:end}.chart-container .axis-line .x-line{text-anchor:middle}.chart-container .legend-dataset-text{fill:#6c7680;font-weight:600}.graph-svg-tip{position:absolute;z-index:99999;padding:10px;font-size:12px;color:#959da5;text-align:center;background:rgba(0,0,0,.8);border-radius:3px}.graph-svg-tip ul{padding-left:0;display:flex}.graph-svg-tip ol{padding-left:0;display:flex}.graph-svg-tip ul.data-point-list li{min-width:90px;flex:1;font-weight:600}.graph-svg-tip strong{color:#dfe2e5;font-weight:600}.graph-svg-tip .svg-pointer{position:absolute;height:5px;margin:0 0 0 -5px;content:' ';border:5px solid transparent;border-top-color:rgba(0,0,0,.8)}.graph-svg-tip.comparison{padding:0;text-align:left;pointer-events:none}.graph-svg-tip.comparison .title{display:block;padding:10px;margin:0;font-weight:600;line-height:1;pointer-events:none}.graph-svg-tip.comparison ul{margin:0;white-space:nowrap;list-style:none}.graph-svg-tip.comparison li{display:inline-block;padding:5px 10px}",_createClass$2=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),BaseChart=function(){function t(e,n){if(_classCallCheck$3(this,t),this.parent="string"==typeof e?document.querySelector(e):e,!(this.parent instanceof HTMLElement)){ throw new Error("No `parent` element to render on was provided."); }this.rawChartArgs=n,this.title=n.title||"",this.type=n.type||"",this.realData=this.prepareData(n.data),this.data=this.prepareFirstData(this.realData),this.colors=this.validateColors(n.colors,this.type),this.config={showTooltip:1,showLegend:1,isNavigable:n.isNavigable||0,animate:void 0!==n.animate?n.animate:1,truncateLegends:n.truncateLegends||1},this.measures=JSON.parse(JSON.stringify(BASE_MEASURES));var i=this.measures;this.setMeasures(n),this.title.length||(i.titleHeight=0),this.config.showLegend||(i.legendHeight=0),this.argHeight=n.height||i.baseHeight,this.state={},this.options={},this.initTimeout=INIT_CHART_UPDATE_TIMEOUT,this.config.isNavigable&&(this.overlays=[]),this.configure(n);}return _createClass$2(t,[{key:"prepareData",value:function(t){return t}},{key:"prepareFirstData",value:function(t){return t}},{key:"validateColors",value:function(t,e){var n=[];return (t=(t||[]).concat(DEFAULT_COLORS[e])).forEach(function(t){var e=getColor(t);isValidColor(e)?n.push(e):console.warn('"'+t+'" is not a valid color.');}),n}},{key:"setMeasures",value:function(){}},{key:"configure",value:function(){var t=this,e=this.argHeight;this.baseHeight=e,this.height=e-getExtraHeight(this.measures),this.boundDrawFn=function(){return t.draw(!0)},window.addEventListener("resize",this.boundDrawFn),window.addEventListener("orientationchange",this.boundDrawFn);}},{key:"destroy",value:function(){window.removeEventListener("resize",this.boundDrawFn),window.removeEventListener("orientationchange",this.boundDrawFn);}},{key:"setup",value:function(){this.makeContainer(),this.updateWidth(),this.makeTooltip(),this.draw(!1,!0);}},{key:"makeContainer",value:function(){this.parent.innerHTML="";var t={inside:this.parent,className:"chart-container"};this.independentWidth&&(t.styles={width:this.independentWidth+"px"}),this.container=$$1.create("div",t);}},{key:"makeTooltip",value:function(){this.tip=new SvgTip({parent:this.container,colors:this.colors}),this.bindTooltip();}},{key:"bindTooltip",value:function(){}},{key:"draw",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];e&&isHidden(this.parent)||(this.updateWidth(),this.calc(e),this.makeChartArea(),this.setupComponents(),this.components.forEach(function(e){return e.setup(t.drawArea)}),this.render(this.components,!1),n&&(this.data=this.realData,setTimeout(function(){t.update(t.data);},this.initTimeout)),this.renderLegend(),this.setupNavigation(n));}},{key:"calc",value:function(){}},{key:"updateWidth",value:function(){this.baseWidth=getElementContentWidth(this.parent),this.width=this.baseWidth-getExtraWidth(this.measures);}},{key:"makeChartArea",value:function(){this.svg&&this.container.removeChild(this.svg);var t=this.measures;this.svg=makeSVGContainer(this.container,"frappe-chart chart",this.baseWidth,this.baseHeight),this.svgDefs=makeSVGDefs(this.svg),this.title.length&&(this.titleEL=makeText("title",t.margins.left,t.margins.top,this.title,{fontSize:t.titleFontSize,fill:"#666666",dy:t.titleFontSize}));var e=getTopOffset(t);this.drawArea=makeSVGGroup(this.type+"-chart chart-draw-area","translate("+getLeftOffset(t)+", "+e+")"),this.config.showLegend&&(e+=this.height+t.paddings.bottom,this.legendArea=makeSVGGroup("chart-legend","translate("+getLeftOffset(t)+", "+e+")")),this.title.length&&this.svg.appendChild(this.titleEL),this.svg.appendChild(this.drawArea),this.config.showLegend&&this.svg.appendChild(this.legendArea),this.updateTipOffset(getLeftOffset(t),getTopOffset(t));}},{key:"updateTipOffset",value:function(t,e){this.tip.offset={x:t,y:e};}},{key:"setupComponents",value:function(){this.components=new Map;}},{key:"update",value:function(t){t||console.error("No data to update."),this.data=this.prepareData(t),this.calc(),this.render(this.components,this.config.animate);}},{key:"render",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.components,n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this.config.isNavigable&&this.overlays.map(function(t){return t.parentNode.removeChild(t)});var i=[];e.forEach(function(t){i=i.concat(t.update(n));}),i.length>0?(runSMILAnimation(this.container,this.svg,i),setTimeout(function(){e.forEach(function(t){return t.make()}),t.updateNav();},CHART_POST_ANIMATE_TIMEOUT)):(e.forEach(function(t){return t.make()}),this.updateNav());}},{key:"updateNav",value:function(){this.config.isNavigable&&(this.makeOverlay(),this.bindUnits());}},{key:"renderLegend",value:function(){}},{key:"setupNavigation",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.config.isNavigable&&e&&(this.bindOverlay(),this.keyActions={13:this.onEnterKey.bind(this),37:this.onLeftArrow.bind(this),38:this.onUpArrow.bind(this),39:this.onRightArrow.bind(this),40:this.onDownArrow.bind(this)},document.addEventListener("keydown",function(e){isElementInViewport(t.container)&&(e=e||window.event,t.keyActions[e.keyCode]&&t.keyActions[e.keyCode]());}));}},{key:"makeOverlay",value:function(){}},{key:"updateOverlay",value:function(){}},{key:"bindOverlay",value:function(){}},{key:"bindUnits",value:function(){}},{key:"onLeftArrow",value:function(){}},{key:"onRightArrow",value:function(){}},{key:"onUpArrow",value:function(){}},{key:"onDownArrow",value:function(){}},{key:"onEnterKey",value:function(){}},{key:"addDataPoint",value:function(){}},{key:"removeDataPoint",value:function(){}},{key:"getDataPoint",value:function(){}},{key:"setCurrentDataPoint",value:function(){}},{key:"updateDataset",value:function(){}},{key:"export",value:function(){var t=prepareForExport(this.svg);downloadFile(this.title||"Chart",[t]);}}]),t}(),_createClass$1=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),_get$1=function t(e,n,i){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,n);if(void 0===a){var r=Object.getPrototypeOf(e);return null===r?void 0:t(r,n,i)}if("value"in a){ return a.value; }var s=a.get;if(void 0!==s){ return s.call(i) }},AggregationChart=function(t){function e(t,n){return _classCallCheck$2(this,e),_possibleConstructorReturn$1(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n))}return _inherits$1(e,t),_createClass$1(e,[{key:"configure",value:function(t){_get$1(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"configure",this).call(this,t),this.config.maxSlices=t.maxSlices||20,this.config.maxLegendPoints=t.maxLegendPoints||20;}},{key:"calc",value:function(){var t=this,e=this.state,n=this.config.maxSlices;e.sliceTotals=[];var i=this.data.labels.map(function(e,n){var i=0;return t.data.datasets.map(function(t){i+=t.values[n];}),[i,e]}).filter(function(t){return t[0]>=0}),a=i;if(i.length>n){i.sort(function(t,e){return e[0]-t[0]}),a=i.slice(0,n-1);var r=0;i.slice(n-1).map(function(t){r+=t[0];}),a.push([r,"Rest"]),this.colors[n-1]="grey";}e.labels=[],a.map(function(t){e.sliceTotals.push(t[0]),e.labels.push(t[1]);}),e.grandTotal=e.sliceTotals.reduce(function(t,e){return t+e},0),this.center={x:this.width/2,y:this.height/2};}},{key:"renderLegend",value:function(){var t=this,e=this.state;this.legendArea.textContent="",this.legendTotals=e.sliceTotals.slice(0,this.config.maxLegendPoints);var n=0,i=0;this.legendTotals.map(function(a,r){var s=150,o=Math.floor((t.width-getExtraWidth(t.measures))/s);t.legendTotals.length<o&&(s=t.width/t.legendTotals.length),n>o&&(n=0,i+=20);var l=s*n+5,u=t.config.truncateLegends?truncateString(e.labels[r],s/10):e.labels[r],c=legendDot(l,i,5,t.colors[r],u+": "+a,!1);t.legendArea.appendChild(c),n++;});}}]),e}(BaseChart),NO_OF_YEAR_MONTHS=12,NO_OF_DAYS_IN_WEEK=7,NO_OF_MILLIS=1e3,SEC_IN_DAY=86400,MONTH_NAMES=["January","February","March","April","May","June","July","August","September","October","November","December"],DAY_NAMES_SHORT=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],_slicedToArray$3=function(){function t(t,e){var n=[],i=!0,a=!1,r=void 0;try{for(var s,o=t[Symbol.iterator]();!(i=(s=o.next()).done)&&(n.push(s.value),!e||n.length!==e);i=!0){ }}catch(t){a=!0,r=t;}finally{try{!i&&o.return&&o.return();}finally{if(a){ throw r }}}return n}return function(e,n){if(Array.isArray(e)){ return e; }if(Symbol.iterator in Object(e)){ return t(e,n); }throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass$4=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),ChartComponent=function(){function t(e){var n=e.layerClass,i=void 0===n?"":n,a=e.layerTransform,r=void 0===a?"":a,s=e.constants,o=e.getData,l=e.makeElements,u=e.animateElements;_classCallCheck$5(this,t),this.layerTransform=r,this.constants=s,this.makeElements=l,this.getData=o,this.animateElements=u,this.store=[],this.labels=[],this.layerClass=i,this.layerClass="function"==typeof this.layerClass?this.layerClass():this.layerClass,this.refresh();}return _createClass$4(t,[{key:"refresh",value:function(t){this.data=t||this.getData();}},{key:"setup",value:function(t){this.layer=makeSVGGroup(this.layerClass,this.layerTransform,t);}},{key:"make",value:function(){this.render(this.data),this.oldData=this.data;}},{key:"render",value:function(t){var e=this;this.store=this.makeElements(t),this.layer.textContent="",this.store.forEach(function(t){e.layer.appendChild(t);}),this.labels.forEach(function(t){e.layer.appendChild(t);});}},{key:"update",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.refresh();var e=[];return t&&(e=this.animateElements(this.data)||[]),e}}]),t}(),componentConfigs={donutSlices:{layerClass:"donut-slices",makeElements:function(t){return t.sliceStrings.map(function(e,n){var i=makePath(e,"donut-path",t.colors[n],"none",t.strokeWidth);return i.style.transition="transform .3s;",i})},animateElements:function(t){return this.store.map(function(e,n){return animatePathStr(e,t.sliceStrings[n])})}},pieSlices:{layerClass:"pie-slices",makeElements:function(t){return t.sliceStrings.map(function(e,n){var i=makePath(e,"pie-path","none",t.colors[n]);return i.style.transition="transform .3s;",i})},animateElements:function(t){return this.store.map(function(e,n){return animatePathStr(e,t.sliceStrings[n])})}},percentageBars:{layerClass:"percentage-bars",makeElements:function(t){var e=this;return t.xPositions.map(function(n,i){return percentageBar(n,0,t.widths[i],e.constants.barHeight,e.constants.barDepth,t.colors[i])})},animateElements:function(t){if(t){ return [] }}},yAxis:{layerClass:"y axis",makeElements:function(t){var e=this;return t.positions.map(function(n,i){return yLine(n,t.labels[i],e.constants.width,{mode:e.constants.mode,pos:e.constants.pos,shortenNumbers:e.constants.shortenNumbers})})},animateElements:function(t){var e=t.positions,n=t.labels,i=this.oldData.positions,a=this.oldData.labels,r=equilizeNoOfElements(i,e),s=_slicedToArray$3(r,2);i=s[0],e=s[1];var o=equilizeNoOfElements(a,n),l=_slicedToArray$3(o,2);return a=l[0],n=l[1],this.render({positions:i,labels:n}),this.store.map(function(t,n){return translateHoriLine(t,e[n],i[n])})}},xAxis:{layerClass:"x axis",makeElements:function(t){var e=this;return t.positions.map(function(n,i){return xLine(n,t.calcLabels[i],e.constants.height,{mode:e.constants.mode,pos:e.constants.pos})})},animateElements:function(t){var e=t.positions,n=t.calcLabels,i=this.oldData.positions,a=this.oldData.calcLabels,r=equilizeNoOfElements(i,e),s=_slicedToArray$3(r,2);i=s[0],e=s[1];var o=equilizeNoOfElements(a,n),l=_slicedToArray$3(o,2);return a=l[0],n=l[1],this.render({positions:i,calcLabels:n}),this.store.map(function(t,n){return translateVertLine(t,e[n],i[n])})}},yMarkers:{layerClass:"y-markers",makeElements:function(t){var e=this;return t.map(function(t){return yMarker(t.position,t.label,e.constants.width,{labelPos:t.options.labelPos,mode:"span",lineType:"dashed"})})},animateElements:function(t){var e=equilizeNoOfElements(this.oldData,t),n=_slicedToArray$3(e,2);this.oldData=n[0];var i=(t=n[1]).map(function(t){return t.position}),a=t.map(function(t){return t.label}),r=t.map(function(t){return t.options}),s=this.oldData.map(function(t){return t.position});return this.render(s.map(function(t,e){return {position:s[e],label:a[e],options:r[e]}})),this.store.map(function(t,e){return translateHoriLine(t,i[e],s[e])})}},yRegions:{layerClass:"y-regions",makeElements:function(t){var e=this;return t.map(function(t){return yRegion(t.startPos,t.endPos,e.constants.width,t.label,{labelPos:t.options.labelPos})})},animateElements:function(t){var e=equilizeNoOfElements(this.oldData,t),n=_slicedToArray$3(e,2);this.oldData=n[0];var i=(t=n[1]).map(function(t){return t.endPos}),a=t.map(function(t){return t.label}),r=t.map(function(t){return t.startPos}),s=t.map(function(t){return t.options}),o=this.oldData.map(function(t){return t.endPos}),l=this.oldData.map(function(t){return t.startPos});this.render(o.map(function(t,e){return {startPos:l[e],endPos:o[e],label:a[e],options:s[e]}}));var u=[];return this.store.map(function(t,e){u=u.concat(animateRegion(t,r[e],i[e],o[e]));}),u}},heatDomain:{layerClass:function(){return "heat-domain domain-"+this.constants.index},makeElements:function(t){var e=this,n=this.constants,i=n.index,a=n.colWidth,r=n.rowHeight,s=n.squareSize,o=n.radius,l=n.xTranslate,u=0;return this.serializedSubDomains=[],t.cols.map(function(t,n){1===n&&e.labels.push(makeText("domain-name",l,-12,getMonthName(i,!0).toUpperCase(),{fontSize:9})),t.map(function(t,n){if(t.fill){var i={"data-date":t.yyyyMmDd,"data-value":t.dataValue,"data-day":n},a=heatSquare("day",l,u,s,o,t.fill,i);e.serializedSubDomains.push(a);}u+=r;}),u=0,l+=a;}),this.serializedSubDomains},animateElements:function(t){if(t){ return [] }}},barGraph:{layerClass:function(){return "dataset-units dataset-bars dataset-"+this.constants.index},makeElements:function(t){var e=this.constants;return this.unitType="bar",this.units=t.yPositions.map(function(n,i){return datasetBar(t.xPositions[i],n,t.barWidth,e.color,t.labels[i],i,t.offsets[i],{zeroLine:t.zeroLine,barsWidth:t.barsWidth,minHeight:e.minHeight})}),this.units},animateElements:function(t){var e=t.xPositions,n=t.yPositions,i=t.offsets,a=t.labels,r=this.oldData.xPositions,s=this.oldData.yPositions,o=this.oldData.offsets,l=this.oldData.labels,u=equilizeNoOfElements(r,e),c=_slicedToArray$3(u,2);r=c[0],e=c[1];var h=equilizeNoOfElements(s,n),d=_slicedToArray$3(h,2);s=d[0],n=d[1];var f=equilizeNoOfElements(o,i),p=_slicedToArray$3(f,2);o=p[0],i=p[1];var v=equilizeNoOfElements(l,a),g=_slicedToArray$3(v,2);l=g[0],a=g[1],this.render({xPositions:r,yPositions:s,offsets:o,labels:a,zeroLine:this.oldData.zeroLine,barsWidth:this.oldData.barsWidth,barWidth:this.oldData.barWidth});var y=[];return this.store.map(function(a,r){y=y.concat(animateBar(a,e[r],n[r],t.barWidth,i[r],{zeroLine:t.zeroLine}));}),y}},lineGraph:{layerClass:function(){return "dataset-units dataset-line dataset-"+this.constants.index},makeElements:function(t){var e=this.constants;return this.unitType="dot",this.paths={},e.hideLine||(this.paths=getPaths(t.xPositions,t.yPositions,e.color,{heatline:e.heatline,regionFill:e.regionFill,spline:e.spline},{svgDefs:e.svgDefs,zeroLine:t.zeroLine})),this.units=[],e.hideDots||(this.units=t.yPositions.map(function(n,i){return datasetDot(t.xPositions[i],n,t.radius,e.color,e.valuesOverPoints?t.values[i]:"",i)})),Object.values(this.paths).concat(this.units)},animateElements:function(t){var e=t.xPositions,n=t.yPositions,i=t.values,a=this.oldData.xPositions,r=this.oldData.yPositions,s=this.oldData.values,o=equilizeNoOfElements(a,e),l=_slicedToArray$3(o,2);a=l[0],e=l[1];var u=equilizeNoOfElements(r,n),c=_slicedToArray$3(u,2);r=c[0],n=c[1];var h=equilizeNoOfElements(s,i),d=_slicedToArray$3(h,2);s=d[0],i=d[1],this.render({xPositions:a,yPositions:r,values:i,zeroLine:this.oldData.zeroLine,radius:this.oldData.radius});var f=[];return Object.keys(this.paths).length&&(f=f.concat(animatePath(this.paths,e,n,t.zeroLine,this.constants.spline))),this.units.length&&this.units.map(function(t,i){f=f.concat(animateDot(t,e[i],n[i]));}),f}}},_createClass=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),_get=function t(e,n,i){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,n);if(void 0===a){var r=Object.getPrototypeOf(e);return null===r?void 0:t(r,n,i)}if("value"in a){ return a.value; }var s=a.get;if(void 0!==s){ return s.call(i) }},PercentageChart=function(t){function e(t,n){_classCallCheck$1(this,e);var i=_possibleConstructorReturn(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return i.type="percentage",i.setup(),i}return _inherits(e,t),_createClass(e,[{key:"setMeasures",value:function(t){var e=this.measures;this.barOptions=t.barOptions||{};var n=this.barOptions;n.height=n.height||PERCENTAGE_BAR_DEFAULT_HEIGHT,n.depth=n.depth||PERCENTAGE_BAR_DEFAULT_DEPTH,e.paddings.right=30,e.legendHeight=60,e.baseHeight=8*(n.height+.5*n.depth);}},{key:"setupComponents",value:function(){var t=this.state,e=[["percentageBars",{barHeight:this.barOptions.height,barDepth:this.barOptions.depth},function(){return {xPositions:t.xPositions,widths:t.widths,colors:this.colors}}.bind(this)]];this.components=new Map(e.map(function(t){var e=getComponent.apply(void 0,_toConsumableArray(t));return [t[0],e]}));}},{key:"calc",value:function(){var t=this;_get(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"calc",this).call(this);var n=this.state;n.xPositions=[],n.widths=[];var i=0;n.sliceTotals.map(function(e){var a=t.width*e/n.grandTotal;n.widths.push(a),n.xPositions.push(i),i+=a;});}},{key:"makeDataByIndex",value:function(){}},{key:"bindTooltip",value:function(){var t=this,e=this.state;this.container.addEventListener("mousemove",function(n){var i=t.components.get("percentageBars").store,a=n.target;if(i.includes(a)){var r=i.indexOf(a),s=getOffset(t.container),o=getOffset(a),l=o.left-s.left+parseInt(a.getAttribute("width"))/2,u=o.top-s.top,c=(t.formattedLabels&&t.formattedLabels.length>0?t.formattedLabels[r]:t.state.labels[r])+": ",h=e.sliceTotals[r]/e.grandTotal;t.tip.setValues(l,u,{name:c,value:(100*h).toFixed(1)+"%"}),t.tip.showTip();}});}}]),e}(AggregationChart),_createClass$5=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),_get$2=function t(e,n,i){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,n);if(void 0===a){var r=Object.getPrototypeOf(e);return null===r?void 0:t(r,n,i)}if("value"in a){ return a.value; }var s=a.get;if(void 0!==s){ return s.call(i) }},PieChart=function(t){function e(t,n){_classCallCheck$6(this,e);var i=_possibleConstructorReturn$2(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return i.type="pie",i.initTimeout=0,i.init=1,i.setup(),i}return _inherits$2(e,t),_createClass$5(e,[{key:"configure",value:function(t){_get$2(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"configure",this).call(this,t),this.mouseMove=this.mouseMove.bind(this),this.mouseLeave=this.mouseLeave.bind(this),this.hoverRadio=t.hoverRadio||.1,this.config.startAngle=t.startAngle||0,this.clockWise=t.clockWise||!1;}},{key:"calc",value:function(){var t=this;_get$2(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"calc",this).call(this);var n=this.state;this.radius=this.height>this.width?this.center.x:this.center.y;var i=this.radius,a=this.clockWise,r=n.slicesProperties||[];n.sliceStrings=[],n.slicesProperties=[];var s=180-this.config.startAngle;n.sliceTotals.map(function(e,o){var l=s,u=e/n.grandTotal*FULL_ANGLE,c=u>180?1:0,h=a?-u:u,d=s+=h,f=getPositionByAngle(l,i),p=getPositionByAngle(d,i),v=t.init&&r[o],g=void 0,y=void 0;t.init?(g=v?v.startPosition:f,y=v?v.endPosition:f):(g=f,y=p);var m=360===u?makeCircleStr(g,y,t.center,t.radius,a,c):makeArcPathStr(g,y,t.center,t.radius,a,c);n.sliceStrings.push(m),n.slicesProperties.push({startPosition:f,endPosition:p,value:e,total:n.grandTotal,startAngle:l,endAngle:d,angle:h});}),this.init=0;}},{key:"setupComponents",value:function(){var t=this.state,e=[["pieSlices",{},function(){return {sliceStrings:t.sliceStrings,colors:this.colors}}.bind(this)]];this.components=new Map(e.map(function(t){var e=getComponent.apply(void 0,_toConsumableArray$2(t));return [t[0],e]}));}},{key:"calTranslateByAngle",value:function(t){var e=this.radius,n=this.hoverRadio,i=getPositionByAngle(t.startAngle+t.angle/2,e);return "translate3d("+i.x*n+"px,"+i.y*n+"px,0)"}},{key:"hoverSlice",value:function(t,e,n,i){if(t){var a=this.colors[e];if(n){transform(t,this.calTranslateByAngle(this.state.slicesProperties[e])),t.style.fill=lightenDarkenColor(a,50);var r=getOffset(this.svg),s=i.pageX-r.left+10,o=i.pageY-r.top-10,l=(this.formatted_labels&&this.formatted_labels.length>0?this.formatted_labels[e]:this.state.labels[e])+": ",u=(100*this.state.sliceTotals[e]/this.state.grandTotal).toFixed(1);this.tip.setValues(s,o,{name:l,value:u+"%"}),this.tip.showTip();}else { transform(t,"translate3d(0,0,0)"),this.tip.hideTip(),t.style.fill=a; }}}},{key:"bindTooltip",value:function(){this.container.addEventListener("mousemove",this.mouseMove),this.container.addEventListener("mouseleave",this.mouseLeave);}},{key:"mouseMove",value:function(t){var e=t.target,n=this.components.get("pieSlices").store,i=this.curActiveSliceIndex,a=this.curActiveSlice;if(n.includes(e)){var r=n.indexOf(e);this.hoverSlice(a,i,!1),this.curActiveSlice=e,this.curActiveSliceIndex=r,this.hoverSlice(e,r,!0,t);}else { this.mouseLeave(); }}},{key:"mouseLeave",value:function(){this.hoverSlice(this.curActiveSlice,this.curActiveSliceIndex,!1);}}]),e}(AggregationChart),_slicedToArray$4=function(){function t(t,e){var n=[],i=!0,a=!1,r=void 0;try{for(var s,o=t[Symbol.iterator]();!(i=(s=o.next()).done)&&(n.push(s.value),!e||n.length!==e);i=!0){ }}catch(t){a=!0,r=t;}finally{try{!i&&o.return&&o.return();}finally{if(a){ throw r }}}return n}return function(e,n){if(Array.isArray(e)){ return e; }if(Symbol.iterator in Object(e)){ return t(e,n); }throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass$6=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),COL_WIDTH=HEATMAP_SQUARE_SIZE+HEATMAP_GUTTER_SIZE,ROW_HEIGHT=COL_WIDTH,Heatmap=function(t){function e(t,n){_classCallCheck$7(this,e);var i=_possibleConstructorReturn$3(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));i.type="heatmap",i.countLabel=n.countLabel||"";var a=["Sunday","Monday"],r=a.includes(n.startSubDomain)?n.startSubDomain:"Sunday";return i.startSubDomainIndex=a.indexOf(r),i.setup(),i}return _inherits$3(e,t),_createClass$6(e,[{key:"setMeasures",value:function(t){var e=this.measures;this.discreteDomains=0===t.discreteDomains?0:1,e.paddings.top=3*ROW_HEIGHT,e.paddings.bottom=0,e.legendHeight=2*ROW_HEIGHT,e.baseHeight=ROW_HEIGHT*NO_OF_DAYS_IN_WEEK+getExtraHeight(e);var n=this.data,i=this.discreteDomains?NO_OF_YEAR_MONTHS:0;this.independentWidth=(getWeeksBetween(n.start,n.end)+i)*COL_WIDTH+getExtraWidth(e);}},{key:"updateWidth",value:function(){var t=this.discreteDomains?NO_OF_YEAR_MONTHS:0,e=this.state.noOfWeeks?this.state.noOfWeeks:52;this.baseWidth=(e+t)*COL_WIDTH+getExtraWidth(this.measures);}},{key:"prepareData",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.data;if(t.start&&t.end&&t.start>t.end){ throw new Error("Start date cannot be greater than end date."); }if(t.start||(t.start=new Date,t.start.setFullYear(t.start.getFullYear()-1)),t.end||(t.end=new Date),t.dataPoints=t.dataPoints||{},parseInt(Object.keys(t.dataPoints)[0])>1e5){var e={};Object.keys(t.dataPoints).forEach(function(n){var i=new Date(n*NO_OF_MILLIS);e[getYyyyMmDd(i)]=t.dataPoints[n];}),t.dataPoints=e;}return t}},{key:"calc",value:function(){var t=this.state;t.start=clone(this.data.start),t.end=clone(this.data.end),t.firstWeekStart=clone(t.start),t.noOfWeeks=getWeeksBetween(t.start,t.end),t.distribution=calcDistribution(Object.values(this.data.dataPoints),HEATMAP_DISTRIBUTION_SIZE),t.domainConfigs=this.getDomains();}},{key:"setupComponents",value:function(){var t=this,e=this.state,n=this.discreteDomains?0:1,i=e.domainConfigs.map(function(i,a){return ["heatDomain",{index:i.index,colWidth:COL_WIDTH,rowHeight:ROW_HEIGHT,squareSize:HEATMAP_SQUARE_SIZE,radius:t.rawChartArgs.radius||0,xTranslate:e.domainConfigs.filter(function(t,e){return e<a}).map(function(t){return t.cols.length-n}).reduce(function(t,e){return t+e},0)*COL_WIDTH},function(){return e.domainConfigs[a]}.bind(t)]});this.components=new Map(i.map(function(t,e){var n=getComponent.apply(void 0,_toConsumableArray$3(t));return [t[0]+"-"+e,n]}));var a=0;DAY_NAMES_SHORT.forEach(function(e,n){if([1,3,5].includes(n)){var i=makeText("subdomain-name",-COL_WIDTH/2,a,e,{fontSize:HEATMAP_SQUARE_SIZE,dy:8,textAnchor:"end"});t.drawArea.appendChild(i);}a+=ROW_HEIGHT;});}},{key:"update",value:function(t){t||console.error("No data to update."),this.data=this.prepareData(t),this.draw(),this.bindTooltip();}},{key:"bindTooltip",value:function(){var t=this;this.container.addEventListener("mousemove",function(e){t.components.forEach(function(n){var i=n.store,a=e.target;if(i.includes(a)){var r=a.getAttribute("data-value"),s=a.getAttribute("data-date").split("-"),o=getMonthName(parseInt(s[1])-1,!0),l=t.container.getBoundingClientRect(),u=a.getBoundingClientRect(),c=parseInt(e.target.getAttribute("width")),h=u.left-l.left+c/2,d=u.top-l.top,f=r+" "+t.countLabel,p=" on "+o+" "+s[0]+", "+s[2];t.tip.setValues(h,d,{name:p,value:f,valueFirst:1},[]),t.tip.showTip();}});});}},{key:"renderLegend",value:function(){var t=this;this.legendArea.textContent="";var e=0,n=ROW_HEIGHT,i=this.rawChartArgs.radius||0,a=makeText("subdomain-name",e,n,"Less",{fontSize:HEATMAP_SQUARE_SIZE+1,dy:9});e=2*COL_WIDTH+COL_WIDTH/2,this.legendArea.appendChild(a),this.colors.slice(0,HEATMAP_DISTRIBUTION_SIZE).map(function(a,r){var s=heatSquare("heatmap-legend-unit",e+(COL_WIDTH+3)*r,n,HEATMAP_SQUARE_SIZE,i,a);t.legendArea.appendChild(s);});var r=makeText("subdomain-name",e+HEATMAP_DISTRIBUTION_SIZE*(COL_WIDTH+3)+COL_WIDTH/4,n,"More",{fontSize:HEATMAP_SQUARE_SIZE+1,dy:9});this.legendArea.appendChild(r);}},{key:"getDomains",value:function(){for(var t=this.state,e=[t.start.getMonth(),t.start.getFullYear()],n=e[0],i=e[1],a=[t.end.getMonth(),t.end.getFullYear()],r=a[0]-n+1+12*(a[1]-i),s=[],o=clone(t.start),l=0;l<r;l++){var u=t.end;if(!areInSameMonth(o,t.end)){var c=[o.getMonth(),o.getFullYear()];u=getLastDateInMonth(c[0],c[1]);}s.push(this.getDomainConfig(o,u)),addDays(u,1),o=u;}return s}},{key:"getDomainConfig",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=[t.getMonth(),t.getFullYear()],i=n[0],a=n[1],r=setDayToSunday(t),s={index:i,cols:[]};addDays(e=clone(e)||getLastDateInMonth(i,a),1);for(var o=getWeeksBetween(r,e),l=[],u=void 0,c=0;c<o;c++){ u=this.getCol(r,i),l.push(u),addDays(r=new Date(u[NO_OF_DAYS_IN_WEEK-1].yyyyMmDd),1); }return void 0!==u[NO_OF_DAYS_IN_WEEK-1].dataValue&&(addDays(r,1),l.push(this.getCol(r,i,!0))),s.cols=l,s}},{key:"getCol",value:function(t,e){for(var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=this.state,a=clone(t),r=[],s=0;s<NO_OF_DAYS_IN_WEEK;s++,addDays(a,1)){var o={},l=a>=i.start&&a<=i.end;n||a.getMonth()!==e||!l?o.yyyyMmDd=getYyyyMmDd(a):o=this.getSubDomainConfig(a),r.push(o);}return r}},{key:"getSubDomainConfig",value:function(t){var e=getYyyyMmDd(t),n=this.data.dataPoints[e];return {yyyyMmDd:e,dataValue:n||0,fill:this.colors[getMaxCheckpoint(n,this.state.distribution)]}}}]),e}(BaseChart),_createClass$7=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),_get$3=function t(e,n,i){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,n);if(void 0===a){var r=Object.getPrototypeOf(e);return null===r?void 0:t(r,n,i)}if("value"in a){ return a.value; }var s=a.get;if(void 0!==s){ return s.call(i) }},AxisChart=function(t){function e(t,n){_classCallCheck$8(this,e);var i=_possibleConstructorReturn$4(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return i.barOptions=n.barOptions||{},i.lineOptions=n.lineOptions||{},i.type=n.type||"line",i.init=1,i.setup(),i}return _inherits$4(e,t),_createClass$7(e,[{key:"setMeasures",value:function(){this.data.datasets.length<=1&&(this.config.showLegend=0,this.measures.paddings.bottom=30);}},{key:"configure",value:function(t){_get$3(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"configure",this).call(this,t),t.axisOptions=t.axisOptions||{},t.tooltipOptions=t.tooltipOptions||{},this.config.xAxisMode=t.axisOptions.xAxisMode||"span",this.config.yAxisMode=t.axisOptions.yAxisMode||"span",this.config.xIsSeries=t.axisOptions.xIsSeries||0,this.config.shortenYAxisNumbers=t.axisOptions.shortenYAxisNumbers||0,this.config.formatTooltipX=t.tooltipOptions.formatTooltipX,this.config.formatTooltipY=t.tooltipOptions.formatTooltipY,this.config.valuesOverPoints=t.valuesOverPoints;}},{key:"prepareData",value:function(){return dataPrep(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.data,this.type)}},{key:"prepareFirstData",value:function(){return zeroDataPrep(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.data)}},{key:"calc",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.calcXPositions(),t||this.calcYAxisParameters(this.getAllYValues(),"line"===this.type),this.makeDataByIndex();}},{key:"calcXPositions",value:function(){var t=this.state,e=this.data.labels;t.datasetLength=e.length,t.unitWidth=this.width/t.datasetLength,t.xOffset=t.unitWidth/2,t.xAxis={labels:e,positions:e.map(function(e,n){return floatTwo(t.xOffset+n*t.unitWidth)})};}},{key:"calcYAxisParameters",value:function(t){var e=calcChartIntervals(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:"false"),n=this.height/getValueRange(e),i=getIntervalSize(e)*n,a=this.height-getZeroIndex(e)*i;this.state.yAxis={labels:e,positions:e.map(function(t){return a-t*n}),scaleMultiplier:n,zeroLine:a},this.calcDatasetPoints(),this.calcYExtremes(),this.calcYRegions();}},{key:"calcDatasetPoints",value:function(){var t=this.state,e=function(e){return e.map(function(e){return scale(e,t.yAxis)})};t.datasets=this.data.datasets.map(function(t,n){var i=t.values,a=t.cumulativeYs||[];return {name:t.name,index:n,chartType:t.chartType,values:i,yPositions:e(i),cumulativeYs:a,cumulativeYPos:e(a)}});}},{key:"calcYExtremes",value:function(){var t=this.state;if(this.barOptions.stacked){ return void(t.yExtremes=t.datasets[t.datasets.length-1].cumulativeYPos); }t.yExtremes=new Array(t.datasetLength).fill(9999),t.datasets.map(function(e){e.yPositions.map(function(e,n){e<t.yExtremes[n]&&(t.yExtremes[n]=e);});});}},{key:"calcYRegions",value:function(){var t=this.state;this.data.yMarkers&&(this.state.yMarkers=this.data.yMarkers.map(function(e){return e.position=scale(e.value,t.yAxis),e.options||(e.options={}),e})),this.data.yRegions&&(this.state.yRegions=this.data.yRegions.map(function(e){return e.startPos=scale(e.start,t.yAxis),e.endPos=scale(e.end,t.yAxis),e.options||(e.options={}),e}));}},{key:"getAllYValues",value:function(){var t,e=this,n="values";if(this.barOptions.stacked){n="cumulativeYs";var i=new Array(this.state.datasetLength).fill(0);this.data.datasets.map(function(t,a){var r=e.data.datasets[a].values;t[n]=i=i.map(function(t,e){return t+r[e]});});}var a=this.data.datasets.map(function(t){return t[n]});return this.data.yMarkers&&a.push(this.data.yMarkers.map(function(t){return t.value})),this.data.yRegions&&this.data.yRegions.map(function(t){a.push([t.end,t.start]);}),(t=[]).concat.apply(t,_toConsumableArray$5(a))}},{key:"setupComponents",value:function(){var t=this,e=[["yAxis",{mode:this.config.yAxisMode,width:this.width,shortenNumbers:this.config.shortenYAxisNumbers},function(){return this.state.yAxis}.bind(this)],["xAxis",{mode:this.config.xAxisMode,height:this.height},function(){var t=this.state;return t.xAxis.calcLabels=getShortenedLabels(this.width,t.xAxis.labels,this.config.xIsSeries),t.xAxis}.bind(this)],["yRegions",{width:this.width,pos:"right"},function(){return this.state.yRegions}.bind(this)]],n=this.state.datasets.filter(function(t){return "bar"===t.chartType}),i=this.state.datasets.filter(function(t){return "line"===t.chartType}),a=n.map(function(e){var i=e.index;return ["barGraph-"+e.index,{index:i,color:t.colors[i],stacked:t.barOptions.stacked,valuesOverPoints:t.config.valuesOverPoints,minHeight:t.height*MIN_BAR_PERCENT_HEIGHT},function(){var t=this.state,e=t.datasets[i],a=this.barOptions.stacked,r=this.barOptions.spaceRatio||BAR_CHART_SPACE_RATIO,s=t.unitWidth*(1-r),o=s/(a?1:n.length),l=t.xAxis.positions.map(function(t){return t-s/2});a||(l=l.map(function(t){return t+o*i}));var u=new Array(t.datasetLength).fill("");this.config.valuesOverPoints&&(u=a&&e.index===t.datasets.length-1?e.cumulativeYs:e.values);var c=new Array(t.datasetLength).fill(0);return a&&(c=e.yPositions.map(function(t,n){return t-e.cumulativeYPos[n]})),{xPositions:l,yPositions:e.yPositions,offsets:c,labels:u,zeroLine:t.yAxis.zeroLine,barsWidth:s,barWidth:o}}.bind(t)]}),r=i.map(function(e){var n=e.index;return ["lineGraph-"+e.index,{index:n,color:t.colors[n],svgDefs:t.svgDefs,heatline:t.lineOptions.heatline,regionFill:t.lineOptions.regionFill,spline:t.lineOptions.spline,hideDots:t.lineOptions.hideDots,hideLine:t.lineOptions.hideLine,valuesOverPoints:t.config.valuesOverPoints},function(){var t=this.state,e=t.datasets[n],i=t.yAxis.positions[0]<t.yAxis.zeroLine?t.yAxis.positions[0]:t.yAxis.zeroLine;return {xPositions:t.xAxis.positions,yPositions:e.yPositions,values:e.values,zeroLine:i,radius:this.lineOptions.dotSize||LINE_CHART_DOT_SIZE}}.bind(t)]}),s=[["yMarkers",{width:this.width,pos:"right"},function(){return this.state.yMarkers}.bind(this)]];e=e.concat(a,r,s);var o=["yMarkers","yRegions"];this.dataUnitComponents=[],this.components=new Map(e.filter(function(e){return !o.includes(e[0])||t.state[e[0]]}).map(function(e){var n=getComponent.apply(void 0,_toConsumableArray$5(e));return (e[0].includes("lineGraph")||e[0].includes("barGraph"))&&t.dataUnitComponents.push(n),[e[0],n]}));}},{key:"makeDataByIndex",value:function(){var t=this;this.dataByIndex={};var e=this.state,n=this.config.formatTooltipX,i=this.config.formatTooltipY;e.xAxis.labels.map(function(a,r){var s=t.state.datasets.map(function(e,n){var a=e.values[r];return {title:e.name,value:a,yPos:e.yPositions[r],color:t.colors[n],formatted:i?i(a):a}});t.dataByIndex[r]={label:a,formattedLabel:n?n(a):a,xPos:e.xAxis.positions[r],values:s,yExtreme:e.yExtremes[r]};});}},{key:"bindTooltip",value:function(){var t=this;this.container.addEventListener("mousemove",function(e){var n=t.measures,i=getOffset(t.container),a=e.pageX-i.left-getLeftOffset(n),r=e.pageY-i.top;r<t.height+getTopOffset(n)&&r>getTopOffset(n)?t.mapTooltipXPosition(a):t.tip.hideTip();});}},{key:"mapTooltipXPosition",value:function(t){var e=this.state;if(e.yExtremes){var n=getClosestInArray(t,e.xAxis.positions,!0);if(n>=0){var i=this.dataByIndex[n];this.tip.setValues(i.xPos+this.tip.offset.x,i.yExtreme+this.tip.offset.y,{name:i.formattedLabel,value:""},i.values,n),this.tip.showTip();}}}},{key:"renderLegend",value:function(){var t=this,e=this.data;e.datasets.length>1&&(this.legendArea.textContent="",e.datasets.map(function(e,n){var i=AXIS_LEGEND_BAR_SIZE,a=legendBar(i*n,"0",i,t.colors[n],e.name,t.config.truncateLegends);t.legendArea.appendChild(a);}));}},{key:"makeOverlay",value:function(){var t=this;if(this.init){ return void(this.init=0); }this.overlayGuides&&this.overlayGuides.forEach(function(t){var e=t.overlay;e.parentNode.removeChild(e);}),this.overlayGuides=this.dataUnitComponents.map(function(t){return {type:t.unitType,overlay:void 0,units:t.units}}),void 0===this.state.currentIndex&&(this.state.currentIndex=this.state.datasetLength-1),this.overlayGuides.map(function(e){var n=e.units[t.state.currentIndex];e.overlay=makeOverlay[e.type](n),t.drawArea.appendChild(e.overlay);});}},{key:"updateOverlayGuides",value:function(){this.overlayGuides&&this.overlayGuides.forEach(function(t){var e=t.overlay;e.parentNode.removeChild(e);});}},{key:"bindOverlay",value:function(){var t=this;this.parent.addEventListener("data-select",function(){t.updateOverlay();});}},{key:"bindUnits",value:function(){var t=this;this.dataUnitComponents.map(function(e){e.units.map(function(e){e.addEventListener("click",function(){var n=e.getAttribute("data-point-index");t.setCurrentDataPoint(n);});});}),this.tip.container.addEventListener("click",function(){var e=t.tip.container.getAttribute("data-point-index");t.setCurrentDataPoint(e);});}},{key:"updateOverlay",value:function(){var t=this;this.overlayGuides.map(function(e){var n=e.units[t.state.currentIndex];updateOverlay[e.type](n,e.overlay);});}},{key:"onLeftArrow",value:function(){this.setCurrentDataPoint(this.state.currentIndex-1);}},{key:"onRightArrow",value:function(){this.setCurrentDataPoint(this.state.currentIndex+1);}},{key:"getDataPoint",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.state.currentIndex,e=this.state;return {index:t,label:e.xAxis.labels[t],values:e.datasets.map(function(e){return e.values[t]})}}},{key:"setCurrentDataPoint",value:function(t){var e=this.state;(t=parseInt(t))<0&&(t=0),t>=e.xAxis.labels.length&&(t=e.xAxis.labels.length-1),t!==e.currentIndex&&(e.currentIndex=t,fire(this.parent,"data-select",this.getDataPoint()));}},{key:"addDataPoint",value:function(t,n){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.state.datasetLength;_get$3(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"addDataPoint",this).call(this,t,n,i),this.data.labels.splice(i,0,t),this.data.datasets.map(function(t,e){t.values.splice(i,0,n[e]);}),this.update(this.data);}},{key:"removeDataPoint",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.state.datasetLength-1;this.data.labels.length<=1||(_get$3(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"removeDataPoint",this).call(this,t),this.data.labels.splice(t,1),this.data.datasets.map(function(e){e.values.splice(t,1);}),this.update(this.data));}},{key:"updateDataset",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.data.datasets[e].values=t,this.update(this.data);}},{key:"updateDatasets",value:function(t){this.data.datasets.map(function(e,n){t[n]&&(e.values=t[n]);}),this.update(this.data);}}]),e}(BaseChart),_createClass$8=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),_get$4=function t(e,n,i){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,n);if(void 0===a){var r=Object.getPrototypeOf(e);return null===r?void 0:t(r,n,i)}if("value"in a){ return a.value; }var s=a.get;if(void 0!==s){ return s.call(i) }},DonutChart=function(t){function e(t,n){_classCallCheck$9(this,e);var i=_possibleConstructorReturn$5(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return i.type="donut",i.initTimeout=0,i.init=1,i.setup(),i}return _inherits$5(e,t),_createClass$8(e,[{key:"configure",value:function(t){_get$4(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"configure",this).call(this,t),this.mouseMove=this.mouseMove.bind(this),this.mouseLeave=this.mouseLeave.bind(this),this.hoverRadio=t.hoverRadio||.1,this.config.startAngle=t.startAngle||0,this.clockWise=t.clockWise||!1,this.strokeWidth=t.strokeWidth||30;}},{key:"calc",value:function(){var t=this;_get$4(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"calc",this).call(this);var n=this.state;this.radius=this.height>this.width?this.center.x-this.strokeWidth/2:this.center.y-this.strokeWidth/2;var i=this.radius,a=this.clockWise,r=n.slicesProperties||[];n.sliceStrings=[],n.slicesProperties=[];var s=180-this.config.startAngle;n.sliceTotals.map(function(e,o){var l=s,u=e/n.grandTotal*FULL_ANGLE,c=u>180?1:0,h=a?-u:u,d=s+=h,f=getPositionByAngle(l,i),p=getPositionByAngle(d,i),v=t.init&&r[o],g=void 0,y=void 0;t.init?(g=v?v.startPosition:f,y=v?v.endPosition:f):(g=f,y=p);var m=360===u?makeStrokeCircleStr(g,y,t.center,t.radius,t.clockWise,c):makeArcStrokePathStr(g,y,t.center,t.radius,t.clockWise,c);n.sliceStrings.push(m),n.slicesProperties.push({startPosition:f,endPosition:p,value:e,total:n.grandTotal,startAngle:l,endAngle:d,angle:h});}),this.init=0;}},{key:"setupComponents",value:function(){var t=this.state,e=[["donutSlices",{},function(){return {sliceStrings:t.sliceStrings,colors:this.colors,strokeWidth:this.strokeWidth}}.bind(this)]];this.components=new Map(e.map(function(t){var e=getComponent.apply(void 0,_toConsumableArray$7(t));return [t[0],e]}));}},{key:"calTranslateByAngle",value:function(t){var e=this.radius,n=this.hoverRadio,i=getPositionByAngle(t.startAngle+t.angle/2,e);return "translate3d("+i.x*n+"px,"+i.y*n+"px,0)"}},{key:"hoverSlice",value:function(t,e,n,i){if(t){var a=this.colors[e];if(n){transform(t,this.calTranslateByAngle(this.state.slicesProperties[e])),t.style.stroke=lightenDarkenColor(a,50);var r=getOffset(this.svg),s=i.pageX-r.left+10,o=i.pageY-r.top-10,l=(this.formatted_labels&&this.formatted_labels.length>0?this.formatted_labels[e]:this.state.labels[e])+": ",u=(100*this.state.sliceTotals[e]/this.state.grandTotal).toFixed(1);this.tip.setValues(s,o,{name:l,value:u+"%"}),this.tip.showTip();}else { transform(t,"translate3d(0,0,0)"),this.tip.hideTip(),t.style.stroke=a; }}}},{key:"bindTooltip",value:function(){this.container.addEventListener("mousemove",this.mouseMove),this.container.addEventListener("mouseleave",this.mouseLeave);}},{key:"mouseMove",value:function(t){var e=t.target,n=this.components.get("donutSlices").store,i=this.curActiveSliceIndex,a=this.curActiveSlice;if(n.includes(e)){var r=n.indexOf(e);this.hoverSlice(a,i,!1),this.curActiveSlice=e,this.curActiveSliceIndex=r,this.hoverSlice(e,r,!0,t);}else { this.mouseLeave(); }}},{key:"mouseLeave",value:function(){this.hoverSlice(this.curActiveSlice,this.curActiveSliceIndex,!1);}}]),e}(AggregationChart),chartTypes={bar:AxisChart,line:AxisChart,percentage:PercentageChart,heatmap:Heatmap,pie:PieChart,donut:DonutChart},Chart=function t(e,n){return _classCallCheck(this,t),getChartByType(n.type,e,n)};

	frappe.Chart = Chart;

	var Sortable$1 = createCommonjsModule(function (module) {
	/**!
	 * Sortable
	 * @author	RubaXa   <trash@rubaxa.org>
	 * @author	owenm    <owen23355@gmail.com>
	 * @license MIT
	 */

	(function sortableModule(factory) {

		{
			module.exports = factory();
		}
	})(function sortableFactory() {

		if (typeof window === "undefined" || !window.document) {
			return function sortableError() {
				throw new Error("Sortable.js requires a window with a document");
			};
		}

		var dragEl,
			parentEl,
			ghostEl,
			cloneEl,
			rootEl,
			nextEl,
			lastDownEl,

			scrollEl,
			scrollParentEl,
			scrollCustomFn,

			oldIndex,
			newIndex,

			activeGroup,
			putSortable,

			autoScrolls = [],
			scrolling = false,

			awaitingDragStarted = false,
			ignoreNextClick = false,
			sortables = [],

			pointerElemChangedInterval,
			lastPointerElemX,
			lastPointerElemY,

			tapEvt,
			touchEvt,

			moved,


			lastTarget,
			lastDirection,
			pastFirstInvertThresh = false,
			isCircumstantialInvert = false,
			lastMode, // 'swap' or 'insert'

			targetMoveDistance,


			forRepaintDummy,
			realDragElRect, // dragEl rect after current animation

			/** @const */
			R_SPACE = /\s+/g,

			expando = 'Sortable' + (new Date).getTime(),

			win = window,
			document = win.document,
			parseInt = win.parseInt,
			setTimeout = win.setTimeout,

			$ = win.jQuery || win.Zepto,
			Polymer = win.Polymer,

			captureMode = {
				capture: false,
				passive: false
			},

			IE11OrLess = !!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie|iemobile)/i),
			Edge = !!navigator.userAgent.match(/Edge/i),
			// FireFox = !!navigator.userAgent.match(/firefox/i),

			CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',

			// This will not pass for IE9, because IE9 DnD only works on anchors
			supportDraggable = ('draggable' in document.createElement('div')),

			supportCssPointerEvents = (function() {
				// false when <= IE11
				if (IE11OrLess) {
					return false;
				}
				var el = document.createElement('x');
				el.style.cssText = 'pointer-events:auto';
				return el.style.pointerEvents === 'auto';
			})(),

			_silent = false,
			_alignedSilent = false,

			abs = Math.abs,
			min = Math.min,

			savedInputChecked = [],

			_detectDirection = function(el, options) {
				var elCSS = _css(el),
					elWidth = parseInt(elCSS.width),
					child1 = _getChild(el, 0, options),
					child2 = _getChild(el, 1, options),
					firstChildCSS = child1 && _css(child1),
					secondChildCSS = child2 && _css(child2),
					firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + _getRect(child1).width,
					secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + _getRect(child2).width;
				if (elCSS.display === 'flex') {
					return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse'
					? 'vertical' : 'horizontal';
				}
				if (child1 && firstChildCSS.float !== 'none') {
					var touchingSideChild2 = firstChildCSS.float === 'left' ? 'left' : 'right';

					return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ?
						'vertical' : 'horizontal';
				}
				return (child1 &&
					(
						firstChildCSS.display === 'block' ||
						firstChildCSS.display === 'flex' ||
						firstChildCSS.display === 'table' ||
						firstChildCSS.display === 'grid' ||
						firstChildWidth >= elWidth &&
						elCSS[CSSFloatProperty] === 'none' ||
						child2 &&
						elCSS[CSSFloatProperty] === 'none' &&
						firstChildWidth + secondChildWidth > elWidth
					) ?
					'vertical' : 'horizontal'
				);
			},

			/**
			 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
			 * @param  {Number} x      X position
			 * @param  {Number} y      Y position
			 * @return {HTMLElement}   Element of the first found nearest Sortable
			 */
			_detectNearestEmptySortable = function(x, y) {
				for (var i = 0; i < sortables.length; i++) {
					if (sortables[i].children.length) { continue; }

					var rect = _getRect(sortables[i]),
						threshold = sortables[i][expando].options.emptyInsertThreshold,
						insideHorizontally = x >= (rect.left - threshold) && x <= (rect.right + threshold),
						insideVertically = y >= (rect.top - threshold) && y <= (rect.bottom + threshold);

					if (insideHorizontally && insideVertically) {
						return sortables[i];
					}
				}
			},

			_isClientInRowColumn = function(x, y, el, axis, options) {
				var targetRect = _getRect(el),
					targetS1Opp = axis === 'vertical' ? targetRect.left : targetRect.top,
					targetS2Opp = axis === 'vertical' ? targetRect.right : targetRect.bottom,
					mouseOnOppAxis = axis === 'vertical' ? x : y;

				return targetS1Opp < mouseOnOppAxis && mouseOnOppAxis < targetS2Opp;
			},

			_isElInRowColumn = function(el1, el2, axis) {
				var el1Rect = el1 === dragEl && realDragElRect || _getRect(el1),
					el2Rect = el2 === dragEl && realDragElRect || _getRect(el2),
					el1S1Opp = axis === 'vertical' ? el1Rect.left : el1Rect.top,
					el1S2Opp = axis === 'vertical' ? el1Rect.right : el1Rect.bottom,
					el1OppLength = axis === 'vertical' ? el1Rect.width : el1Rect.height,
					el2S1Opp = axis === 'vertical' ? el2Rect.left : el2Rect.top,
					el2S2Opp = axis === 'vertical' ? el2Rect.right : el2Rect.bottom,
					el2OppLength = axis === 'vertical' ? el2Rect.width : el2Rect.height;

				return (
					el1S1Opp === el2S1Opp ||
					el1S2Opp === el2S2Opp ||
					(el1S1Opp + el1OppLength / 2) === (el2S1Opp + el2OppLength / 2)
				);
			},

			_getParentAutoScrollElement = function(el, includeSelf) {
				// skip to window
				if (!el || !el.getBoundingClientRect) { return win; }

				var elem = el;
				var gotSelf = false;
				do {
					// we don't need to get elem css if it isn't even overflowing in the first place (performance)
					if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
						var elemCSS = _css(elem);
						if (
							elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') ||
							elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')
						) {
							if (!elem || !elem.getBoundingClientRect || elem === document.body) { return win; }

							if (gotSelf || includeSelf) { return elem; }
							gotSelf = true;
						}
					}
				/* jshint boss:true */
				} while (elem = elem.parentNode);

				return win;
			},

			_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl, /**Boolean*/isFallback) {
				// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
				if (options.scroll) {
					var _this = rootEl ? rootEl[expando] : window,
						sens = options.scrollSensitivity,
						speed = options.scrollSpeed,

						x = evt.clientX,
						y = evt.clientY,

						winWidth = window.innerWidth,
						winHeight = window.innerHeight,

						scrollThisInstance = false;

					// Detect scrollEl
					if (scrollParentEl !== rootEl) {
						_clearAutoScrolls();

						scrollEl = options.scroll;
						scrollCustomFn = options.scrollFn;

						if (scrollEl === true) {
							scrollEl = _getParentAutoScrollElement(rootEl, true);
							scrollParentEl = scrollEl;
						}
					}


					var layersOut = 0;
					var currentParent = scrollEl;
					do {
						var	el = currentParent,
							rect = _getRect(el),

							top = rect.top,
							bottom = rect.bottom,
							left = rect.left,
							right = rect.right,

							width = rect.width,
							height = rect.height,

							scrollWidth,
							scrollHeight,

							css,

							vx,
							vy,

							canScrollX,
							canScrollY,

							scrollPosX,
							scrollPosY;


						if (el !== win) {
							scrollWidth = el.scrollWidth;
							scrollHeight = el.scrollHeight;

							css = _css(el);

							canScrollX = width < scrollWidth && (css.overflowX === 'auto' || css.overflowX === 'scroll');
							canScrollY = height < scrollHeight && (css.overflowY === 'auto' || css.overflowY === 'scroll');

							scrollPosX = el.scrollLeft;
							scrollPosY = el.scrollTop;
						} else {
							scrollWidth = document.documentElement.scrollWidth;
							scrollHeight = document.documentElement.scrollHeight;

							css = _css(document.documentElement);

							canScrollX = width < scrollWidth && (css.overflowX === 'auto' || css.overflowX === 'scroll' || css.overflowX === 'visible');
							canScrollY = height < scrollHeight && (css.overflowY === 'auto' || css.overflowY === 'scroll' || css.overflowY === 'visible');

							scrollPosX = document.documentElement.scrollLeft;
							scrollPosY = document.documentElement.scrollTop;
						}

						vx = canScrollX && (abs(right - x) <= sens && (scrollPosX + width) < scrollWidth) - (abs(left - x) <= sens && !!scrollPosX);

						vy = canScrollY && (abs(bottom - y) <= sens && (scrollPosY + height) < scrollHeight) - (abs(top - y) <= sens && !!scrollPosY);


						if (!autoScrolls[layersOut]) {
							for (var i = 0; i <= layersOut; i++) {
								if (!autoScrolls[i]) {
									autoScrolls[i] = {};
								}
							}
						}

						if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
							autoScrolls[layersOut].el = el;
							autoScrolls[layersOut].vx = vx;
							autoScrolls[layersOut].vy = vy;

							clearInterval(autoScrolls[layersOut].pid);

							if (el && (vx != 0 || vy != 0)) {
								scrollThisInstance = true;
								/* jshint loopfunc:true */
								autoScrolls[layersOut].pid = setInterval((function () {
									// emulate drag over during autoscroll (fallback), emulating native DnD behaviour
									if (isFallback && this.layer === 0) {
										Sortable.active._emulateDragOver(true);
									}
									var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
									var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

									if ('function' === typeof(scrollCustomFn)) {
										if (scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt, touchEvt, autoScrolls[this.layer].el) !== 'continue') {
											return;
										}
									}
									if (autoScrolls[this.layer].el === win) {
										win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);
									} else {
										autoScrolls[this.layer].el.scrollTop += scrollOffsetY;
										autoScrolls[this.layer].el.scrollLeft += scrollOffsetX;
									}
								}).bind({layer: layersOut}), 24);
							}
						}
						layersOut++;
					} while (options.bubbleScroll && currentParent !== win && (currentParent = _getParentAutoScrollElement(currentParent, false)));
					scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
				}
			}, 30),

			_clearAutoScrolls = function () {
				autoScrolls.forEach(function(autoScroll) {
					clearInterval(autoScroll.pid);
				});
				autoScrolls = [];
			},

			_prepareGroup = function (options) {
				function toFn(value, pull) {
					return function(to, from, dragEl, evt) {
						var sameGroup = to.options.group.name &&
										from.options.group.name &&
										to.options.group.name === from.options.group.name;

						if (value == null && (pull || sameGroup)) {
							// Default pull value
							// Default pull and put value if same group
							return true;
						} else if (value == null || value === false) {
							return false;
						} else if (pull && value === 'clone') {
							return value;
						} else if (typeof value === 'function') {
							return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
						} else {
							var otherGroup = (pull ? to : from).options.group.name;

							return (value === true ||
							(typeof value === 'string' && value === otherGroup) ||
							(value.join && value.indexOf(otherGroup) > -1));
						}
					};
				}

				var group = {};
				var originalGroup = options.group;

				if (!originalGroup || typeof originalGroup != 'object') {
					originalGroup = {name: originalGroup};
				}

				group.name = originalGroup.name;
				group.checkPull = toFn(originalGroup.pull, true);
				group.checkPut = toFn(originalGroup.put);
				group.revertClone = originalGroup.revertClone;

				options.group = group;
			},

			_checkAlignment = function(evt) {
				if (!dragEl || !dragEl.parentNode) { return; }
				dragEl.parentNode[expando] && dragEl.parentNode[expando]._computeIsAligned(evt);
			},

			_isTrueParentSortable = function(el, target) {
				var trueParent = target;
				while (!trueParent[expando]) {
					trueParent = trueParent.parentNode;
				}

				return el === trueParent;
			},

			_artificalBubble = function(sortable, originalEvt, method) {
				// Artificial IE bubbling
				var nextParent = sortable.parentNode;
				while (nextParent && !nextParent[expando]) {
					nextParent = nextParent.parentNode;
				}

				if (nextParent) {
					nextParent[expando][method](_extend(originalEvt, {
						artificialBubble: true
					}));
				}
			},

			_hideGhostForTarget = function() {
				if (!supportCssPointerEvents && ghostEl) {
					_css(ghostEl, 'display', 'none');
				}
			},

			_unhideGhostForTarget = function() {
				if (!supportCssPointerEvents && ghostEl) {
					_css(ghostEl, 'display', '');
				}
			};


		// #1184 fix - Prevent click event on fallback if dragged but item not changed position
		document.addEventListener('click', function(evt) {
			if (ignoreNextClick) {
				evt.preventDefault();
				evt.stopPropagation && evt.stopPropagation();
				evt.stopImmediatePropagation && evt.stopImmediatePropagation();
				ignoreNextClick = false;
				return false;
			}
		}, true);

		var nearestEmptyInsertDetectEvent = function(evt) {
			evt = evt.touches ? evt.touches[0] : evt;
			if (dragEl) {
				var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

				if (nearest) {
					nearest[expando]._onDragOver({
						clientX: evt.clientX,
						clientY: evt.clientY,
						target: nearest,
						rootEl: nearest
					});
				}
			}
		};
		// We do not want this to be triggered if completed (bubbling canceled), so only define it here
		_on(document, 'dragover', nearestEmptyInsertDetectEvent);
		_on(document, 'mousemove', nearestEmptyInsertDetectEvent);
		_on(document, 'touchmove', nearestEmptyInsertDetectEvent);

		/**
		 * @class  Sortable
		 * @param  {HTMLElement}  el
		 * @param  {Object}       [options]
		 */
		function Sortable(el, options) {
			if (!(el && el.nodeType && el.nodeType === 1)) {
				throw 'Sortable: `el` must be HTMLElement, not ' + {}.toString.call(el);
			}

			this.el = el; // root element
			this.options = options = _extend({}, options);


			// Export instance
			el[expando] = this;

			// Default options
			var defaults = {
				group: null,
				sort: true,
				disabled: false,
				store: null,
				handle: null,
				scroll: true,
				scrollSensitivity: 30,
				scrollSpeed: 10,
				bubbleScroll: true,
				draggable: /[uo]l/i.test(el.nodeName) ? '>li' : '>*',
				swapThreshold: 1, // percentage; 0 <= x <= 1
				invertSwap: false, // invert always
				invertedSwapThreshold: null, // will be set to same as swapThreshold if default
				removeCloneOnHide: true,
				direction: function() {
					return _detectDirection(el, this.options);
				},
				ghostClass: 'sortable-ghost',
				chosenClass: 'sortable-chosen',
				dragClass: 'sortable-drag',
				ignore: 'a, img',
				filter: null,
				preventOnFilter: true,
				animation: 0,
				easing: null,
				setData: function (dataTransfer, dragEl) {
					dataTransfer.setData('Text', dragEl.textContent);
				},
				dropBubble: false,
				dragoverBubble: false,
				dataIdAttr: 'data-id',
				delay: 0,
				touchStartThreshold: parseInt(window.devicePixelRatio, 10) || 1,
				forceFallback: false,
				fallbackClass: 'sortable-fallback',
				fallbackOnBody: false,
				fallbackTolerance: 0,
				fallbackOffset: {x: 0, y: 0},
				supportPointer: Sortable.supportPointer !== false && (
					('PointerEvent' in window) ||
					window.navigator && ('msPointerEnabled' in window.navigator) // microsoft
				),
				emptyInsertThreshold: 5
			};


			// Set default options
			for (var name in defaults) {
				!(name in options) && (options[name] = defaults[name]);
			}

			_prepareGroup(options);

			// Bind all private methods
			for (var fn in this) {
				if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
					this[fn] = this[fn].bind(this);
				}
			}

			// Setup drag mode
			this.nativeDraggable = options.forceFallback ? false : supportDraggable;

			// Bind events
			if (options.supportPointer) {
				_on(el, 'pointerdown', this._onTapStart);
			} else {
				_on(el, 'mousedown', this._onTapStart);
				_on(el, 'touchstart', this._onTapStart);
			}

			if (this.nativeDraggable) {
				_on(el, 'dragover', this);
				_on(el, 'dragenter', this);
			}

			sortables.push(this.el);

			// Restore sorting
			options.store && options.store.get && this.sort(options.store.get(this) || []);
		}

		Sortable.prototype = /** @lends Sortable.prototype */ {
			constructor: Sortable,

			_computeIsAligned: function(evt) {
				var target;

				if (ghostEl && !supportCssPointerEvents) {
					_hideGhostForTarget();
					target = document.elementFromPoint(evt.clientX, evt.clientY);
					_unhideGhostForTarget();
				} else {
					target = evt.target;
				}

				target = _closest(target, this.options.draggable, this.el, false);
				if (_alignedSilent) { return; }
				if (!dragEl || dragEl.parentNode !== this.el) { return; }

				var children = this.el.children;
				for (var i = 0; i < children.length; i++) {
					// Don't change for target in case it is changed to aligned before onDragOver is fired
					if (_closest(children[i], this.options.draggable, this.el, false) && children[i] !== target) {
						children[i].sortableMouseAligned = _isClientInRowColumn(evt.clientX, evt.clientY, children[i], this._getDirection(evt, null), this.options);
					}
				}
				// Used for nulling last target when not in element, nothing to do with checking if aligned
				if (!_closest(target, this.options.draggable, this.el, true)) {
					lastTarget = null;
				}

				_alignedSilent = true;
				setTimeout(function() {
					_alignedSilent = false;
				}, 30);

			},

			_getDirection: function(evt, target) {
				return (typeof this.options.direction === 'function') ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
			},

			_onTapStart: function (/** Event|TouchEvent */evt) {
				if (!evt.cancelable) { return; }
				var _this = this,
					el = this.el,
					options = this.options,
					preventOnFilter = options.preventOnFilter,
					type = evt.type,
					touch = evt.touches && evt.touches[0],
					target = (touch || evt).target,
					originalTarget = evt.target.shadowRoot && ((evt.path && evt.path[0]) || (evt.composedPath && evt.composedPath()[0])) || target,
					filter = options.filter,
					startIndex;

				_saveInputCheckedState(el);


				// IE: Calls events in capture mode if event element is nested. This ensures only correct element's _onTapStart goes through.
				// This process is also done in _onDragOver
				if (IE11OrLess && !evt.artificialBubble && !_isTrueParentSortable(el, target)) {
					return;
				}

				// Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
				if (dragEl) {
					return;
				}

				if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
					return; // only left button and enabled
				}

				// cancel dnd if original target is content editable
				if (originalTarget.isContentEditable) {
					return;
				}

				target = _closest(target, options.draggable, el, false);

				if (!target) {
					if (IE11OrLess) {
						_artificalBubble(el, evt, '_onTapStart');
					}
					return;
				}

				if (lastDownEl === target) {
					// Ignoring duplicate `down`
					return;
				}

				// Get the index of the dragged element within its parent
				startIndex = _index(target, options.draggable);

				// Check filter
				if (typeof filter === 'function') {
					if (filter.call(this, evt, target, this)) {
						_dispatchEvent(_this, originalTarget, 'filter', target, el, el, startIndex);
						preventOnFilter && evt.cancelable && evt.preventDefault();
						return; // cancel dnd
					}
				}
				else if (filter) {
					filter = filter.split(',').some(function (criteria) {
						criteria = _closest(originalTarget, criteria.trim(), el, false);

						if (criteria) {
							_dispatchEvent(_this, criteria, 'filter', target, el, el, startIndex);
							return true;
						}
					});

					if (filter) {
						preventOnFilter && evt.cancelable && evt.preventDefault();
						return; // cancel dnd
					}
				}

				if (options.handle && !_closest(originalTarget, options.handle, el, false)) {
					return;
				}

				// Prepare `dragstart`
				this._prepareDragStart(evt, touch, target, startIndex);
			},


			_handleAutoScroll: function(evt, fallback) {
				if (!dragEl || !this.options.scroll) { return; }
				var x = evt.clientX,
					y = evt.clientY,

					elem = document.elementFromPoint(x, y),
					_this = this;

				// IE does not seem to have native autoscroll,
				// Edge's autoscroll seems too conditional,
				// Firefox and Chrome are good
				if (fallback || Edge || IE11OrLess) {
					_autoScroll(evt, _this.options, elem, fallback);

					// Listener for pointer element change
					var ogElemScroller = _getParentAutoScrollElement(elem, true);
					if (
						scrolling &&
						(
							!pointerElemChangedInterval ||
							x !== lastPointerElemX ||
							y !== lastPointerElemY
						)
					) {

						pointerElemChangedInterval && clearInterval(pointerElemChangedInterval);
						// Detect for pointer elem change, emulating native DnD behaviour
						pointerElemChangedInterval = setInterval(function() {
							if (!dragEl) { return; }
							// could also check if scroll direction on newElem changes due to parent autoscrolling
							var newElem = _getParentAutoScrollElement(document.elementFromPoint(x, y), true);
							if (newElem !== ogElemScroller) {
								ogElemScroller = newElem;
								_clearAutoScrolls();
								_autoScroll(evt, _this.options, ogElemScroller, fallback);
							}
						}, 10);
						lastPointerElemX = x;
						lastPointerElemY = y;
					}

				} else {
					// if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
					if (!_this.options.bubbleScroll || _getParentAutoScrollElement(elem, true) === window) {
						_clearAutoScrolls();
						return;
					}
					_autoScroll(evt, _this.options, _getParentAutoScrollElement(elem, false), false);
				}
			},

			_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target, /** Number */startIndex) {
				var _this = this,
					el = _this.el,
					options = _this.options,
					ownerDocument = el.ownerDocument,
					dragStartFn;

				if (target && !dragEl && (target.parentNode === el)) {
					rootEl = el;
					dragEl = target;
					parentEl = dragEl.parentNode;
					nextEl = dragEl.nextSibling;
					lastDownEl = target;
					activeGroup = options.group;
					oldIndex = startIndex;

					tapEvt = {
						target: dragEl,
						clientX: (touch || evt).clientX,
						clientY: (touch || evt).clientY
					};

					this._lastX = (touch || evt).clientX;
					this._lastY = (touch || evt).clientY;

					dragEl.style['will-change'] = 'all';
					// undo animation if needed
					dragEl.style.transition = '';
					dragEl.style.transform = '';

					dragStartFn = function () {
						// Delayed drag has been triggered
						// we can re-enable the events: touchmove/mousemove
						_this._disableDelayedDrag();

						// Make the element draggable
						dragEl.draggable = _this.nativeDraggable;

						// Bind the events: dragstart/dragend
						_this._triggerDragStart(evt, touch);

						// Drag start event
						_dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, rootEl, oldIndex);

						// Chosen item
						_toggleClass(dragEl, options.chosenClass, true);
					};

					// Disable "draggable"
					options.ignore.split(',').forEach(function (criteria) {
						_find(dragEl, criteria.trim(), _disableDraggable);
					});

					if (options.supportPointer) {
						_on(ownerDocument, 'pointerup', _this._onDrop);
					} else {
						_on(ownerDocument, 'mouseup', _this._onDrop);
						_on(ownerDocument, 'touchend', _this._onDrop);
						_on(ownerDocument, 'touchcancel', _this._onDrop);
					}

					if (options.delay) {
						// If the user moves the pointer or let go the click or touch
						// before the delay has been reached:
						// disable the delayed drag
						_on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
						_on(ownerDocument, 'touchend', _this._disableDelayedDrag);
						_on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
						_on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
						_on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
						options.supportPointer && _on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);

						_this._dragStartTimer = setTimeout(dragStartFn, options.delay);
					} else {
						dragStartFn();
					}
				}
			},

			_delayedDragTouchMoveHandler: function (/** TouchEvent|PointerEvent **/e) {
				var touch = e.touches ? e.touches[0] : e;
				if (min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY))
						>= this.options.touchStartThreshold
				) {
					this._disableDelayedDrag();
				}
			},

			_disableDelayedDrag: function () {
				var ownerDocument = this.el.ownerDocument;

				clearTimeout(this._dragStartTimer);
				_off(ownerDocument, 'mouseup', this._disableDelayedDrag);
				_off(ownerDocument, 'touchend', this._disableDelayedDrag);
				_off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
				_off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
				_off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
				_off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
			},

			_triggerDragStart: function (/** Event */evt, /** Touch */touch) {
				touch = touch || (evt.pointerType == 'touch' ? evt : null);

				if (!this.nativeDraggable || touch) {
					if (this.options.supportPointer) {
						_on(document, 'pointermove', this._onTouchMove);
					} else if (touch) {
						_on(document, 'touchmove', this._onTouchMove);
					} else {
						_on(document, 'mousemove', this._onTouchMove);
					}
				} else {
					_on(dragEl, 'dragend', this);
					_on(rootEl, 'dragstart', this._onDragStart);
				}

				try {
					if (document.selection) {
						// Timeout neccessary for IE9
						_nextTick(function () {
							document.selection.empty();
						});
					} else {
						window.getSelection().removeAllRanges();
					}
				} catch (err) {
				}
			},

			_dragStarted: function (fallback) {
				awaitingDragStarted = false;
				if (rootEl && dragEl) {
					if (this.nativeDraggable) {
						_on(document, 'dragover', this._handleAutoScroll);
						_on(document, 'dragover', _checkAlignment);
					}
					var options = this.options;

					// Apply effect
					!fallback && _toggleClass(dragEl, options.dragClass, false);
					_toggleClass(dragEl, options.ghostClass, true);

					// In case dragging an animated element
					_css(dragEl, 'transform', '');

					Sortable.active = this;

					fallback && this._appendGhost();

					// Drag start event
					_dispatchEvent(this, rootEl, 'start', dragEl, rootEl, rootEl, oldIndex);
				} else {
					this._nulling();
				}
			},

			_emulateDragOver: function (bypassLastTouchCheck) {
				if (touchEvt) {
					if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY && !bypassLastTouchCheck) {
						return;
					}
					this._lastX = touchEvt.clientX;
					this._lastY = touchEvt.clientY;

					_hideGhostForTarget();

					var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
					var parent = target;

					while (target && target.shadowRoot) {
						target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
						parent = target;
					}

					if (parent) {
						do {
							if (parent[expando]) {
								var inserted;

								inserted = parent[expando]._onDragOver({
									clientX: touchEvt.clientX,
									clientY: touchEvt.clientY,
									target: target,
									rootEl: parent
								});

								if (inserted && !this.options.dragoverBubble) {
									break;
								}
							}

							target = parent; // store last element
						}
						/* jshint boss:true */
						while (parent = parent.parentNode);
					}
					dragEl.parentNode[expando]._computeIsAligned(touchEvt);

					_unhideGhostForTarget();
				}
			},


			_onTouchMove: function (/**TouchEvent*/evt) {
				if (tapEvt) {
					var	options = this.options,
						fallbackTolerance = options.fallbackTolerance,
						fallbackOffset = options.fallbackOffset,
						touch = evt.touches ? evt.touches[0] : evt,
						matrix = ghostEl && _matrix(ghostEl),
						scaleX = ghostEl && matrix && matrix.a,
						scaleY = ghostEl && matrix && matrix.d,
						dx = ((touch.clientX - tapEvt.clientX) + fallbackOffset.x) / (scaleX ? scaleX : 1),
						dy = ((touch.clientY - tapEvt.clientY) + fallbackOffset.y) / (scaleY ? scaleY : 1),
						translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';


					// only set the status to dragging, when we are actually dragging
					if (!Sortable.active && !awaitingDragStarted) {
						if (fallbackTolerance &&
							min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance
						) {
							return;
						}
						this._onDragStart(evt, true);
					}

					this._handleAutoScroll(touch, true);


					moved = true;
					touchEvt = touch;


					_css(ghostEl, 'webkitTransform', translate3d);
					_css(ghostEl, 'mozTransform', translate3d);
					_css(ghostEl, 'msTransform', translate3d);
					_css(ghostEl, 'transform', translate3d);

					evt.cancelable && evt.preventDefault();
				}
			},

			_appendGhost: function () {
				if (!ghostEl) {
					var rect = _getRect(dragEl, this.options.fallbackOnBody ? document.body : rootEl, true),
						css = _css(dragEl),
						options = this.options;

					ghostEl = dragEl.cloneNode(true);

					_toggleClass(ghostEl, options.ghostClass, false);
					_toggleClass(ghostEl, options.fallbackClass, true);
					_toggleClass(ghostEl, options.dragClass, true);

					_css(ghostEl, 'box-sizing', 'border-box');
					_css(ghostEl, 'margin', 0);
					_css(ghostEl, 'top', rect.top);
					_css(ghostEl, 'left', rect.left);
					_css(ghostEl, 'width', rect.width);
					_css(ghostEl, 'height', rect.height);
					_css(ghostEl, 'opacity', '0.8');
					_css(ghostEl, 'position', 'fixed');
					_css(ghostEl, 'zIndex', '100000');
					_css(ghostEl, 'pointerEvents', 'none');

					options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);
				}
			},

			_onDragStart: function (/**Event*/evt, /**boolean*/fallback) {
				var _this = this;
				var dataTransfer = evt.dataTransfer;
				var options = _this.options;

				// Setup clone
				cloneEl = _clone(dragEl);

				cloneEl.draggable = false;
				cloneEl.style['will-change'] = '';

				this._hideClone();

				_toggleClass(cloneEl, _this.options.chosenClass, false);


				// #1143: IFrame support workaround
				_this._cloneId = _nextTick(function () {
					if (!_this.options.removeCloneOnHide) {
						rootEl.insertBefore(cloneEl, dragEl);
					}
					_dispatchEvent(_this, rootEl, 'clone', dragEl);
				});


				!fallback && _toggleClass(dragEl, options.dragClass, true);

				// Set proper drop events
				if (fallback) {
					ignoreNextClick = true;
					_this._loopId = setInterval(_this._emulateDragOver, 50);
				} else {
					// Undo what was set in _prepareDragStart before drag started
					_off(document, 'mouseup', _this._onDrop);
					_off(document, 'touchend', _this._onDrop);
					_off(document, 'touchcancel', _this._onDrop);

					if (dataTransfer) {
						dataTransfer.effectAllowed = 'move';
						options.setData && options.setData.call(_this, dataTransfer, dragEl);
					}

					_on(document, 'drop', _this);

					// #1276 fix:
					_css(dragEl, 'transform', 'translateZ(0)');
				}

				awaitingDragStarted = true;

				_this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback));
				_on(document, 'selectstart', _this);
			},

			// Returns true - if no further action is needed (either inserted or another condition)
			_onDragOver: function (/**Event*/evt) {
				var el = this.el,
					target = evt.target,
					dragRect,
					targetRect,
					revert,
					options = this.options,
					group = options.group,
					activeSortable = Sortable.active,
					isOwner = (activeGroup === group),
					canSort = options.sort,
					_this = this;

				if (_silent) { return; }

				// IE event order fix
				if (IE11OrLess && !evt.rootEl && !evt.artificialBubble && !_isTrueParentSortable(el, target)) {
					return;
				}

				// Return invocation when no further action is needed in another sortable
				function completed() {
					if (activeSortable) {
						// Set ghost class to new sortable's ghost class
						_toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
						_toggleClass(dragEl, options.ghostClass, true);
					}

					if (putSortable !== _this && _this !== Sortable.active) {
						putSortable = _this;
					} else if (_this === Sortable.active) {
						putSortable = null;
					}


					// Null lastTarget if it is not inside a previously swapped element
					if ((target === dragEl && !dragEl.animated) || (target === el && !target.animated)) {
						lastTarget = null;
					}
					// no bubbling and not fallback
					if (!options.dragoverBubble && !evt.rootEl && target !== document) {
						_this._handleAutoScroll(evt);
						dragEl.parentNode[expando]._computeIsAligned(evt);
					}

					!options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();

					return true;
				}

				// Call when dragEl has been inserted
				function changed() {
					_dispatchEvent(_this, rootEl, 'change', target, el, rootEl, oldIndex, _index(dragEl, options.draggable), evt);
				}


				if (evt.preventDefault !== void 0) {
					evt.cancelable && evt.preventDefault();
				}


				moved = true;

				target = _closest(target, options.draggable, el, true);

				// target is dragEl or target is animated
				if (!!_closest(evt.target, null, dragEl, true) || target.animated) {
					return completed();
				}

				if (target !== dragEl) {
					ignoreNextClick = false;
				}

				if (activeSortable && !options.disabled &&
					(isOwner
						? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
						: (
							putSortable === this ||
							(
								(this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&
								group.checkPut(this, activeSortable, dragEl, evt)
							)
						)
					)
				) {
					var axis = this._getDirection(evt, target);

					dragRect = _getRect(dragEl);

					if (revert) {
						this._hideClone();
						parentEl = rootEl; // actualization

						if (nextEl) {
							rootEl.insertBefore(dragEl, nextEl);
						} else {
							rootEl.appendChild(dragEl);
						}

						return completed();
					}

					if ((el.children.length === 0) || (el.children[0] === ghostEl) ||
						_ghostIsLast(evt, axis, el) && !dragEl.animated
					) {
						//assign target only if condition is true
						if (el.children.length !== 0 && el.children[0] !== ghostEl && el === evt.target) {
							target = _lastChild(el);
						}

						if (target) {
							targetRect = _getRect(target);
						}

						if (isOwner) {
							activeSortable._hideClone();
						} else {
							activeSortable._showClone(this);
						}

						if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
							el.appendChild(dragEl);
							parentEl = el; // actualization
							realDragElRect = null;

							changed();
							this._animate(dragRect, dragEl);
							target && this._animate(targetRect, target);
							return completed();
						}
					}
					else if (target && target !== dragEl && target.parentNode === el) {
						var direction = 0,
							targetBeforeFirstSwap,
							aligned = target.sortableMouseAligned,
							differentLevel = dragEl.parentNode !== el,
							scrolledPastTop = _isScrolledPast(target, axis === 'vertical' ? 'top' : 'left');

						if (lastTarget !== target) {
							lastMode = null;
							targetBeforeFirstSwap = _getRect(target)[axis === 'vertical' ? 'top' : 'left'];
							pastFirstInvertThresh = false;
						}

						// Reference: https://www.lucidchart.com/documents/view/10fa0e93-e362-4126-aca2-b709ee56bd8b/0
						if (
							_isElInRowColumn(dragEl, target, axis) && aligned ||
							differentLevel ||
							scrolledPastTop ||
							options.invertSwap ||
							lastMode === 'insert' ||
							// Needed, in the case that we are inside target and inserted because not aligned... aligned will stay false while inside
							// and lastMode will change to 'insert', but we must swap
							lastMode === 'swap'
						) {
							// New target that we will be inside
							if (lastMode !== 'swap') {
								isCircumstantialInvert = options.invertSwap || differentLevel || scrolling || scrolledPastTop;
							}

							direction = _getSwapDirection(evt, target, axis,
								options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold,
								isCircumstantialInvert,
								lastTarget === target);
							lastMode = 'swap';
						} else {
							// Insert at position
							direction = _getInsertDirection(target, options);
							lastMode = 'insert';
						}
						if (direction === 0) { return completed(); }

						realDragElRect = null;
						lastTarget = target;

						lastDirection = direction;

						targetRect = _getRect(target);

						var nextSibling = target.nextElementSibling,
							after = false;

						after = direction === 1;

						var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

						if (moveVector !== false) {
							if (moveVector === 1 || moveVector === -1) {
								after = (moveVector === 1);
							}

							_silent = true;
							setTimeout(_unsilent, 30);

							if (isOwner) {
								activeSortable._hideClone();
							} else {
								activeSortable._showClone(this);
							}

							if (after && !nextSibling) {
								el.appendChild(dragEl);
							} else {
								target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
							}

							parentEl = dragEl.parentNode; // actualization

							// must be done before animation
							if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
								targetMoveDistance = abs(targetBeforeFirstSwap - _getRect(target)[axis === 'vertical' ? 'top' : 'left']);
							}
							changed();
							!differentLevel && this._animate(targetRect, target);
							this._animate(dragRect, dragEl);

							return completed();
						}
					}

					if (el.contains(dragEl)) {
						return completed();
					}
				}

				if (IE11OrLess && !evt.rootEl) {
					_artificalBubble(el, evt, '_onDragOver');
				}

				return false;
			},

			_animate: function (prevRect, target) {
				var ms = this.options.animation;

				if (ms) {
					var currentRect = _getRect(target);

					if (target === dragEl) {
						realDragElRect = currentRect;
					}

					if (prevRect.nodeType === 1) {
						prevRect = _getRect(prevRect);
					}

					// Check if actually moving position
					if ((prevRect.left + prevRect.width / 2) !== (currentRect.left + currentRect.width / 2)
						|| (prevRect.top + prevRect.height / 2) !== (currentRect.top + currentRect.height / 2)
					) {
						var matrix = _matrix(this.el),
							scaleX = matrix && matrix.a,
							scaleY = matrix && matrix.d;

						_css(target, 'transition', 'none');
						_css(target, 'transform', 'translate3d('
							+ (prevRect.left - currentRect.left) / (scaleX ? scaleX : 1) + 'px,'
							+ (prevRect.top - currentRect.top) / (scaleY ? scaleY : 1) + 'px,0)'
						);

						forRepaintDummy = target.offsetWidth; // repaint
						_css(target, 'transition', 'transform ' + ms + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
						_css(target, 'transform', 'translate3d(0,0,0)');
					}

					(typeof target.animated === 'number') && clearTimeout(target.animated);
					target.animated = setTimeout(function () {
						_css(target, 'transition', '');
						_css(target, 'transform', '');
						target.animated = false;
					}, ms);
				}
			},

			_offUpEvents: function () {
				var ownerDocument = this.el.ownerDocument;

				_off(document, 'touchmove', this._onTouchMove);
				_off(document, 'pointermove', this._onTouchMove);
				_off(ownerDocument, 'mouseup', this._onDrop);
				_off(ownerDocument, 'touchend', this._onDrop);
				_off(ownerDocument, 'pointerup', this._onDrop);
				_off(ownerDocument, 'touchcancel', this._onDrop);
				_off(document, 'selectstart', this);
			},

			_onDrop: function (/**Event*/evt) {
				var el = this.el,
					options = this.options;
				awaitingDragStarted = false;
				scrolling = false;
				isCircumstantialInvert = false;
				pastFirstInvertThresh = false;

				clearInterval(this._loopId);

				clearInterval(pointerElemChangedInterval);
				_clearAutoScrolls();
				_cancelThrottle();

				clearTimeout(this._dragStartTimer);

				_cancelNextTick(this._cloneId);
				_cancelNextTick(this._dragStartId);

				// Unbind events
				_off(document, 'mousemove', this._onTouchMove);


				if (this.nativeDraggable) {
					_off(document, 'drop', this);
					_off(el, 'dragstart', this._onDragStart);
					_off(document, 'dragover', this._handleAutoScroll);
					_off(document, 'dragover', _checkAlignment);
				}

				this._offUpEvents();

				if (evt) {
					if (moved) {
						evt.cancelable && evt.preventDefault();
						!options.dropBubble && evt.stopPropagation();
					}

					ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

					if (rootEl === parentEl || (putSortable && putSortable.lastPutMode !== 'clone')) {
						// Remove clone
						cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
					}

					if (dragEl) {
						if (this.nativeDraggable) {
							_off(dragEl, 'dragend', this);
						}

						_disableDraggable(dragEl);
						dragEl.style['will-change'] = '';

						// Remove class's
						_toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
						_toggleClass(dragEl, this.options.chosenClass, false);

						// Drag stop event
						_dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex, null, evt);

						if (rootEl !== parentEl) {
							newIndex = _index(dragEl, options.draggable);

							if (newIndex >= 0) {
								// Add event
								_dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

								// Remove event
								_dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

								// drag from one list and drop into another
								_dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
								_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
							}

							putSortable && putSortable.save();
						}
						else {
							if (dragEl.nextSibling !== nextEl) {
								// Get the index of the dragged element within its parent
								newIndex = _index(dragEl, options.draggable);

								if (newIndex >= 0) {
									// drag & drop within the same list
									_dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
									_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
								}
							}
						}

						if (Sortable.active) {
							/* jshint eqnull:true */
							if (newIndex == null || newIndex === -1) {
								newIndex = oldIndex;
							}

							_dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

							// Save sorting
							this.save();
						}
					}

				}
				this._nulling();
			},

			_nulling: function() {
				rootEl =
				dragEl =
				parentEl =
				ghostEl =
				nextEl =
				cloneEl =
				lastDownEl =

				scrollEl =
				scrollParentEl =
				autoScrolls.length =

				pointerElemChangedInterval =
				lastPointerElemX =
				lastPointerElemY =

				tapEvt =
				touchEvt =

				moved =
				newIndex =
				oldIndex =

				lastTarget =
				lastDirection =

				forRepaintDummy =
				realDragElRect =

				putSortable =
				activeGroup =
				Sortable.active = null;

				savedInputChecked.forEach(function (el) {
					el.checked = true;
				});

				savedInputChecked.length = 0;
			},

			handleEvent: function (/**Event*/evt) {
				switch (evt.type) {
					case 'drop':
					case 'dragend':
						this._onDrop(evt);
						break;

					case 'dragenter':
					case 'dragover':
						if (dragEl) {
							this._onDragOver(evt);
							_globalDragOver(evt);
						}
						break;

					case 'selectstart':
						evt.preventDefault();
						break;
				}
			},


			/**
			 * Serializes the item into an array of string.
			 * @returns {String[]}
			 */
			toArray: function () {
				var order = [],
					el,
					children = this.el.children,
					i = 0,
					n = children.length,
					options = this.options;

				for (; i < n; i++) {
					el = children[i];
					if (_closest(el, options.draggable, this.el, false)) {
						order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
					}
				}

				return order;
			},


			/**
			 * Sorts the elements according to the array.
			 * @param  {String[]}  order  order of the items
			 */
			sort: function (order) {
				var items = {}, rootEl = this.el;

				this.toArray().forEach(function (id, i) {
					var el = rootEl.children[i];

					if (_closest(el, this.options.draggable, rootEl, false)) {
						items[id] = el;
					}
				}, this);

				order.forEach(function (id) {
					if (items[id]) {
						rootEl.removeChild(items[id]);
						rootEl.appendChild(items[id]);
					}
				});
			},


			/**
			 * Save the current sorting
			 */
			save: function () {
				var store = this.options.store;
				store && store.set && store.set(this);
			},


			/**
			 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
			 * @param   {HTMLElement}  el
			 * @param   {String}       [selector]  default: `options.draggable`
			 * @returns {HTMLElement|null}
			 */
			closest: function (el, selector) {
				return _closest(el, selector || this.options.draggable, this.el, false);
			},


			/**
			 * Set/get option
			 * @param   {string} name
			 * @param   {*}      [value]
			 * @returns {*}
			 */
			option: function (name, value) {
				var options = this.options;

				if (value === void 0) {
					return options[name];
				} else {
					options[name] = value;

					if (name === 'group') {
						_prepareGroup(options);
					}
				}
			},


			/**
			 * Destroy
			 */
			destroy: function () {
				var el = this.el;

				el[expando] = null;

				_off(el, 'mousedown', this._onTapStart);
				_off(el, 'touchstart', this._onTapStart);
				_off(el, 'pointerdown', this._onTapStart);

				if (this.nativeDraggable) {
					_off(el, 'dragover', this);
					_off(el, 'dragenter', this);
				}
				// Remove draggable attributes
				Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
					el.removeAttribute('draggable');
				});

				this._onDrop();

				sortables.splice(sortables.indexOf(this.el), 1);

				this.el = el = null;
			},

			_hideClone: function() {
				if (!cloneEl.cloneHidden) {
					_css(cloneEl, 'display', 'none');
					cloneEl.cloneHidden = true;
					if (cloneEl.parentNode && this.options.removeCloneOnHide) {
						cloneEl.parentNode.removeChild(cloneEl);
					}
				}
			},

			_showClone: function(putSortable) {
				if (putSortable.lastPutMode !== 'clone') {
					this._hideClone();
					return;
				}

				if (cloneEl.cloneHidden) {
					// show clone at dragEl or original position
					if (rootEl.contains(dragEl) && !this.options.group.revertClone) {
						rootEl.insertBefore(cloneEl, dragEl);
					} else if (nextEl) {
						rootEl.insertBefore(cloneEl, nextEl);
					} else {
						rootEl.appendChild(cloneEl);
					}

					if (this.options.group.revertClone) {
						this._animate(dragEl, cloneEl);
					}
					_css(cloneEl, 'display', '');
					cloneEl.cloneHidden = false;
				}
			}
		};

		function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
			if (el) {
				ctx = ctx || document;

				do {
					if (
						selector != null &&
						(
							selector[0] === '>' && el.parentNode === ctx && _matches(el, selector.substring(1)) ||
							_matches(el, selector)
						) ||
						includeCTX && el === ctx
					) {
						return el;
					}

					if (el === ctx) { break; }
					/* jshint boss:true */
				} while (el = _getParentOrHost(el));
			}

			return null;
		}


		function _getParentOrHost(el) {
			return (el.host && el !== document && el.host.nodeType)
				? el.host
				: el.parentNode;
		}


		function _globalDragOver(/**Event*/evt) {
			if (evt.dataTransfer) {
				evt.dataTransfer.dropEffect = 'move';
			}
			evt.cancelable && evt.preventDefault();
		}


		function _on(el, event, fn) {
			el.addEventListener(event, fn, captureMode);
		}


		function _off(el, event, fn) {
			el.removeEventListener(event, fn, captureMode);
		}


		function _toggleClass(el, name, state) {
			if (el && name) {
				if (el.classList) {
					el.classList[state ? 'add' : 'remove'](name);
				}
				else {
					var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
					el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
				}
			}
		}


		function _css(el, prop, val) {
			var style = el && el.style;

			if (style) {
				if (val === void 0) {
					if (document.defaultView && document.defaultView.getComputedStyle) {
						val = document.defaultView.getComputedStyle(el, '');
					}
					else if (el.currentStyle) {
						val = el.currentStyle;
					}

					return prop === void 0 ? val : val[prop];
				}
				else {
					if (!(prop in style) && prop.indexOf('webkit') === -1) {
						prop = '-webkit-' + prop;
					}

					style[prop] = val + (typeof val === 'string' ? '' : 'px');
				}
			}
		}

		function _matrix(el) {
			var appliedTransforms = '';
			do {
				var transform = _css(el, 'transform');

				if (transform && transform !== 'none') {
					appliedTransforms = transform + ' ' + appliedTransforms;
				}
				/* jshint boss:true */
			} while (el = el.parentNode);

			if (window.DOMMatrix) {
				return new DOMMatrix(appliedTransforms);
			} else if (window.WebKitCSSMatrix) {
				return new WebKitCSSMatrix(appliedTransforms);
			} else if (window.CSSMatrix) {
				return new CSSMatrix(appliedTransforms);
			}
		}


		function _find(ctx, tagName, iterator) {
			if (ctx) {
				var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;

				if (iterator) {
					for (; i < n; i++) {
						iterator(list[i], i);
					}
				}

				return list;
			}

			return [];
		}



		function _dispatchEvent(sortable, rootEl, name, targetEl, toEl, fromEl, startIndex, newIndex, originalEvt) {
			sortable = (sortable || rootEl[expando]);
			var evt,
				options = sortable.options,
				onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
			// Support for new CustomEvent feature
			if (window.CustomEvent && !IE11OrLess && !Edge) {
				evt = new CustomEvent(name, {
					bubbles: true,
					cancelable: true
				});
			} else {
				evt = document.createEvent('Event');
				evt.initEvent(name, true, true);
			}

			evt.to = toEl || rootEl;
			evt.from = fromEl || rootEl;
			evt.item = targetEl || rootEl;
			evt.clone = cloneEl;

			evt.oldIndex = startIndex;
			evt.newIndex = newIndex;

			evt.originalEvent = originalEvt;

			if (rootEl) {
				rootEl.dispatchEvent(evt);
		        }

			if (options[onName]) {
				options[onName].call(sortable, evt);
			}
		}


		function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {
			var evt,
				sortable = fromEl[expando],
				onMoveFn = sortable.options.onMove,
				retVal;
			// Support for new CustomEvent feature
			if (window.CustomEvent && !IE11OrLess && !Edge) {
				evt = new CustomEvent('move', {
					bubbles: true,
					cancelable: true
				});
			} else {
				evt = document.createEvent('Event');
				evt.initEvent('move', true, true);
			}

			evt.to = toEl;
			evt.from = fromEl;
			evt.dragged = dragEl;
			evt.draggedRect = dragRect;
			evt.related = targetEl || toEl;
			evt.relatedRect = targetRect || _getRect(toEl);
			evt.willInsertAfter = willInsertAfter;

			evt.originalEvent = originalEvt;

			fromEl.dispatchEvent(evt);

			if (onMoveFn) {
				retVal = onMoveFn.call(sortable, evt, originalEvt);
			}

			return retVal;
		}

		function _disableDraggable(el) {
			el.draggable = false;
		}

		function _unsilent() {
			_silent = false;
		}

		/**
		 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
		 * and non-draggable elements
		 * @param  {HTMLElement} el       The parent element
		 * @param  {Number} childNum      The index of the child
		 * @param  {Object} options       Parent Sortable's options
		 * @return {HTMLElement}          The child at index childNum, or null if not found
		 */
		function _getChild(el, childNum, options) {
			var currentChild = 0,
				i = 0,
				children = el.children;

			while (i < children.length) {
				if (
					children[i].style.display !== 'none' &&
					children[i] !== ghostEl &&
					children[i] !== dragEl &&
					_closest(children[i], options.draggable, el, false)
				) {
					if (currentChild === childNum) {
						return children[i];
					}
					currentChild++;
				}

				i++;
			}
			return null;
		}

		/**
		 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
		 * @param  {HTMLElement} el       Parent element
		 * @return {HTMLElement}          The last child, ignoring ghostEl
		 */
		function _lastChild(el) {
			var last = el.lastElementChild;

			while (last === ghostEl || last.style.display === 'none') {
				last = last.previousElementSibling;

				if (!last) { break; }
			}

			return last || null;
		}

		function _ghostIsLast(evt, axis, el) {
			var elRect = _getRect(_lastChild(el)),
				mouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,
				mouseOnOppAxis = axis === 'vertical' ? evt.clientX : evt.clientY,
				targetS2 = axis === 'vertical' ? elRect.bottom : elRect.right,
				targetS1Opp = axis === 'vertical' ? elRect.left : elRect.top,
				targetS2Opp = axis === 'vertical' ? elRect.right : elRect.bottom,
				spacer = 10;

			return (
				axis === 'vertical' ?
					(mouseOnOppAxis > targetS2Opp + spacer || mouseOnOppAxis <= targetS2Opp && mouseOnAxis > targetS2 && mouseOnOppAxis >= targetS1Opp) :
					(mouseOnAxis > targetS2 && mouseOnOppAxis > targetS1Opp || mouseOnAxis <= targetS2 && mouseOnOppAxis > targetS2Opp + spacer)
			);
		}

		function _getSwapDirection(evt, target, axis, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
			var targetRect = _getRect(target),
				mouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,
				targetLength = axis === 'vertical' ? targetRect.height : targetRect.width,
				targetS1 = axis === 'vertical' ? targetRect.top : targetRect.left,
				targetS2 = axis === 'vertical' ? targetRect.bottom : targetRect.right,
				dragRect = _getRect(dragEl),
				invert = false;


			if (!invertSwap) {
				// Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
				if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) { // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
					// check if past first invert threshold on side opposite of lastDirection
					if (!pastFirstInvertThresh &&
						(lastDirection === 1 ?
							(
								mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2
							) :
							(
								mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2
							)
						)
					)
					{
						// past first invert threshold, do not restrict inverted threshold to dragEl shadow
						pastFirstInvertThresh = true;
					}

					if (!pastFirstInvertThresh) {
						var dragS1 = axis === 'vertical' ? dragRect.top : dragRect.left,
							dragS2 = axis === 'vertical' ? dragRect.bottom : dragRect.right;
						// dragEl shadow (target move distance shadow)
						if (
							lastDirection === 1 ?
							(
								mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
							) :
							(
								mouseOnAxis > targetS2 - targetMoveDistance
							)
						)
						{
							return lastDirection * -1;
						}
					} else {
						invert = true;
					}
				} else {
					// Regular
					if (
						mouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold) / 2) &&
						mouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold) / 2)
					) {
						return ((mouseOnAxis > targetS1 + targetLength / 2) ? -1 : 1);
					}
				}
			}

			invert = invert || invertSwap;

			if (invert) {
				// Invert of regular
				if (
					mouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold / 2) ||
					mouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold / 2)
				)
				{
					return ((mouseOnAxis > targetS1 + targetLength / 2) ? 1 : -1);
				}
			}

			return 0;
		}

		/**
		 * Gets the direction dragEl must be swapped relative to target in order to make it
		 * seem that dragEl has been "inserted" into that element's position
		 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
		 * @param  {Object} options           options of the parent sortable
		 * @return {Number}                   Direction dragEl must be swapped
		 */
		function _getInsertDirection(target, options) {
			var dragElIndex = _index(dragEl, options.draggable),
				targetIndex = _index(target, options.draggable);

			if (dragElIndex < targetIndex) {
				return 1;
			} else {
				return -1;
			}
		}


		/**
		 * Generate id
		 * @param   {HTMLElement} el
		 * @returns {String}
		 * @private
		 */
		function _generateId(el) {
			var str = el.tagName + el.className + el.src + el.href + el.textContent,
				i = str.length,
				sum = 0;

			while (i--) {
				sum += str.charCodeAt(i);
			}

			return sum.toString(36);
		}

		/**
		 * Returns the index of an element within its parent for a selected set of
		 * elements
		 * @param  {HTMLElement} el
		 * @param  {selector} selector
		 * @return {number}
		 */
		function _index(el, selector) {
			var index = 0;

			if (!el || !el.parentNode) {
				return -1;
			}

			while (el && (el = el.previousElementSibling)) {
				if ((el.nodeName.toUpperCase() !== 'TEMPLATE') && el !== cloneEl) {
					index++;
				}
			}

			return index;
		}

		function _matches(/**HTMLElement*/el, /**String*/selector) {
			if (el) {
				try {
					if (el.matches) {
						return el.matches(selector);
					} else if (el.msMatchesSelector) {
						return el.msMatchesSelector(selector);
					} else if (el.webkitMatchesSelector) {
						return el.webkitMatchesSelector(selector);
					}
				} catch(_) {
					return false;
				}
			}

			return false;
		}

		var _throttleTimeout;
		function _throttle(callback, ms) {
			return function () {
				if (!_throttleTimeout) {
					var args = arguments,
						_this = this;

					_throttleTimeout = setTimeout(function () {
						if (args.length === 1) {
							callback.call(_this, args[0]);
						} else {
							callback.apply(_this, args);
						}

						_throttleTimeout = void 0;
					}, ms);
				}
			};
		}

		function _cancelThrottle() {
			clearTimeout(_throttleTimeout);
			_throttleTimeout = void 0;
		}

		function _extend(dst, src) {
			if (dst && src) {
				for (var key in src) {
					if (src.hasOwnProperty(key)) {
						dst[key] = src[key];
					}
				}
			}

			return dst;
		}

		function _clone(el) {
			if (Polymer && Polymer.dom) {
				return Polymer.dom(el).cloneNode(true);
			}
			else if ($) {
				return $(el).clone(true)[0];
			}
			else {
				return el.cloneNode(true);
			}
		}

		function _saveInputCheckedState(root) {
			savedInputChecked.length = 0;

			var inputs = root.getElementsByTagName('input');
			var idx = inputs.length;

			while (idx--) {
				var el = inputs[idx];
				el.checked && savedInputChecked.push(el);
			}
		}

		function _nextTick(fn) {
			return setTimeout(fn, 0);
		}

		function _cancelNextTick(id) {
			return clearTimeout(id);
		}


		/**
		 * Returns the "bounding client rect" of given element
		 * @param  {HTMLElement} el                The element whose boundingClientRect is wanted
		 * @param  {[HTMLElement]} container       the parent the element will be placed in
		 * @param  {[Boolean]} adjustForTransform  Whether the rect should compensate for parent's transform
		 * (used for fixed positioning on el)
		 * @return {Object}                        The boundingClientRect of el
		 */
		function _getRect(el, container, adjustForTransform) {
			if (!el.getBoundingClientRect && el !== win) { return; }

			var elRect,
				top,
				left,
				bottom,
				right,
				height,
				width;

			if (el !== win) {
				elRect = el.getBoundingClientRect();
				top = elRect.top;
				left = elRect.left;
				bottom = elRect.bottom;
				right = elRect.right;
				height = elRect.height;
				width = elRect.width;
			} else {
				top = 0;
				left = 0;
				bottom = window.innerHeight;
				right = window.innerWidth;
				height = window.innerHeight;
				width = window.innerWidth;
			}

			if (adjustForTransform && el !== win) {
				// Adjust for translate()
				container = container || el.parentNode;

				// solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
				// Not needed on <= IE11
				if (!IE11OrLess) {
					do {
						if (container && container.getBoundingClientRect && _css(container, 'transform') !== 'none') {
							var containerRect = container.getBoundingClientRect();

							// Set relative to edges of padding box of container
							top -= containerRect.top + parseInt(_css(container, 'border-top-width'));
							left -= containerRect.left + parseInt(_css(container, 'border-left-width'));
							bottom = top + elRect.height;
							right = left + elRect.width;

							break;
						}
						/* jshint boss:true */
					} while (container = container.parentNode);
				}

				// Adjust for scale()
				var matrix = _matrix(el),
					scaleX = matrix && matrix.a,
					scaleY = matrix && matrix.d;

				if (matrix) {
					top /= scaleY;
					left /= scaleX;

					width /= scaleX;
					height /= scaleY;

					bottom = top + height;
					right = left + width;
				}
			}

			return {
				top: top,
				left: left,
				bottom: bottom,
				right: right,
				width: width,
				height: height
			};
		}


		/**
		 * Checks if a side of an element is scrolled past a side of it's parents
		 * @param  {HTMLElement}  el       The element who's side being scrolled out of view is in question
		 * @param  {String}       side     Side of the element in question ('top', 'left', 'right', 'bottom')
		 * @return {Boolean}               Whether the element is overflowing the viewport on the given side of it's parent
		 */
		function _isScrolledPast(el, side) {
			var parent = _getParentAutoScrollElement(parent, true),
				elSide = _getRect(el)[side];

			/* jshint boss:true */
			while (parent) {
				var parentSide = _getRect(parent)[side],
					visible;

				if (side === 'top' || side === 'left') {
					visible = elSide >= parentSide;
				} else {
					visible = elSide <= parentSide;
				}

				if (!visible) { return true; }

				if (parent === win) { break; }

				parent = _getParentAutoScrollElement(parent, false);
			}

			return false;
		}

		// Fixed #973:
		_on(document, 'touchmove', function(evt) {
			if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
				evt.preventDefault();
			}
		});


		// Export utils
		Sortable.utils = {
			on: _on,
			off: _off,
			css: _css,
			find: _find,
			is: function (el, selector) {
				return !!_closest(el, selector, el, false);
			},
			extend: _extend,
			throttle: _throttle,
			closest: _closest,
			toggleClass: _toggleClass,
			clone: _clone,
			index: _index,
			nextTick: _nextTick,
			cancelNextTick: _cancelNextTick,
			detectDirection: _detectDirection,
			getChild: _getChild
		};


		/**
		 * Create sortable instance
		 * @param {HTMLElement}  el
		 * @param {Object}      [options]
		 */
		Sortable.create = function (el, options) {
			return new Sortable(el, options);
		};


		// Export
		Sortable.version = '1.8.3';
		return Sortable;
	});
	});

	var Sortable$2 = /*#__PURE__*/Object.freeze({
		default: Sortable$1,
		__moduleExports: Sortable$1
	});

	var require$$0 = ( Sortable$2 && Sortable$1 ) || Sortable$2;

	var frappeDatatable_cjs = createCommonjsModule(function (module) {

	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var Sortable = _interopDefault(require$$0);

	function $(expr, con) {
	    return typeof expr === 'string' ?
	        (con || document).querySelector(expr) :
	        expr || null;
	}

	$.each = function (expr, con) {
	    return typeof expr === 'string' ?
	        Array.from((con || document).querySelectorAll(expr)) :
	        expr || null;
	};

	$.create = function (tag, o) {
	    var element = document.createElement(tag);

	    var loop = function ( i ) {
	        var val = o[i];

	        if (i === 'inside') {
	            $(val).appendChild(element);
	        } else
	        if (i === 'around') {
	            var ref = $(val);
	            ref.parentNode.insertBefore(element, ref);
	            element.appendChild(ref);
	        } else
	        if (i === 'styles') {
	            if (typeof val === 'object') {
	                Object.keys(val).map(function (prop) {
	                    element.style[prop] = val[prop];
	                });
	            }
	        } else
	        if (i in element) {
	            element[i] = val;
	        } else {
	            element.setAttribute(i, val);
	        }
	    };

	    for (var i in o) loop( i );

	    return element;
	};

	$.on = function (element, event, selector, callback) {
	    if (!callback) {
	        callback = selector;
	        $.bind(element, event, callback);
	    } else {
	        $.delegate(element, event, selector, callback);
	    }
	};

	$.off = function (element, event, handler) {
	    element.removeEventListener(event, handler);
	};

	$.bind = function (element, event, callback) {
	    event.split(/\s+/).forEach(function (event) {
	        element.addEventListener(event, callback);
	    });
	};

	$.delegate = function (element, event, selector, callback) {
	    element.addEventListener(event, function (e) {
	        var delegatedTarget = e.target.closest(selector);
	        if (delegatedTarget) {
	            e.delegatedTarget = delegatedTarget;
	            callback.call(this, e, delegatedTarget);
	        }
	    });
	};

	$.unbind = function (element, o) {
	    if (element) {
	        var loop = function ( event ) {
	            var callback = o[event];

	            event.split(/\s+/).forEach(function (event) {
	                element.removeEventListener(event, callback);
	            });
	        };

	        for (var event in o) loop( event );
	    }
	};

	$.fire = function (target, type, properties) {
	    var evt = document.createEvent('HTMLEvents');

	    evt.initEvent(type, true, true);

	    for (var j in properties) {
	        evt[j] = properties[j];
	    }

	    return target.dispatchEvent(evt);
	};

	$.data = function (element, attrs) { // eslint-disable-line
	    if (!attrs) {
	        return element.dataset;
	    }

	    for (var attr in attrs) {
	        element.dataset[attr] = attrs[attr];
	    }
	};

	$.style = function (elements, styleMap) { // eslint-disable-line

	    if (typeof styleMap === 'string') {
	        return $.getStyle(elements, styleMap);
	    }

	    if (!Array.isArray(elements)) {
	        elements = [elements];
	    }

	    elements.map(function (element) {
	        for (var prop in styleMap) {
	            element.style[prop] = styleMap[prop];
	        }
	    });
	};

	$.removeStyle = function (elements, styleProps) {
	    if (!Array.isArray(elements)) {
	        elements = [elements];
	    }

	    if (!Array.isArray(styleProps)) {
	        styleProps = [styleProps];
	    }

	    elements.map(function (element) {
	        for (var i = 0, list = styleProps; i < list.length; i += 1) {
	            var prop = list[i];

	          element.style[prop] = '';
	        }
	    });
	};

	$.getStyle = function (element, prop) {
	    if (!prop) {
	        return getComputedStyle(element);
	    }

	    var val = getComputedStyle(element)[prop];

	    if (['width', 'height'].includes(prop)) {
	        val = parseFloat(val);
	    }

	    return val;
	};

	$.closest = function (selector, element) {
	    if (!element) { return null; }

	    if (element.matches(selector)) {
	        return element;
	    }

	    return $.closest(selector, element.parentNode);
	};

	$.inViewport = function (el, parentEl) {
	    var ref = el.getBoundingClientRect();
	    var top = ref.top;
	    var left = ref.left;
	    var bottom = ref.bottom;
	    var right = ref.right;
	    var ref$1 = parentEl.getBoundingClientRect();
	    var pTop = ref$1.top;
	    var pLeft = ref$1.left;
	    var pBottom = ref$1.bottom;
	    var pRight = ref$1.right;

	    return top >= pTop && left >= pLeft && bottom <= pBottom && right <= pRight;
	};

	$.scrollTop = function scrollTop(element, pixels) {
	    requestAnimationFrame(function () {
	        element.scrollTop = pixels;
	    });
	};

	$.scrollbarSize = function scrollbarSize() {
	    if (!$.scrollBarSizeValue) {
	        $.scrollBarSizeValue = getScrollBarSize();
	    }
	    return $.scrollBarSizeValue;
	};

	function getScrollBarSize() {
	    // assume scrollbar width and height would be the same

	    // Create the measurement node
	    var scrollDiv = document.createElement('div');
	    $.style(scrollDiv, {
	        width: '100px',
	        height: '100px',
	        overflow: 'scroll',
	        position: 'absolute',
	        top: '-9999px'
	    });
	    document.body.appendChild(scrollDiv);

	    // Get the scrollbar width
	    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;

	    // Delete the DIV
	    document.body.removeChild(scrollDiv);

	    return scrollbarWidth;
	}

	$.hasVerticalOverflow = function (element) {
	    return element.scrollHeight > element.offsetHeight + 10;
	};

	$.hasHorizontalOverflow = function (element) {
	    return element.scrollWidth > element.offsetWidth + 10;
	};

	$.measureTextWidth = function (text) {
	    var div = document.createElement('div');
	    div.style.position = 'absolute';
	    div.style.visibility = 'hidden';
	    div.style.height = 'auto';
	    div.style.width = 'auto';
	    div.style.whiteSpace = 'nowrap';
	    div.innerText = text;
	    document.body.appendChild(div);
	    return div.clientWidth + 1;
	};

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject;

	var commonjsGlobal$1 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal$1 == 'object' && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;

	var _freeGlobal = freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = _freeGlobal || freeSelf || Function('return this')();

	var _root = root;

	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return _root.Date.now();
	};

	var now_1 = now;

	/** Built-in value references. */
	var Symbol = _root.Symbol;

	var _Symbol = Symbol;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	var _objectToString = objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? _getRawTag(value)
	    : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
	}

	var isSymbol_1 = isSymbol;

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol_1(value)) {
	    return NAN;
	  }
	  if (isObject_1(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject_1(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	var toNumber_1 = toNumber;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max,
	    nativeMin = Math.min;

	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  wait = toNumber_1(wait) || 0;
	  if (isObject_1(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;

	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }

	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }

	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        timeWaiting = wait - timeSinceLastCall;

	    return maxing
	      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
	      : timeWaiting;
	  }

	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;

	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }

	  function timerExpired() {
	    var time = now_1();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }

	  function trailingEdge(time) {
	    timerId = undefined;

	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }

	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }

	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now_1());
	  }

	  function debounced() {
	    var time = now_1(),
	        isInvoking = shouldInvoke(time);

	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;

	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        clearTimeout(timerId);
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}

	var debounce_1 = debounce;

	/** Error message constants. */
	var FUNC_ERROR_TEXT$1 = 'Expected a function';

	/**
	 * Creates a throttled function that only invokes `func` at most once per
	 * every `wait` milliseconds. The throttled function comes with a `cancel`
	 * method to cancel delayed `func` invocations and a `flush` method to
	 * immediately invoke them. Provide `options` to indicate whether `func`
	 * should be invoked on the leading and/or trailing edge of the `wait`
	 * timeout. The `func` is invoked with the last arguments provided to the
	 * throttled function. Subsequent calls to the throttled function return the
	 * result of the last `func` invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the throttled function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.throttle` and `_.debounce`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to throttle.
	 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=true]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new throttled function.
	 * @example
	 *
	 * // Avoid excessively updating the position while scrolling.
	 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	 *
	 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	 * jQuery(element).on('click', throttled);
	 *
	 * // Cancel the trailing throttled invocation.
	 * jQuery(window).on('popstate', throttled.cancel);
	 */
	function throttle(func, wait, options) {
	  var leading = true,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$1);
	  }
	  if (isObject_1(options)) {
	    leading = 'leading' in options ? !!options.leading : leading;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	  return debounce_1(func, wait, {
	    'leading': leading,
	    'maxWait': wait,
	    'trailing': trailing
	  });
	}

	var throttle_1 = throttle;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = _root['__core-js_shared__'];

	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	/* Built-in method references that are verified to be native. */
	var nativeCreate = _getNative(Object, 'create');

	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;

	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;

	var _ListCache = ListCache;

	/* Built-in method references that are verified to be native. */
	var Map = _getNative(_root, 'Map');

	var _Map = Map;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash,
	    'map': new (_Map || _ListCache),
	    'string': new _Hash
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;

	var _MapCache = MapCache;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED$2);
	  return this;
	}

	var _setCacheAdd = setCacheAdd;

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	var _setCacheHas = setCacheHas;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new _MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
	SetCache.prototype.has = _setCacheHas;

	var _SetCache = SetCache;

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	var _baseFindIndex = baseFindIndex;

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	var _baseIsNaN = baseIsNaN;

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	var _strictIndexOf = strictIndexOf;

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? _strictIndexOf(array, value, fromIndex)
	    : _baseFindIndex(array, _baseIsNaN, fromIndex);
	}

	var _baseIndexOf = baseIndexOf;

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && _baseIndexOf(array, value, 0) > -1;
	}

	var _arrayIncludes = arrayIncludes;

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	var _arrayIncludesWith = arrayIncludesWith;

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	var _cacheHas = cacheHas;

	/* Built-in method references that are verified to be native. */
	var Set = _getNative(_root, 'Set');

	var _Set = Set;

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	var noop_1 = noop;

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	var _setToArray = setToArray;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */
	var createSet = !(_Set && (1 / _setToArray(new _Set([,-0]))[1]) == INFINITY) ? noop_1 : function(values) {
	  return new _Set(values);
	};

	var _createSet = createSet;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = _arrayIncludes,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = _arrayIncludesWith;
	  }
	  else if (length >= LARGE_ARRAY_SIZE) {
	    var set = iteratee ? null : _createSet(array);
	    if (set) {
	      return _setToArray(set);
	    }
	    isCommon = false;
	    includes = _cacheHas;
	    seen = new _SetCache;
	  }
	  else {
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	var _baseUniq = baseUniq;

	/**
	 * Creates a duplicate-free version of an array, using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons, in which only the first occurrence of each element
	 * is kept. The order of result values is determined by the order they occur
	 * in the array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @returns {Array} Returns the new duplicate free array.
	 * @example
	 *
	 * _.uniq([2, 1, 2]);
	 * // => [2, 1]
	 */
	function uniq(array) {
	  return (array && array.length) ? _baseUniq(array) : [];
	}

	var uniq_1 = uniq;

	function camelCaseToDash(str) {
	    return str.replace(/([A-Z])/g, function (g) { return ("-" + (g[0].toLowerCase())); });
	}

	function makeDataAttributeString(props) {
	    var keys = Object.keys(props);

	    return keys
	        .map(function (key) {
	            var _key = camelCaseToDash(key);
	            var val = props[key];

	            if (val === undefined) { return ''; }
	            return ("data-" + _key + "=\"" + val + "\" ");
	        })
	        .join('')
	        .trim();
	}

	function copyTextToClipboard(text) {
	    // https://stackoverflow.com/a/30810322/5353542
	    var textArea = document.createElement('textarea');

	    //
	    // *** This styling is an extra step which is likely not required. ***
	    //
	    // Why is it here? To ensure:
	    // 1. the element is able to have focus and selection.
	    // 2. if element was to flash render it has minimal visual impact.
	    // 3. less flakyness with selection and copying which **might** occur if
	    //    the textarea element is not visible.
	    //
	    // The likelihood is the element won't even render, not even a flash,
	    // so some of these are just precautions. However in IE the element
	    // is visible whilst the popup box asking the user for permission for
	    // the web page to copy to the clipboard.
	    //

	    // Place in top-left corner of screen regardless of scroll position.
	    textArea.style.position = 'fixed';
	    textArea.style.top = 0;
	    textArea.style.left = 0;

	    // Ensure it has a small width and height. Setting to 1px / 1em
	    // doesn't work as this gives a negative w/h on some browsers.
	    textArea.style.width = '2em';
	    textArea.style.height = '2em';

	    // We don't need padding, reducing the size if it does flash render.
	    textArea.style.padding = 0;

	    // Clean up any borders.
	    textArea.style.border = 'none';
	    textArea.style.outline = 'none';
	    textArea.style.boxShadow = 'none';

	    // Avoid flash of white box if rendered for any reason.
	    textArea.style.background = 'transparent';

	    textArea.value = text;

	    document.body.appendChild(textArea);

	    textArea.select();

	    try {
	        document.execCommand('copy');
	    } catch (err) {
	        console.log('Oops, unable to copy');
	    }

	    document.body.removeChild(textArea);
	}

	function isNumeric(val) {
	    return !isNaN(val);
	}

	var throttle$1 = throttle_1;

	var debounce$1 = debounce_1;

	function nextTick(fn, context) {
	    if ( context === void 0 ) context = null;

	    return function () {
	        var args = [], len = arguments.length;
	        while ( len-- ) args[ len ] = arguments[ len ];

	        return new Promise(function (resolve) {
	            var execute = function () {
	                var out = fn.apply(context, args);
	                resolve(out);
	            };
	            setTimeout(execute);
	        });
	    };
	}
	function linkProperties(target, source, properties) {
	    var props = properties.reduce(function (acc, prop) {
	        acc[prop] = {
	            get: function get() {
	                return source[prop];
	            }
	        };
	        return acc;
	    }, {});
	    Object.defineProperties(target, props);
	}
	function isSet(val) {
	    return val !== undefined || val !== null;
	}

	function notSet(val) {
	    return !isSet(val);
	}

	function isNumber(val) {
	    return !isNaN(val);
	}

	function ensureArray(val) {
	    if (!Array.isArray(val)) {
	        return [val];
	    }
	    return val;
	}

	function uniq$1(arr) {
	    return uniq_1(arr);
	}

	function numberSortAsc(a, b) {
	    return a - b;
	}
	function stripHTML(html) {
	    return html.replace(/<[^>]*>/g, '');
	}

	class DataManager {
	    constructor(options) {
	        this.options = options;
	        this.sortRows = nextTick(this.sortRows, this);
	        this.switchColumn = nextTick(this.switchColumn, this);
	        this.removeColumn = nextTick(this.removeColumn, this);
	        this.options.filterRows = nextTick(this.options.filterRows, this);
	    }

	    init(data, columns) {
	        if (!data) {
	            data = this.options.data;
	        }
	        if (columns) {
	            this.options.columns = columns;
	        }

	        this.data = data;

	        this.rowCount = 0;
	        this.columns = [];
	        this.rows = [];

	        this.prepareColumns();
	        this.prepareRows();
	        this.prepareTreeRows();
	        this.prepareRowView();
	        this.prepareNumericColumns();
	    }

	    // computed property
	    get currentSort() {
	        var col = this.columns.find(function (col) { return col.sortOrder !== 'none'; });
	        return col || {
	            colIndex: -1,
	            sortOrder: 'none'
	        };
	    }

	    prepareColumns() {
	        this.columns = [];
	        this.validateColumns();
	        this.prepareDefaultColumns();
	        this.prepareHeader();
	    }

	    prepareDefaultColumns() {
	        if (this.options.checkboxColumn && !this.hasColumnById('_checkbox')) {
	            var cell = {
	                id: '_checkbox',
	                content: this.getCheckboxHTML(),
	                editable: false,
	                resizable: false,
	                sortable: false,
	                focusable: false,
	                dropdown: false,
	                width: 32
	            };
	            this.columns.push(cell);
	        }

	        if (this.options.serialNoColumn && !this.hasColumnById('_rowIndex')) {
	            var cell$1 = {
	                id: '_rowIndex',
	                content: '',
	                align: 'center',
	                editable: false,
	                resizable: false,
	                focusable: false,
	                dropdown: false
	            };

	            this.columns.push(cell$1);
	        }
	    }

	    prepareHeader() {
	        var this$1 = this;

	        var columns = this.columns.concat(this.options.columns);
	        var baseCell = {
	            isHeader: 1,
	            editable: true,
	            sortable: true,
	            resizable: true,
	            focusable: true,
	            dropdown: true,
	            width: null,
	            format: function (value) {
	                if (value === null || value === undefined) {
	                    return '';
	                }
	                return value + '';
	            }
	        };

	        this.columns = columns
	            .map(function (cell, i) { return this$1.prepareCell(cell, i); })
	            .map(function (col) { return Object.assign({}, baseCell, col); })
	            .map(function (col) {
	                col.content = col.content || col.name || '';
	                col.id = col.id || col.content;
	                return col;
	            });
	    }

	    prepareCell(content, i) {
	        var cell = {
	            content: '',
	            sortOrder: 'none',
	            colIndex: i,
	            column: this.columns[i]
	        };

	        if (content !== null && typeof content === 'object') {
	            // passed as column/header
	            Object.assign(cell, content);
	        } else {
	            cell.content = content;
	        }

	        return cell;
	    }

	    prepareNumericColumns() {
	        var row0 = this.getRow(0);
	        if (!row0) { return; }
	        this.columns = this.columns.map(function (column, i) {

	            var cellValue = row0[i].content;
	            if (!column.align && isNumeric(cellValue)) {
	                column.align = 'right';
	            }

	            return column;
	        });
	    }

	    prepareRows() {
	        var this$1 = this;

	        this.validateData(this.data);

	        this.rows = this.data.map(function (d, i) {
	            var index = this$1._getNextRowCount();

	            var row = [];
	            var meta = {
	                rowIndex: index
	            };

	            if (Array.isArray(d)) {
	                // row is an array
	                if (this$1.options.checkboxColumn) {
	                    row.push(this$1.getCheckboxHTML());
	                }
	                if (this$1.options.serialNoColumn) {
	                    row.push((index + 1) + '');
	                }
	                row = row.concat(d);

	                while (row.length < this$1.columns.length) {
	                    row.push('');
	                }

	            } else {
	                // row is an object
	                for (var i$1 = 0, list = this$1.columns; i$1 < list.length; i$1 += 1) {
	                    var col = list[i$1];

	                  if (col.id === '_checkbox') {
	                        row.push(this$1.getCheckboxHTML());
	                    } else if (col.id === '_rowIndex') {
	                        row.push((index + 1) + '');
	                    } else {
	                        row.push(d[col.id]);
	                    }
	                }

	                meta.indent = d.indent || 0;
	            }

	            return this$1.prepareRow(row, meta);
	        });
	    }

	    prepareTreeRows() {
	        var this$1 = this;

	        this.rows.forEach(function (row, i) {
	            if (isNumber(row.meta.indent)) {
	                // if (i === 36) debugger;
	                var nextRow = this$1.getRow(i + 1);
	                row.meta.isLeaf = !nextRow ||
	                    notSet(nextRow.meta.indent) ||
	                    nextRow.meta.indent <= row.meta.indent;
	                row.meta.isTreeNodeClose = false;
	            }
	        });
	    }

	    prepareRowView() {
	        // This is order in which rows will be rendered in the table.
	        // When sorting happens, only this.rowViewOrder will change
	        // and not the original this.rows
	        this.rowViewOrder = this.rows.map(function (row) { return row.meta.rowIndex; });
	    }

	    prepareRow(row, meta) {
	        var this$1 = this;

	        var baseRowCell = {
	            rowIndex: meta.rowIndex,
	            indent: meta.indent
	        };

	        row = row
	            .map(function (cell, i) { return this$1.prepareCell(cell, i); })
	            .map(function (cell) { return Object.assign({}, baseRowCell, cell); });

	        // monkey patched in array object
	        row.meta = meta;
	        return row;
	    }

	    validateColumns() {
	        var columns = this.options.columns;
	        if (!Array.isArray(columns)) {
	            throw new DataError('`columns` must be an array');
	        }

	        columns.forEach(function (column, i) {
	            if (typeof column !== 'string' && typeof column !== 'object') {
	                throw new DataError(("column \"" + i + "\" must be a string or an object"));
	            }
	        });
	    }

	    validateData(data) {
	        if (Array.isArray(data) &&
	            (data.length === 0 || Array.isArray(data[0]) || typeof data[0] === 'object')) {
	            return true;
	        }
	        throw new DataError('`data` must be an array of arrays or objects');
	    }

	    appendRows(rows) {
	        var ref;

	        this.validateData(rows);

	        (ref = this.rows).push.apply(ref, this.prepareRows(rows));
	    }

	    sortRows(colIndex, sortOrder) {
	        if ( sortOrder === void 0 ) sortOrder = 'none';

	        colIndex = +colIndex;

	        // reset sortOrder and update for colIndex
	        this.getColumns()
	            .map(function (col) {
	                if (col.colIndex === colIndex) {
	                    col.sortOrder = sortOrder;
	                } else {
	                    col.sortOrder = 'none';
	                }
	            });

	        this._sortRows(colIndex, sortOrder);
	    }

	    _sortRows(colIndex, sortOrder) {
	        var this$1 = this;


	        if (this.currentSort.colIndex === colIndex) {
	            // reverse the array if only sortOrder changed
	            if (
	                (this.currentSort.sortOrder === 'asc' && sortOrder === 'desc') ||
	                (this.currentSort.sortOrder === 'desc' && sortOrder === 'asc')
	            ) {
	                this.reverseArray(this.rowViewOrder);
	                this.currentSort.sortOrder = sortOrder;
	                return;
	            }
	        }

	        this.rowViewOrder.sort(function (a, b) {
	            var aIndex = a;
	            var bIndex = b;

	            var aContent = this$1.getCell(colIndex, a).content;
	            var bContent = this$1.getCell(colIndex, b).content;
	            aContent = aContent == null ? '' : aContent;
	            bContent = bContent == null ? '' : bContent;

	            if (sortOrder === 'none') {
	                return aIndex - bIndex;
	            } else if (sortOrder === 'asc') {
	                if (aContent < bContent) { return -1; }
	                if (aContent > bContent) { return 1; }
	                if (aContent === bContent) { return 0; }
	            } else if (sortOrder === 'desc') {
	                if (aContent < bContent) { return 1; }
	                if (aContent > bContent) { return -1; }
	                if (aContent === bContent) { return 0; }
	            }
	            return 0;
	        });

	        if (this.hasColumnById('_rowIndex')) {
	            // update row index
	            var srNoColIndex = this.getColumnIndexById('_rowIndex');
	            this.rows.forEach(function (row, index) {
	                var viewIndex = this$1.rowViewOrder.indexOf(index);
	                var cell = row[srNoColIndex];
	                cell.content = (viewIndex + 1) + '';
	            });
	        }
	    }

	    reverseArray(array) {
	        var left = null;
	        var right = null;
	        var length = array.length;

	        for (left = 0, right = length - 1; left < right; left += 1, right -= 1) {
	            var temporary = array[left];

	            array[left] = array[right];
	            array[right] = temporary;
	        }
	    }

	    switchColumn(index1, index2) {
	        // update columns
	        var temp = this.columns[index1];
	        this.columns[index1] = this.columns[index2];
	        this.columns[index2] = temp;

	        this.columns[index1].colIndex = index1;
	        this.columns[index2].colIndex = index2;

	        // update rows
	        this.rows.forEach(function (row) {
	            var newCell1 = Object.assign({}, row[index1], {
	                colIndex: index2
	            });
	            var newCell2 = Object.assign({}, row[index2], {
	                colIndex: index1
	            });

	            row[index2] = newCell1;
	            row[index1] = newCell2;
	        });
	    }

	    removeColumn(index) {
	        index = +index;
	        var filter = function (cell) { return cell.colIndex !== index; };
	        var map = function (cell, i) { return Object.assign({}, cell, {
	            colIndex: i
	        }); };
	        // update columns
	        this.columns = this.columns
	            .filter(filter)
	            .map(map);

	        // update rows
	        this.rows.forEach(function (row) {
	            // remove cell
	            row.splice(index, 1);
	            // update colIndex
	            row.forEach(function (cell, i) {
	                cell.colIndex = i;
	            });
	        });
	    }

	    updateRow(row, rowIndex) {
	        if (row.length < this.columns.length) {
	            if (this.hasColumnById('_rowIndex')) {
	                var val = (rowIndex + 1) + '';

	                row = [val].concat(row);
	            }

	            if (this.hasColumnById('_checkbox')) {
	                var val$1 = '<input type="checkbox" />';

	                row = [val$1].concat(row);
	            }
	        }

	        var _row = this.prepareRow(row, {rowIndex: rowIndex});
	        var index = this.rows.findIndex(function (row) { return row[0].rowIndex === rowIndex; });
	        this.rows[index] = _row;

	        return _row;
	    }

	    updateCell(colIndex, rowIndex, options) {
	        var cell;
	        if (typeof colIndex === 'object') {
	            // cell object was passed,
	            // must have colIndex, rowIndex
	            cell = colIndex;
	            colIndex = cell.colIndex;
	            rowIndex = cell.rowIndex;
	            // the object passed must be merged with original cell
	            options = cell;
	        }
	        cell = this.getCell(colIndex, rowIndex);

	        // mutate object directly
	        for (var key in options) {
	            var newVal = options[key];
	            if (newVal !== undefined) {
	                cell[key] = newVal;
	            }
	        }

	        return cell;
	    }

	    updateColumn(colIndex, keyValPairs) {
	        var column = this.getColumn(colIndex);
	        for (var key in keyValPairs) {
	            var newVal = keyValPairs[key];
	            if (newVal !== undefined) {
	                column[key] = newVal;
	            }
	        }
	        return column;
	    }

	    filterRows(filters) {
	        var this$1 = this;

	        return this.options.filterRows(this.rows, filters)
	            .then(function (result) {
	                if (!result) {
	                    result = this$1.getAllRowIndices();
	                }

	                if (!result.then) {
	                    result = Promise.resolve(result);
	                }

	                return result.then(function (rowsToShow) {
	                    this$1._filteredRows = rowsToShow;

	                    var rowsToHide = this$1.getAllRowIndices()
	                        .filter(function (index) { return !rowsToShow.includes(index); });

	                    return {
	                        rowsToHide: rowsToHide,
	                        rowsToShow: rowsToShow
	                    };
	                });
	            });
	    }

	    getFilteredRowIndices() {
	        return this._filteredRows || this.getAllRowIndices();
	    }

	    getAllRowIndices() {
	        return this.rows.map(function (row) { return row.meta.rowIndex; });
	    }

	    getRowCount() {
	        return this.rowCount;
	    }

	    _getNextRowCount() {
	        var val = this.rowCount;

	        this.rowCount++;
	        return val;
	    }

	    getRows(start, end) {
	        return this.rows.slice(start, end);
	    }

	    getRowsForView(start, end) {
	        var this$1 = this;

	        var rows = this.rowViewOrder.map(function (i) { return this$1.rows[i]; });
	        return rows.slice(start, end);
	    }

	    getColumns(skipStandardColumns) {
	        var columns = this.columns;

	        if (skipStandardColumns) {
	            columns = columns.slice(this.getStandardColumnCount());
	        }

	        return columns;
	    }

	    getStandardColumnCount() {
	        if (this.options.checkboxColumn && this.options.serialNoColumn) {
	            return 2;
	        }

	        if (this.options.checkboxColumn || this.options.serialNoColumn) {
	            return 1;
	        }

	        return 0;
	    }

	    getColumnCount(skipStandardColumns) {
	        var val = this.columns.length;

	        if (skipStandardColumns) {
	            val = val - this.getStandardColumnCount();
	        }

	        return val;
	    }

	    getColumn(colIndex) {
	        colIndex = +colIndex;

	        if (colIndex < 0) {
	            // negative indexes
	            colIndex = this.columns.length + colIndex;
	        }

	        return this.columns.find(function (col) { return col.colIndex === colIndex; });
	    }

	    getColumnById(id) {
	        return this.columns.find(function (col) { return col.id === id; });
	    }

	    getRow(rowIndex) {
	        rowIndex = +rowIndex;
	        return this.rows[rowIndex];
	    }

	    getCell(colIndex, rowIndex) {
	        rowIndex = +rowIndex;
	        colIndex = +colIndex;
	        return this.getRow(rowIndex)[colIndex];
	    }

	    getChildren(parentRowIndex) {
	        parentRowIndex = +parentRowIndex;
	        var parentIndent = this.getRow(parentRowIndex).meta.indent;
	        var out = [];

	        for (var i = parentRowIndex + 1; i < this.rowCount; i++) {
	            var row = this.getRow(i);
	            if (isNaN(row.meta.indent)) { continue; }

	            if (row.meta.indent > parentIndent) {
	                out.push(i);
	            }

	            if (row.meta.indent === parentIndent) {
	                break;
	            }
	        }

	        return out;
	    }

	    getImmediateChildren(parentRowIndex) {
	        parentRowIndex = +parentRowIndex;
	        var parentIndent = this.getRow(parentRowIndex).meta.indent;
	        var out = [];
	        var childIndent = parentIndent + 1;

	        for (var i = parentRowIndex + 1; i < this.rowCount; i++) {
	            var row = this.getRow(i);
	            if (isNaN(row.meta.indent) || row.meta.indent > childIndent) { continue; }

	            if (row.meta.indent === childIndent) {
	                out.push(i);
	            }

	            if (row.meta.indent === parentIndent) {
	                break;
	            }
	        }

	        return out;
	    }

	    get() {
	        return {
	            columns: this.columns,
	            rows: this.rows
	        };
	    }

	    /**
	     * Returns the original data which was passed
	     * based on rowIndex
	     * @param {Number} rowIndex
	     * @returns Array|Object
	     * @memberof DataManager
	     */
	    getData(rowIndex) {
	        return this.data[rowIndex];
	    }

	    hasColumn(name) {
	        return Boolean(this.columns.find(function (col) { return col.content === name; }));
	    }

	    hasColumnById(id) {
	        return Boolean(this.columns.find(function (col) { return col.id === id; }));
	    }

	    getColumnIndex(name) {
	        return this.columns.findIndex(function (col) { return col.content === name; });
	    }

	    getColumnIndexById(id) {
	        return this.columns.findIndex(function (col) { return col.id === id; });
	    }

	    getCheckboxHTML() {
	        return '<input type="checkbox" />';
	    }
	}

	// Custom Errors
	class DataError extends TypeError {}

	/* eslint-disable max-len */

	// Icons from https://feathericons.com/

	var icons = {
	    chevronDown: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg>',
	    chevronRight: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline></svg>'
	};

	class CellManager {
	    constructor(instance) {
	        this.instance = instance;
	        linkProperties(this, this.instance, [
	            'wrapper',
	            'options',
	            'style',
	            'header',
	            'bodyScrollable',
	            'columnmanager',
	            'rowmanager',
	            'datamanager',
	            'keyboard'
	        ]);

	        this.bindEvents();
	    }

	    bindEvents() {
	        this.bindFocusCell();
	        this.bindEditCell();
	        this.bindKeyboardSelection();
	        this.bindCopyCellContents();
	        this.bindMouseEvents();
	        this.bindTreeEvents();
	    }

	    bindFocusCell() {
	        this.bindKeyboardNav();
	    }

	    bindEditCell() {
	        var this$1 = this;

	        this.$editingCell = null;

	        $.on(this.bodyScrollable, 'dblclick', '.dt-cell', function (e, cell) {
	            this$1.activateEditing(cell);
	        });

	        this.keyboard.on('enter', function () {
	            if (this$1.$focusedCell && !this$1.$editingCell) {
	                // enter keypress on focused cell
	                this$1.activateEditing(this$1.$focusedCell);
	            } else if (this$1.$editingCell) {
	                // enter keypress on editing cell
	                this$1.deactivateEditing();
	            }
	        });
	    }

	    bindKeyboardNav() {
	        var this$1 = this;

	        var focusLastCell = function (direction) {
	            if (!this$1.$focusedCell || this$1.$editingCell) {
	                return false;
	            }

	            var $cell = this$1.$focusedCell;
	            var ref = $.data($cell);
	            var rowIndex = ref.rowIndex;
	            var colIndex = ref.colIndex;

	            if (direction === 'left') {
	                $cell = this$1.getLeftMostCell$(rowIndex);
	            } else if (direction === 'right') {
	                $cell = this$1.getRightMostCell$(rowIndex);
	            } else if (direction === 'up') {
	                $cell = this$1.getTopMostCell$(colIndex);
	            } else if (direction === 'down') {
	                $cell = this$1.getBottomMostCell$(colIndex);
	            }

	            this$1.focusCell($cell);
	            return true;
	        };

	        ['left', 'right', 'up', 'down', 'tab', 'shift+tab']
	            .map(function (direction) { return this$1.keyboard.on(direction, function () { return this$1.focusCellInDirection(direction); }); });

	        ['left', 'right', 'up', 'down']
	            .map(function (direction) { return this$1.keyboard.on(("ctrl+" + direction), function () { return focusLastCell(direction); }); });

	        this.keyboard.on('esc', function () {
	            this$1.deactivateEditing(false);
	            this$1.columnmanager.toggleFilter(false);
	        });

	        if (this.options.inlineFilters) {
	            this.keyboard.on('ctrl+f', function (e) {
	                var $cell = $.closest('.dt-cell', e.target);
	                var ref = $.data($cell);
	                var colIndex = ref.colIndex;

	                this$1.activateFilter(colIndex);
	                return true;
	            });

	            $.on(this.header, 'focusin', '.dt-filter', function () {
	                this$1.unfocusCell(this$1.$focusedCell);
	            });
	        }
	    }

	    bindKeyboardSelection() {
	        var this$1 = this;

	        var getNextSelectionCursor = function (direction) {
	            var $selectionCursor = this$1.getSelectionCursor();

	            if (direction === 'left') {
	                $selectionCursor = this$1.getLeftCell$($selectionCursor);
	            } else if (direction === 'right') {
	                $selectionCursor = this$1.getRightCell$($selectionCursor);
	            } else if (direction === 'up') {
	                $selectionCursor = this$1.getAboveCell$($selectionCursor);
	            } else if (direction === 'down') {
	                $selectionCursor = this$1.getBelowCell$($selectionCursor);
	            }

	            return $selectionCursor;
	        };

	        ['left', 'right', 'up', 'down']
	            .map(function (direction) { return this$1.keyboard.on(("shift+" + direction), function () { return this$1.selectArea(getNextSelectionCursor(direction)); }); });
	    }

	    bindCopyCellContents() {
	        var this$1 = this;

	        this.keyboard.on('ctrl+c', function () {
	            var noOfCellsCopied = this$1.copyCellContents(this$1.$focusedCell, this$1.$selectionCursor);
	            var message = noOfCellsCopied + " cell" + (noOfCellsCopied > 1 ? 's' : '') + " copied";
	            if (noOfCellsCopied) {
	                this$1.instance.showToastMessage(message, 2);
	            }
	        });

	        if (this.options.pasteFromClipboard) {
	            this.keyboard.on('ctrl+v', function (e) {
	                // hack
	                // https://stackoverflow.com/a/2177059/5353542
	                this$1.instance.pasteTarget.focus();

	                setTimeout(function () {
	                    var data = this$1.instance.pasteTarget.value;
	                    this$1.instance.pasteTarget.value = '';
	                    this$1.pasteContentInCell(data);
	                }, 10);

	                return false;
	            });
	        }
	    }

	    bindMouseEvents() {
	        var this$1 = this;

	        var mouseDown = null;

	        $.on(this.bodyScrollable, 'mousedown', '.dt-cell', function (e) {
	            mouseDown = true;
	            this$1.focusCell($(e.delegatedTarget));
	        });

	        $.on(this.bodyScrollable, 'mouseup', function () {
	            mouseDown = false;
	        });

	        var selectArea = function (e) {
	            if (!mouseDown) { return; }
	            this$1.selectArea($(e.delegatedTarget));
	        };

	        $.on(this.bodyScrollable, 'mousemove', '.dt-cell', throttle$1(selectArea, 50));
	    }

	    bindTreeEvents() {
	        var this$1 = this;

	        $.on(this.bodyScrollable, 'click', '.dt-tree-node__toggle', function (e, $toggle) {
	            var $cell = $.closest('.dt-cell', $toggle);
	            var ref = $.data($cell);
	            var rowIndex = ref.rowIndex;

	            if ($cell.classList.contains('dt-cell--tree-close')) {
	                this$1.rowmanager.openSingleNode(rowIndex);
	            } else {
	                this$1.rowmanager.closeSingleNode(rowIndex);
	            }
	        });
	    }

	    focusCell($cell, ref) {
	        if ( ref === void 0 ) ref = {};
	        var skipClearSelection = ref.skipClearSelection; if ( skipClearSelection === void 0 ) skipClearSelection = 0;
	        var skipDOMFocus = ref.skipDOMFocus; if ( skipDOMFocus === void 0 ) skipDOMFocus = 0;
	        var skipScrollToCell = ref.skipScrollToCell; if ( skipScrollToCell === void 0 ) skipScrollToCell = 0;

	        if (!$cell) { return; }

	        // don't focus if already editing cell
	        if ($cell === this.$editingCell) { return; }

	        var ref$1 = $.data($cell);
	        var colIndex = ref$1.colIndex;
	        var isHeader = ref$1.isHeader;
	        if (isHeader) {
	            return;
	        }

	        var column = this.columnmanager.getColumn(colIndex);
	        if (column.focusable === false) {
	            return;
	        }

	        if (!skipScrollToCell) {
	            this.scrollToCell($cell);
	        }

	        this.deactivateEditing();
	        if (!skipClearSelection) {
	            this.clearSelection();
	        }

	        if (this.$focusedCell) {
	            this.$focusedCell.classList.remove('dt-cell--focus');
	        }

	        this.$focusedCell = $cell;
	        $cell.classList.add('dt-cell--focus');

	        if (!skipDOMFocus) {
	            // so that keyboard nav works
	            $cell.focus();
	        }

	        this.highlightRowColumnHeader($cell);
	    }

	    unfocusCell($cell) {
	        if (!$cell) { return; }

	        // remove cell border
	        $cell.classList.remove('dt-cell--focus');
	        this.$focusedCell = null;

	        // reset header background
	        if (this.lastHeaders) {
	            this.lastHeaders.forEach(function (header) { return header && header.classList.remove('dt-cell--highlight'); });
	        }
	    }

	    highlightRowColumnHeader($cell) {
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;

	        var srNoColIndex = this.datamanager.getColumnIndexById('_rowIndex');
	        var colHeaderSelector = ".dt-cell--header-" + colIndex;
	        var rowHeaderSelector = ".dt-cell--" + srNoColIndex + "-" + rowIndex;

	        if (this.lastHeaders) {
	            this.lastHeaders.forEach(function (header) { return header && header.classList.remove('dt-cell--highlight'); });
	        }

	        var colHeader = $(colHeaderSelector, this.wrapper);
	        var rowHeader = $(rowHeaderSelector, this.wrapper);

	        this.lastHeaders = [colHeader, rowHeader];
	        this.lastHeaders.forEach(function (header) { return header && header.classList.add('dt-cell--highlight'); });
	    }

	    selectAreaOnClusterChanged() {
	        if (!(this.$focusedCell && this.$selectionCursor)) { return; }
	        var ref = $.data(this.$selectionCursor);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;
	        var $cell = this.getCell$(colIndex, rowIndex);

	        if (!$cell || $cell === this.$selectionCursor) { return; }

	        // selectArea needs $focusedCell
	        var fCell = $.data(this.$focusedCell);
	        this.$focusedCell = this.getCell$(fCell.colIndex, fCell.rowIndex);

	        this.selectArea($cell);
	    }

	    focusCellOnClusterChanged() {
	        if (!this.$focusedCell) { return; }

	        var ref = $.data(this.$focusedCell);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;
	        var $cell = this.getCell$(colIndex, rowIndex);

	        if (!$cell) { return; }
	        // this function is called after hyperlist renders the rows after scroll,
	        // focusCell calls clearSelection which resets the area selection
	        // so a flag to skip it
	        // we also skip DOM focus and scroll to cell
	        // because it fights with the user scroll
	        this.focusCell($cell, {
	            skipClearSelection: 1,
	            skipDOMFocus: 1,
	            skipScrollToCell: 1
	        });
	    }

	    selectArea($selectionCursor) {
	        if (!this.$focusedCell) { return; }

	        if (this._selectArea(this.$focusedCell, $selectionCursor)) {
	            // valid selection
	            this.$selectionCursor = $selectionCursor;
	        }
	    }

	    _selectArea($cell1, $cell2) {
	        var this$1 = this;

	        if ($cell1 === $cell2) { return false; }

	        var cells = this.getCellsInRange($cell1, $cell2);
	        if (!cells) { return false; }

	        this.clearSelection();
	        this._selectedCells = cells.map(function (index) {
	          var ref;

	          return (ref = this$1).getCell$.apply(ref, index);
	        });
	        requestAnimationFrame(function () {
	            this$1._selectedCells.map(function ($cell) { return $cell.classList.add('dt-cell--highlight'); });
	        });
	        return true;
	    }

	    getCellsInRange($cell1, $cell2) {
	        var assign, assign$1, assign$2;

	        var colIndex1, rowIndex1, colIndex2, rowIndex2;

	        if (typeof $cell1 === 'number') {
	            (assign = arguments, colIndex1 = assign[0], rowIndex1 = assign[1], colIndex2 = assign[2], rowIndex2 = assign[3]);
	        } else
	        if (typeof $cell1 === 'object') {
	            if (!($cell1 && $cell2)) {
	                return false;
	            }

	            var cell1 = $.data($cell1);
	            var cell2 = $.data($cell2);

	            colIndex1 = +cell1.colIndex;
	            rowIndex1 = +cell1.rowIndex;
	            colIndex2 = +cell2.colIndex;
	            rowIndex2 = +cell2.rowIndex;
	        }

	        if (rowIndex1 > rowIndex2) {
	            (assign$1 = [rowIndex2, rowIndex1], rowIndex1 = assign$1[0], rowIndex2 = assign$1[1]);
	        }

	        if (colIndex1 > colIndex2) {
	            (assign$2 = [colIndex2, colIndex1], colIndex1 = assign$2[0], colIndex2 = assign$2[1]);
	        }

	        if (this.isStandardCell(colIndex1) || this.isStandardCell(colIndex2)) {
	            return false;
	        }

	        var cells = [];
	        var colIndex = colIndex1;
	        var rowIndex = rowIndex1;
	        var rowIndices = [];

	        while (rowIndex <= rowIndex2) {
	            rowIndices.push(rowIndex);
	            rowIndex += 1;
	        }

	        rowIndices.map(function (rowIndex) {
	            while (colIndex <= colIndex2) {
	                cells.push([colIndex, rowIndex]);
	                colIndex++;
	            }
	            colIndex = colIndex1;
	        });

	        return cells;
	    }

	    clearSelection() {
	        (this._selectedCells || [])
	            .forEach(function ($cell) { return $cell.classList.remove('dt-cell--highlight'); });

	        this._selectedCells = [];
	        this.$selectionCursor = null;
	    }

	    getSelectionCursor() {
	        return this.$selectionCursor || this.$focusedCell;
	    }

	    activateEditing($cell) {
	        this.focusCell($cell);
	        var ref = $.data($cell);
	        var rowIndex = ref.rowIndex;
	        var colIndex = ref.colIndex;

	        var col = this.columnmanager.getColumn(colIndex);
	        if (col && (col.editable === false || col.focusable === false)) {
	            return;
	        }

	        var cell = this.getCell(colIndex, rowIndex);
	        if (cell && cell.editable === false) {
	            return;
	        }

	        if (this.$editingCell) {
	            var ref$1 = $.data(this.$editingCell);
	            var _rowIndex = ref$1._rowIndex;
	            var _colIndex = ref$1._colIndex;

	            if (rowIndex === _rowIndex && colIndex === _colIndex) {
	                // editing the same cell
	                return;
	            }
	        }

	        this.$editingCell = $cell;
	        $cell.classList.add('dt-cell--editing');

	        var $editCell = $('.dt-cell__edit', $cell);
	        $editCell.innerHTML = '';

	        var editor = this.getEditor(colIndex, rowIndex, cell.content, $editCell);

	        if (editor) {
	            this.currentCellEditor = editor;
	            // initialize editing input with cell value
	            editor.initValue(cell.content, rowIndex, col);
	        }
	    }

	    deactivateEditing(submitValue) {
	        if ( submitValue === void 0 ) submitValue = true;

	        if (submitValue) {
	            this.submitEditing();
	        }
	        // keep focus on the cell so that keyboard navigation works
	        if (this.$focusedCell) { this.$focusedCell.focus(); }

	        if (!this.$editingCell) { return; }
	        this.$editingCell.classList.remove('dt-cell--editing');
	        this.$editingCell = null;
	    }

	    getEditor(colIndex, rowIndex, value, parent) {
	        var column = this.datamanager.getColumn(colIndex);
	        var row = this.datamanager.getRow(rowIndex);
	        var data = this.datamanager.getData(rowIndex);
	        var editor = this.options.getEditor ?
	            this.options.getEditor(colIndex, rowIndex, value, parent, column, row, data) :
	            this.getDefaultEditor(parent);

	        if (editor === false) {
	            // explicitly returned false
	            return false;
	        }
	        if (editor === undefined) {
	            // didn't return editor, fallback to default
	            editor = this.getDefaultEditor(parent);
	        }

	        return editor;
	    }

	    getDefaultEditor(parent) {
	        var $input = $.create('input', {
	            class: 'dt-input',
	            type: 'text',
	            inside: parent
	        });

	        return {
	            initValue: function initValue(value) {
	                $input.focus();
	                $input.value = value;
	            },
	            getValue: function getValue() {
	                return $input.value;
	            },
	            setValue: function setValue(value) {
	                $input.value = value;
	            }
	        };
	    }

	    submitEditing() {
	        var this$1 = this;

	        var promise = Promise.resolve();
	        if (!this.$editingCell) { return promise; }

	        var $cell = this.$editingCell;
	        var ref = $.data($cell);
	        var rowIndex = ref.rowIndex;
	        var colIndex = ref.colIndex;
	        var col = this.datamanager.getColumn(colIndex);

	        if ($cell) {
	            var editor = this.currentCellEditor;

	            if (editor) {
	                var valuePromise = editor.getValue();

	                // convert to stubbed Promise
	                if (!valuePromise.then) {
	                    valuePromise = Promise.resolve(valuePromise);
	                }

	                promise = valuePromise.then(function (value) {
	                    var done = editor.setValue(value, rowIndex, col);
	                    var oldValue = this$1.getCell(colIndex, rowIndex).content;

	                    // update cell immediately
	                    this$1.updateCell(colIndex, rowIndex, value);
	                    $cell.focus();

	                    if (done && done.then) {
	                        // revert to oldValue if promise fails
	                        done.catch(function (e) {
	                            console.log(e);
	                            this$1.updateCell(colIndex, rowIndex, oldValue);
	                        });
	                    }
	                    return done;
	                });
	            }
	        }

	        this.currentCellEditor = null;
	        return promise;
	    }

	    copyCellContents($cell1, $cell2) {
	        var this$1 = this;

	        if (!$cell2 && $cell1) {
	            // copy only focusedCell
	            var ref = $.data($cell1);
	            var colIndex = ref.colIndex;
	            var rowIndex = ref.rowIndex;
	            var cell = this.getCell(colIndex, rowIndex);
	            copyTextToClipboard(cell.content);
	            return 1;
	        }
	        var cells = this.getCellsInRange($cell1, $cell2);

	        if (!cells) { return 0; }

	        var rows = cells
	            // get cell objects
	            .map(function (index) {
	              var ref;

	              return (ref = this$1).getCell.apply(ref, index);
	        })
	            // convert to array of rows
	            .reduce(function (acc, curr) {
	                var rowIndex = curr.rowIndex;

	                acc[rowIndex] = acc[rowIndex] || [];
	                acc[rowIndex].push(curr.content);

	                return acc;
	            }, []);

	        var values = rows
	            // join values by tab
	            .map(function (row) { return row.join('\t'); })
	            // join rows by newline
	            .join('\n');

	        copyTextToClipboard(values);

	        // return no of cells copied
	        return rows.reduce(function (total, row) { return total + row.length; }, 0);
	    }

	    pasteContentInCell(data) {
	        var this$1 = this;

	        if (!this.$focusedCell) { return; }

	        var matrix = data
	            .split('\n')
	            .map(function (row) { return row.split('\t'); })
	            .filter(function (row) { return row.length && row.every(function (it) { return it; }); });

	        var ref = $.data(this.$focusedCell);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;

	        var focusedCell = {
	            colIndex: +colIndex,
	            rowIndex: +rowIndex
	        };

	        matrix.forEach(function (row, i) {
	            var rowIndex = i + focusedCell.rowIndex;
	            row.forEach(function (cell, j) {
	                var colIndex = j + focusedCell.colIndex;
	                this$1.updateCell(colIndex, rowIndex, cell);
	            });
	        });
	    }

	    activateFilter(colIndex) {
	        this.columnmanager.toggleFilter();
	        this.columnmanager.focusFilter(colIndex);

	        if (!this.columnmanager.isFilterShown) {
	            // put focus back on cell
	            this.$focusedCell && this.$focusedCell.focus();
	        }
	    }

	    updateCell(colIndex, rowIndex, value) {
	        var cell = this.datamanager.updateCell(colIndex, rowIndex, {
	            content: value
	        });
	        this.refreshCell(cell);
	    }

	    refreshCell(cell) {
	        var $cell = $(this.selector(cell.colIndex, cell.rowIndex), this.bodyScrollable);
	        $cell.innerHTML = this.getCellContent(cell);
	    }

	    toggleTreeButton(rowIndex, flag) {
	        var colIndex = this.columnmanager.getFirstColumnIndex();
	        var $cell = this.getCell$(colIndex, rowIndex);
	        if ($cell) {
	            $cell.classList[flag ? 'remove' : 'add']('dt-cell--tree-close');
	        }
	    }

	    isStandardCell(colIndex) {
	        // Standard cells are in Sr. No and Checkbox column
	        return colIndex < this.columnmanager.getFirstColumnIndex();
	    }

	    focusCellInDirection(direction) {
	        if (!this.$focusedCell) {
	            return false;
	        } else if (this.$editingCell && ['tab', 'shift+tab'].includes(direction)) {
	            this.deactivateEditing();
	        }

	        var $cell = this.$focusedCell;

	        if (direction === 'left' || direction === 'shift+tab') {
	            $cell = this.getLeftCell$($cell);
	        } else if (direction === 'right' || direction === 'tab') {
	            $cell = this.getRightCell$($cell);
	        } else if (direction === 'up') {
	            $cell = this.getAboveCell$($cell);
	        } else if (direction === 'down') {
	            $cell = this.getBelowCell$($cell);
	        }

	        if (!$cell) {
	            return false;
	        }

	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;
	        var column = this.columnmanager.getColumn(colIndex);

	        if (!column.focusable) {
	            var $prevFocusedCell = this.$focusedCell;
	            this.unfocusCell($prevFocusedCell);
	            this.$focusedCell = $cell;
	            var ret = this.focusCellInDirection(direction);
	            if (!ret) {
	                this.focusCell($prevFocusedCell);
	            }
	            return ret;
	        }

	        this.focusCell($cell);
	        return true;
	    }

	    getCell$(colIndex, rowIndex) {
	        return $(this.selector(colIndex, rowIndex), this.bodyScrollable);
	    }

	    getAboveCell$($cell) {
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;

	        var $aboveRow = $cell.parentElement.previousElementSibling;
	        while ($aboveRow && $aboveRow.classList.contains('dt-row--hide')) {
	            $aboveRow = $aboveRow.previousElementSibling;
	        }

	        if (!$aboveRow) { return $cell; }
	        return $((".dt-cell--col-" + colIndex), $aboveRow);
	    }

	    getBelowCell$($cell) {
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;

	        var $belowRow = $cell.parentElement.nextElementSibling;
	        while ($belowRow && $belowRow.classList.contains('dt-row--hide')) {
	            $belowRow = $belowRow.nextElementSibling;
	        }

	        if (!$belowRow) { return $cell; }
	        return $((".dt-cell--col-" + colIndex), $belowRow);
	    }

	    getLeftCell$($cell) {
	        return $cell.previousElementSibling;
	    }

	    getRightCell$($cell) {
	        return $cell.nextElementSibling;
	    }

	    getLeftMostCell$(rowIndex) {
	        return this.getCell$(this.columnmanager.getFirstColumnIndex(), rowIndex);
	    }

	    getRightMostCell$(rowIndex) {
	        return this.getCell$(this.columnmanager.getLastColumnIndex(), rowIndex);
	    }

	    getTopMostCell$(colIndex) {
	        return this.getCell$(colIndex, this.rowmanager.getFirstRowIndex());
	    }

	    getBottomMostCell$(colIndex) {
	        return this.getCell$(colIndex, this.rowmanager.getLastRowIndex());
	    }

	    getCell(colIndex, rowIndex) {
	        return this.instance.datamanager.getCell(colIndex, rowIndex);
	    }

	    getRowHeight() {
	        return $.style($('.dt-row', this.bodyScrollable), 'height');
	    }

	    scrollToCell($cell) {
	        if ($.inViewport($cell, this.bodyScrollable)) { return false; }

	        var ref = $.data($cell);
	        var rowIndex = ref.rowIndex;
	        this.rowmanager.scrollToRow(rowIndex);
	        return false;
	    }

	    getRowCountPerPage() {
	        return Math.ceil(this.instance.getViewportHeight() / this.getRowHeight());
	    }

	    getCellHTML(cell) {
	        var rowIndex = cell.rowIndex;
	        var colIndex = cell.colIndex;
	        var isHeader = cell.isHeader;
	        var isFilter = cell.isFilter;
	        var isTotalRow = cell.isTotalRow;
	        var dataAttr = makeDataAttributeString({
	            rowIndex: rowIndex,
	            colIndex: colIndex,
	            isHeader: isHeader,
	            isFilter: isFilter,
	            isTotalRow: isTotalRow
	        });

	        var row = this.datamanager.getRow(rowIndex);

	        var isBodyCell = !(isHeader || isFilter || isTotalRow);

	        var className = [
	            'dt-cell',
	            'dt-cell--col-' + colIndex,
	            isBodyCell ? ("dt-cell--" + colIndex + "-" + rowIndex) : '',
	            isBodyCell ? 'dt-cell--row-' + rowIndex : '',
	            isHeader ? 'dt-cell--header' : '',
	            isHeader ? ("dt-cell--header-" + colIndex) : '',
	            isFilter ? 'dt-cell--filter' : '',
	            isBodyCell && (row && row.meta.isTreeNodeClose) ? 'dt-cell--tree-close' : ''
	        ].join(' ');

	        return ("\n            <div class=\"" + className + "\" " + dataAttr + " tabindex=\"0\">\n                " + (this.getCellContent(cell)) + "\n            </div>\n        ");
	    }

	    getCellContent(cell) {
	        var isHeader = cell.isHeader;
	        var isFilter = cell.isFilter;
	        var colIndex = cell.colIndex;

	        var editable = !isHeader && cell.editable !== false;
	        var editCellHTML = editable ? this.getEditCellHTML(colIndex) : '';

	        var sortable = isHeader && cell.sortable !== false;
	        var sortIndicator = sortable ?
	            ("<span class=\"sort-indicator\">\n                " + (this.options.sortIndicator[cell.sortOrder]) + "\n            </span>") :
	            '';

	        var resizable = isHeader && cell.resizable !== false;
	        var resizeColumn = resizable ? '<span class="dt-cell__resize-handle"></span>' : '';

	        var hasDropdown = isHeader && cell.dropdown !== false;
	        var dropdown = hasDropdown ? this.columnmanager.getDropdownHTML() : '';

	        var customFormatter = cell.format || (cell.column && cell.column.format) || null;

	        var contentHTML;
	        if (isHeader || isFilter || !customFormatter) {
	            contentHTML = cell.content;
	        } else {
	            var row = this.datamanager.getRow(cell.rowIndex);
	            var data = this.datamanager.getData(cell.rowIndex);
	            contentHTML = customFormatter(cell.content, row, cell.column, data);
	        }

	        cell.html = contentHTML;

	        if (this.options.treeView && !(isHeader || isFilter) && cell.indent !== undefined) {
	            var nextRow = this.datamanager.getRow(cell.rowIndex + 1);
	            var addToggle = nextRow && nextRow.meta.indent > cell.indent;
	            var leftPadding = 20;
	            var unit = 'px';

	            // Add toggle and indent in the first column
	            var firstColumnIndex = this.datamanager.getColumnIndexById('_rowIndex') + 1;
	            if (firstColumnIndex === cell.colIndex) {
	                var padding = ((cell.indent || 0)) * leftPadding;
	                var toggleHTML = addToggle ?
	                    ("<span class=\"dt-tree-node__toggle\" style=\"left: " + (padding - leftPadding) + unit + "\">\n                        <span class=\"icon-open\">" + (icons.chevronDown) + "</span>\n                        <span class=\"icon-close\">" + (icons.chevronRight) + "</span>\n                    </span>") : '';
	                contentHTML = "<span class=\"dt-tree-node\" style=\"padding-left: " + padding + unit + "\">\n                    " + toggleHTML + "\n                    <span>" + contentHTML + "</span>\n                </span>";
	            }
	        }

	        var className = [
	            'dt-cell__content',
	            isHeader ? ("dt-cell__content--header-" + colIndex) : ("dt-cell__content--col-" + colIndex)
	        ].join(' ');

	        return ("\n            <div class=\"" + className + "\">\n                " + contentHTML + "\n                " + sortIndicator + "\n                " + resizeColumn + "\n                " + dropdown + "\n            </div>\n            " + editCellHTML + "\n        ");
	    }

	    getEditCellHTML(colIndex) {
	        return ("<div class=\"dt-cell__edit dt-cell__edit--col-" + colIndex + "\"></div>");
	    }

	    selector(colIndex, rowIndex) {
	        return (".dt-cell--" + colIndex + "-" + rowIndex);
	    }
	}

	class ColumnManager {
	    constructor(instance) {
	        this.instance = instance;

	        linkProperties(this, this.instance, [
	            'options',
	            'fireEvent',
	            'header',
	            'datamanager',
	            'cellmanager',
	            'style',
	            'wrapper',
	            'rowmanager',
	            'bodyScrollable',
	            'bodyRenderer'
	        ]);

	        this.bindEvents();
	    }

	    renderHeader() {
	        this.header.innerHTML = '<div></div>';
	        this.refreshHeader();
	    }

	    refreshHeader() {
	        var columns = this.datamanager.getColumns();

	        // refresh html
	        $('div', this.header).innerHTML = this.getHeaderHTML(columns);

	        this.$filterRow = $('.dt-row-filter', this.header);
	        if (this.$filterRow) {
	            $.style(this.$filterRow, { display: 'none' });
	        }
	        // reset columnMap
	        this.$columnMap = [];
	        this.bindMoveColumn();
	    }

	    getHeaderHTML(columns) {
	        var html = this.rowmanager.getRowHTML(columns, {
	            isHeader: 1
	        });
	        if (this.options.inlineFilters) {
	            html += this.rowmanager.getRowHTML(columns, {
	                isFilter: 1
	            });
	        }
	        return html;
	    }

	    bindEvents() {
	        this.bindDropdown();
	        this.bindResizeColumn();
	        this.bindPerfectColumnWidth();
	        this.bindFilter();
	    }

	    bindDropdown() {
	        var this$1 = this;

	        var toggleClass = '.dt-dropdown__toggle';
	        var dropdownClass = '.dt-dropdown__list';

	        // attach the dropdown list to container
	        this.instance.dropdownContainer.innerHTML = this.getDropdownListHTML();
	        this.$dropdownList = this.instance.dropdownContainer.firstElementChild;

	        $.on(this.header, 'click', toggleClass, function (e) {
	            this$1.openDropdown(e);
	        });

	        var deactivateDropdownOnBodyClick = function (e) {
	            var selector = [
	                toggleClass, toggleClass + ' *',
	                dropdownClass, dropdownClass + ' *'
	            ].join(',');
	            if (e.target.matches(selector)) { return; }
	            deactivateDropdown();
	        };
	        $.on(document.body, 'click', deactivateDropdownOnBodyClick);
	        document.addEventListener('scroll', deactivateDropdown, true);

	        this.instance.on('onDestroy', function () {
	            $.off(document.body, 'click', deactivateDropdownOnBodyClick);
	            $.off(document, 'scroll', deactivateDropdown);
	        });

	        $.on(this.$dropdownList, 'click', '.dt-dropdown__list-item', function (e, $item) {
	            if (!this$1._dropdownActiveColIndex) { return; }
	            var dropdownItems = this$1.options.headerDropdown;
	            var ref = $.data($item);
	            var index = ref.index;
	            var colIndex = this$1._dropdownActiveColIndex;
	            var callback = dropdownItems[index].action;

	            callback && callback.call(this$1.instance, this$1.getColumn(colIndex));
	            this$1.hideDropdown();
	        });

	        var _this = this;
	        function deactivateDropdown(e) {
	            _this.hideDropdown();
	        }

	        this.hideDropdown();
	    }

	    openDropdown(e) {
	        if (!this._dropdownWidth) {
	            $.style(this.$dropdownList, { display: '' });
	            this._dropdownWidth = $.style(this.$dropdownList, 'width');
	        }
	        $.style(this.$dropdownList, {
	            display: '',
	            left: (e.clientX - this._dropdownWidth + 4) + 'px',
	            top: (e.clientY + 4) + 'px'
	        });
	        var $cell = $.closest('.dt-cell', e.target);
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;
	        this._dropdownActiveColIndex = colIndex;
	    }

	    hideDropdown() {
	        $.style(this.$dropdownList, {
	            display: 'none'
	        });
	        this._dropdownActiveColIndex = null;
	    }

	    bindResizeColumn() {
	        var this$1 = this;

	        var isDragging = false;
	        var $resizingCell, startWidth, startX;

	        $.on(this.header, 'mousedown', '.dt-cell .dt-cell__resize-handle', function (e, $handle) {
	            document.body.classList.add('dt-resize');
	            var $cell = $handle.parentNode.parentNode;
	            $resizingCell = $cell;
	            var ref = $.data($resizingCell);
	            var colIndex = ref.colIndex;
	            var col = this$1.getColumn(colIndex);

	            if (col && col.resizable === false) {
	                return;
	            }

	            isDragging = true;
	            startWidth = $.style($('.dt-cell__content', $resizingCell), 'width');
	            startX = e.pageX;
	        });

	        var onMouseup = function (e) {
	            document.body.classList.remove('dt-resize');
	            if (!$resizingCell) { return; }
	            isDragging = false;

	            var ref = $.data($resizingCell);
	            var colIndex = ref.colIndex;
	            this$1.setColumnWidth(colIndex);
	            this$1.style.setBodyStyle();
	            $resizingCell = null;
	        };
	        $.on(document.body, 'mouseup', onMouseup);
	        this.instance.on('onDestroy', function () {
	            $.off(document.body, 'mouseup', onMouseup);
	        });

	        var onMouseMove = function (e) {
	            if (!isDragging) { return; }
	            var finalWidth = startWidth + (e.pageX - startX);
	            var ref = $.data($resizingCell);
	            var colIndex = ref.colIndex;

	            var columnMinWidth = this$1.options.minimumColumnWidth;
	            if (columnMinWidth > finalWidth) {
	                // don't resize past 30 pixels
	                return;
	            }
	            this$1.datamanager.updateColumn(colIndex, {
	                width: finalWidth
	            });
	            this$1.setColumnHeaderWidth(colIndex);
	        };
	        $.on(document.body, 'mousemove', onMouseMove);
	        this.instance.on('onDestroy', function () {
	            $.off(document.body, 'mousemove', onMouseMove);
	        });
	    }

	    bindPerfectColumnWidth() {
	        var this$1 = this;

	        $.on(this.header, 'dblclick', '.dt-cell .dt-cell__resize-handle', function (e, $handle) {
	            var $cell = $handle.parentNode.parentNode;
	            var ref = $.data($cell);
	            var colIndex = ref.colIndex;

	            var longestCell = this$1.bodyRenderer.visibleRows
	                .map(function (d) { return d[colIndex]; })
	                .reduce(function (acc, curr) { return acc.content.length > curr.content.length ? acc : curr; });

	            var $longestCellHTML = this$1.cellmanager.getCellHTML(longestCell);
	            var $div = document.createElement('div');
	            $div.innerHTML = $longestCellHTML;
	            var cellText = $div.querySelector('.dt-cell__content').textContent;

	            var ref$1 = $.getStyle(this$1.bodyScrollable.querySelector('.dt-cell__content'));
	            var borderLeftWidth = ref$1.borderLeftWidth;
	            var borderRightWidth = ref$1.borderRightWidth;
	            var paddingLeft = ref$1.paddingLeft;
	            var paddingRight = ref$1.paddingRight;

	            var padding = [borderLeftWidth, borderRightWidth, paddingLeft, paddingRight]
	                .map(parseFloat)
	                .reduce(function (sum, val) { return sum + val; });

	            var width = $.measureTextWidth(cellText) + padding;
	            this$1.datamanager.updateColumn(colIndex, { width: width });
	            this$1.setColumnHeaderWidth(colIndex);
	            this$1.setColumnWidth(colIndex);
	        });
	    }

	    bindMoveColumn() {
	        var this$1 = this;

	        if (this.options.disableReorderColumn) { return; }

	        var $parent = $('.dt-row', this.header);

	        this.sortable = Sortable.create($parent, {
	            onEnd: function (e) {
	                var oldIndex = e.oldIndex;
	                var newIndex = e.newIndex;
	                var $draggedCell = e.item;
	                var ref = $.data($draggedCell);
	                var colIndex = ref.colIndex;
	                if (+colIndex === newIndex) { return; }

	                this$1.switchColumn(oldIndex, newIndex);
	            },
	            preventOnFilter: false,
	            filter: '.dt-cell__resize-handle, .dt-dropdown',
	            chosenClass: 'dt-cell--dragging',
	            animation: 150
	        });
	    }

	    sortColumn(colIndex, nextSortOrder) {
	        var this$1 = this;

	        this.instance.freeze();
	        this.sortRows(colIndex, nextSortOrder)
	            .then(function () {
	                this$1.refreshHeader();
	                return this$1.rowmanager.refreshRows();
	            })
	            .then(function () { return this$1.instance.unfreeze(); })
	            .then(function () {
	                this$1.fireEvent('onSortColumn', this$1.getColumn(colIndex));
	            });
	    }

	    removeColumn(colIndex) {
	        var this$1 = this;

	        var removedCol = this.getColumn(colIndex);
	        this.instance.freeze();
	        this.datamanager.removeColumn(colIndex)
	            .then(function () {
	                this$1.refreshHeader();
	                return this$1.rowmanager.refreshRows();
	            })
	            .then(function () { return this$1.instance.unfreeze(); })
	            .then(function () {
	                this$1.fireEvent('onRemoveColumn', removedCol);
	            });
	    }

	    switchColumn(oldIndex, newIndex) {
	        var this$1 = this;

	        this.instance.freeze();
	        this.datamanager.switchColumn(oldIndex, newIndex)
	            .then(function () {
	                this$1.refreshHeader();
	                return this$1.rowmanager.refreshRows();
	            })
	            .then(function () {
	                this$1.setColumnWidth(oldIndex);
	                this$1.setColumnWidth(newIndex);
	                this$1.instance.unfreeze();
	            })
	            .then(function () {
	                this$1.fireEvent('onSwitchColumn',
	                    this$1.getColumn(oldIndex), this$1.getColumn(newIndex)
	                );
	            });
	    }

	    toggleFilter(flag) {
	        if (!this.options.inlineFilters) { return; }

	        var showFilter;
	        if (flag === undefined) {
	            showFilter = !this.isFilterShown;
	        } else {
	            showFilter = flag;
	        }

	        if (showFilter) {
	            $.style(this.$filterRow, { display: '' });
	        } else {
	            $.style(this.$filterRow, { display: 'none' });
	        }

	        this.isFilterShown = showFilter;
	        this.style.setBodyStyle();
	    }

	    focusFilter(colIndex) {
	        if (!this.isFilterShown) { return; }

	        var $filterInput = $((".dt-cell--col-" + colIndex + " .dt-filter"), this.$filterRow);
	        $filterInput.focus();
	    }

	    bindFilter() {
	        var this$1 = this;

	        if (!this.options.inlineFilters) { return; }
	        var handler = function (e) {
	            this$1.applyFilter(this$1.getAppliedFilters());
	        };
	        $.on(this.header, 'keydown', '.dt-filter', debounce$1(handler, 300));
	    }

	    applyFilter(filters) {
	        var this$1 = this;

	        this.datamanager.filterRows(filters)
	            .then(function (ref) {
	                var rowsToShow = ref.rowsToShow;

	                this$1.rowmanager.showRows(rowsToShow);
	            });
	    }

	    getAppliedFilters() {
	        var filters = {};
	        $.each('.dt-filter', this.header).map(function (input) {
	            var value = input.value;
	            if (value) {
	                filters[input.dataset.colIndex] = value;
	            }
	        });
	        return filters;
	    }

	    applyDefaultSortOrder() {
	        // sort rows if any 1 column has a default sortOrder set
	        var columnsToSort = this.getColumns().filter(function (col) { return col.sortOrder !== 'none'; });

	        if (columnsToSort.length === 1) {
	            var column = columnsToSort[0];
	            this.sortColumn(column.colIndex, column.sortOrder);
	        }
	    }

	    sortRows(colIndex, sortOrder) {
	        return this.datamanager.sortRows(colIndex, sortOrder);
	    }

	    getColumn(colIndex) {
	        return this.datamanager.getColumn(colIndex);
	    }

	    getColumns() {
	        return this.datamanager.getColumns();
	    }

	    setColumnWidth(colIndex, width) {
	        colIndex = +colIndex;

	        var columnWidth = width || this.getColumn(colIndex).width;

	        var selector = [
	            (".dt-cell__content--col-" + colIndex),
	            (".dt-cell__edit--col-" + colIndex)
	        ].join(', ');

	        var styles = {
	            width: columnWidth + 'px'
	        };

	        this.style.setStyle(selector, styles);
	    }

	    setColumnHeaderWidth(colIndex) {
	        colIndex = +colIndex;
	        this.$columnMap = this.$columnMap || [];
	        var selector = ".dt-cell__content--header-" + colIndex;
	        var ref = this.getColumn(colIndex);
	        var width = ref.width;

	        var $column = this.$columnMap[colIndex];
	        if (!$column) {
	            $column = this.header.querySelector(selector);
	            this.$columnMap[colIndex] = $column;
	        }

	        $column.style.width = width + 'px';
	    }

	    getColumnMinWidth(colIndex) {
	        colIndex = +colIndex;
	        return this.getColumn(colIndex).minWidth || 24;
	    }

	    getFirstColumnIndex() {
	        return this.datamanager.getColumnIndexById('_rowIndex') + 1;
	    }

	    getHeaderCell$(colIndex) {
	        return $((".dt-cell--header-" + colIndex), this.header);
	    }

	    getLastColumnIndex() {
	        return this.datamanager.getColumnCount() - 1;
	    }

	    getDropdownHTML() {
	        var ref = this.options;
	        var dropdownButton = ref.dropdownButton;

	        return ("\n            <div class=\"dt-dropdown\">\n                <div class=\"dt-dropdown__toggle\">" + dropdownButton + "</div>\n            </div>\n      ");
	    }

	    getDropdownListHTML() {
	        var ref = this.options;
	        var dropdownItems = ref.headerDropdown;

	        return ("\n            <div class=\"dt-dropdown__list\">\n            " + (dropdownItems.map(function (d, i) { return ("\n                <div class=\"dt-dropdown__list-item\" data-index=\"" + i + "\">" + (d.label) + "</div>\n            "); }).join('')) + "\n            </div>\n        ");
	    }
	}

	class RowManager {
	    constructor(instance) {
	        this.instance = instance;
	        linkProperties(this, this.instance, [
	            'options',
	            'fireEvent',
	            'wrapper',
	            'bodyScrollable',
	            'bodyRenderer',
	            'style'
	        ]);

	        this.bindEvents();
	        this.refreshRows = nextTick(this.refreshRows, this);
	    }

	    get datamanager() {
	        return this.instance.datamanager;
	    }

	    get cellmanager() {
	        return this.instance.cellmanager;
	    }

	    bindEvents() {
	        this.bindCheckbox();
	    }

	    bindCheckbox() {
	        var this$1 = this;

	        if (!this.options.checkboxColumn) { return; }

	        // map of checked rows
	        this.checkMap = [];

	        $.on(this.wrapper, 'click', '.dt-cell--col-0 [type="checkbox"]', function (e, $checkbox) {
	            var $cell = $checkbox.closest('.dt-cell');
	            var ref = $.data($cell);
	            var rowIndex = ref.rowIndex;
	            var isHeader = ref.isHeader;
	            var checked = $checkbox.checked;

	            if (isHeader) {
	                this$1.checkAll(checked);
	            } else {
	                this$1.checkRow(rowIndex, checked);
	            }
	        });
	    }

	    refreshRows() {
	        this.instance.renderBody();
	        this.instance.setDimensions();
	    }

	    refreshRow(row, rowIndex) {
	        var this$1 = this;

	        var _row = this.datamanager.updateRow(row, rowIndex);

	        _row.forEach(function (cell) {
	            this$1.cellmanager.refreshCell(cell);
	        });
	    }

	    getCheckedRows() {
	        if (!this.checkMap) {
	            return [];
	        }

	        var out = [];
	        for (var rowIndex in this.checkMap) {
	            var checked = this.checkMap[rowIndex];
	            if (checked === 1) {
	                out.push(rowIndex);
	            }
	        }

	        return out;
	    }

	    highlightCheckedRows() {
	        var this$1 = this;

	        this.getCheckedRows()
	            .map(function (rowIndex) { return this$1.checkRow(rowIndex, true); });
	    }

	    checkRow(rowIndex, toggle) {
	        var value = toggle ? 1 : 0;
	        var selector = function (rowIndex) { return (".dt-cell--0-" + rowIndex + " [type=\"checkbox\"]"); };
	        // update internal map
	        this.checkMap[rowIndex] = value;
	        // set checkbox value explicitly
	        $.each(selector(rowIndex), this.bodyScrollable)
	            .map(function (input) {
	                input.checked = toggle;
	            });
	        // highlight row
	        this.highlightRow(rowIndex, toggle);
	        this.showCheckStatus();
	        this.fireEvent('onCheckRow', this.datamanager.getRow(rowIndex));
	    }

	    checkAll(toggle) {
	        var value = toggle ? 1 : 0;

	        // update internal map
	        if (toggle) {
	            this.checkMap = Array.from(Array(this.getTotalRows())).map(function (c) { return value; });
	        } else {
	            this.checkMap = [];
	        }
	        // set checkbox value
	        $.each('.dt-cell--col-0 [type="checkbox"]', this.bodyScrollable)
	            .map(function (input) {
	                input.checked = toggle;
	            });
	        // highlight all
	        this.highlightAll(toggle);
	        this.showCheckStatus();
	        this.fireEvent('onCheckRow');
	    }

	    showCheckStatus() {
	        if (!this.options.checkedRowStatus) { return; }
	        var checkedRows = this.getCheckedRows();
	        var count = checkedRows.length;
	        if (count > 0) {
	            this.bodyRenderer.showToastMessage((count + " row" + (count > 1 ? 's' : '') + " selected"));
	        } else {
	            this.bodyRenderer.clearToastMessage();
	        }
	    }

	    highlightRow(rowIndex, toggle) {
	        if ( toggle === void 0 ) toggle = true;

	        var $row = this.getRow$(rowIndex);
	        if (!$row) { return; }

	        if (!toggle && this.bodyScrollable.classList.contains('dt-scrollable--highlight-all')) {
	            $row.classList.add('dt-row--unhighlight');
	            return;
	        }

	        if (toggle && $row.classList.contains('dt-row--unhighlight')) {
	            $row.classList.remove('dt-row--unhighlight');
	        }

	        this._highlightedRows = this._highlightedRows || {};

	        if (toggle) {
	            $row.classList.add('dt-row--highlight');
	            this._highlightedRows[rowIndex] = $row;
	        } else {
	            $row.classList.remove('dt-row--highlight');
	            delete this._highlightedRows[rowIndex];
	        }
	    }

	    highlightAll(toggle) {
	        if ( toggle === void 0 ) toggle = true;

	        if (toggle) {
	            this.bodyScrollable.classList.add('dt-scrollable--highlight-all');
	        } else {
	            this.bodyScrollable.classList.remove('dt-scrollable--highlight-all');
	            for (var rowIndex in this._highlightedRows) {
	                var $row = this._highlightedRows[rowIndex];
	                $row.classList.remove('dt-row--highlight');
	            }
	            this._highlightedRows = {};
	        }
	    }

	    showRows(rowIndices) {
	        var this$1 = this;

	        rowIndices = ensureArray(rowIndices);
	        var rows = rowIndices.map(function (rowIndex) { return this$1.datamanager.getRow(rowIndex); });
	        this.bodyRenderer.renderRows(rows);
	    }

	    showAllRows() {
	        var rowIndices = this.datamanager.getAllRowIndices();
	        this.showRows(rowIndices);
	    }

	    getChildrenToShowForNode(rowIndex) {
	        var row = this.datamanager.getRow(rowIndex);
	        row.meta.isTreeNodeClose = false;

	        return this.datamanager.getImmediateChildren(rowIndex);
	    }

	    openSingleNode(rowIndex) {
	        var childrenToShow = this.getChildrenToShowForNode(rowIndex);
	        var visibleRowIndices = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = uniq$1(childrenToShow.concat( visibleRowIndices)).sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    getChildrenToHideForNode(rowIndex) {
	        var this$1 = this;

	        var row = this.datamanager.getRow(rowIndex);
	        row.meta.isTreeNodeClose = true;

	        var rowsToHide = this.datamanager.getChildren(rowIndex);
	        rowsToHide.forEach(function (rowIndex) {
	            var row = this$1.datamanager.getRow(rowIndex);
	            if (!row.meta.isLeaf) {
	                row.meta.isTreeNodeClose = true;
	            }
	        });

	        return rowsToHide;
	    }

	    closeSingleNode(rowIndex) {
	        var rowsToHide = this.getChildrenToHideForNode(rowIndex);
	        var visibleRows = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = visibleRows
	            .filter(function (rowIndex) { return !rowsToHide.includes(rowIndex); })
	            .sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    expandAllNodes() {
	        var this$1 = this;

	        var rows = this.datamanager.getRows();
	        var rootNodes = rows.filter(function (row) { return !row.meta.isLeaf; });

	        var childrenToShow = rootNodes.map(function (row) { return this$1.getChildrenToShowForNode(row.meta.rowIndex); }).flat();
	        var visibleRowIndices = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = uniq$1(childrenToShow.concat( visibleRowIndices)).sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    collapseAllNodes() {
	        var this$1 = this;

	        var rows = this.datamanager.getRows();
	        var rootNodes = rows.filter(function (row) { return row.meta.indent === 0; });

	        var rowsToHide = rootNodes.map(function (row) { return this$1.getChildrenToHideForNode(row.meta.rowIndex); }).flat();
	        var visibleRows = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = visibleRows
	            .filter(function (rowIndex) { return !rowsToHide.includes(rowIndex); })
	            .sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    setTreeDepth(depth) {
	        var rows = this.datamanager.getRows();

	        var rowsToOpen = rows.filter(function (row) { return row.meta.indent < depth; });
	        var rowsToClose = rows.filter(function (row) { return row.meta.indent >= depth; });
	        var rowsToHide = rowsToClose.filter(function (row) { return row.meta.indent > depth; });

	        rowsToClose.forEach(function (row) {
	            if (!row.meta.isLeaf) {
	                row.meta.isTreeNodeClose = true;
	            }
	        });
	        rowsToOpen.forEach(function (row) {
	            if (!row.meta.isLeaf) {
	                row.meta.isTreeNodeClose = false;
	            }
	        });

	        var rowsToShow = rows
	            .filter(function (row) { return !rowsToHide.includes(row); })
	            .map(function (row) { return row.meta.rowIndex; })
	            .sort(numberSortAsc);
	        this.showRows(rowsToShow);
	    }

	    getRow$(rowIndex) {
	        return $(this.selector(rowIndex), this.bodyScrollable);
	    }

	    getTotalRows() {
	        return this.datamanager.getRowCount();
	    }

	    getFirstRowIndex() {
	        return 0;
	    }

	    getLastRowIndex() {
	        return this.datamanager.getRowCount() - 1;
	    }

	    scrollToRow(rowIndex) {
	        rowIndex = +rowIndex;
	        this._lastScrollTo = this._lastScrollTo || 0;
	        var $row = this.getRow$(rowIndex);
	        if ($.inViewport($row, this.bodyScrollable)) { return; }

	        var ref = $row.getBoundingClientRect();
	        var height = ref.height;
	        var ref$1 = this.bodyScrollable.getBoundingClientRect();
	        var top = ref$1.top;
	        var bottom = ref$1.bottom;
	        var rowsInView = Math.floor((bottom - top) / height);

	        var offset = 0;
	        if (rowIndex > this._lastScrollTo) {
	            offset = height * ((rowIndex + 1) - rowsInView);
	        } else {
	            offset = height * ((rowIndex + 1) - 1);
	        }

	        this._lastScrollTo = rowIndex;
	        $.scrollTop(this.bodyScrollable, offset);
	    }

	    getRowHTML(row, props) {
	        var this$1 = this;

	        var dataAttr = makeDataAttributeString(props);
	        var rowIdentifier = props.rowIndex;

	        if (props.isFilter) {
	            row = row.map(function (cell) { return (Object.assign({}, cell, {
	                content: this$1.getFilterInput({
	                    colIndex: cell.colIndex
	                }),
	                isFilter: 1,
	                isHeader: undefined,
	                editable: false
	            })); });

	            rowIdentifier = 'filter';
	        }

	        if (props.isHeader) {
	            rowIdentifier = 'header';
	        }

	        return ("\n            <div class=\"dt-row dt-row-" + rowIdentifier + "\" " + dataAttr + ">\n                " + (row.map(function (cell) { return this$1.cellmanager.getCellHTML(cell); }).join('')) + "\n            </div>\n        ");
	    }

	    getFilterInput(props) {
	        var dataAttr = makeDataAttributeString(props);
	        return ("<input class=\"dt-filter dt-input\" type=\"text\" " + dataAttr + " tabindex=\"1\" />");
	    }

	    selector(rowIndex) {
	        return (".dt-row-" + rowIndex);
	    }
	}

	var hyperlist = createCommonjsModule(function (module, exports) {
	(function(f){{module.exports=f();}})(function(){return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof commonjsRequire&&commonjsRequire;if(!f&&c){ return c(i,!0); }if(u){ return u(i,!0); }var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t);}return n[i].exports}for(var u="function"==typeof commonjsRequire&&commonjsRequire,i=0;i<t.length;i++){ o(t[i]); }return o}return r})()({1:[function(_dereq_,module,exports){

	// Default configuration.

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var defaultConfig = {
	  width: '100%',
	  height: '100%'

	  // Check for valid number.
	};var isNumber = function isNumber(input) {
	  return Number(input) === Number(input);
	};

	// Add a class to an element.
	var addClass = 'classList' in document.documentElement ? function (element, className) {
	  element.classList.add(className);
	} : function (element, className) {
	  var oldClass = element.getAttribute('class') || '';
	  element.setAttribute('class', oldClass + ' ' + className);
	};

	/**
	 * Creates a HyperList instance that virtually scrolls very large amounts of
	 * data effortlessly.
	 */

	var HyperList = function () {
	  _createClass(HyperList, null, [{
	    key: 'create',
	    value: function create(element, userProvidedConfig) {
	      return new HyperList(element, userProvidedConfig);
	    }

	    /**
	     * Merge given css style on an element
	     * @param {DOMElement} element
	     * @param {Object} style
	     */

	  }, {
	    key: 'mergeStyle',
	    value: function mergeStyle(element, style) {
	      for (var i in style) {
	        if (element.style[i] !== style[i]) {
	          element.style[i] = style[i];
	        }
	      }
	    }
	  }, {
	    key: 'getMaxBrowserHeight',
	    value: function getMaxBrowserHeight() {
	      // Create two elements, the wrapper is `1px` tall and is transparent and
	      // positioned at the top of the page. Inside that is an element that gets
	      // set to 1 billion pixels. Then reads the max height the browser can
	      // calculate.
	      var wrapper = document.createElement('div');
	      var fixture = document.createElement('div');

	      // As said above, these values get set to put the fixture elements into the
	      // right visual state.
	      HyperList.mergeStyle(wrapper, { position: 'absolute', height: '1px', opacity: 0 });
	      HyperList.mergeStyle(fixture, { height: '1e7px' });

	      // Add the fixture into the wrapper element.
	      wrapper.appendChild(fixture);

	      // Apply to the page, the values won't kick in unless this is attached.
	      document.body.appendChild(wrapper);

	      // Get the maximum element height in pixels.
	      var maxElementHeight = fixture.offsetHeight;

	      // Remove the element immediately after reading the value.
	      document.body.removeChild(wrapper);

	      return maxElementHeight;
	    }
	  }]);

	  function HyperList(element, userProvidedConfig) {
	    var _this = this;

	    _classCallCheck(this, HyperList);

	    this._config = {};
	    this._lastRepaint = null;
	    this._maxElementHeight = HyperList.getMaxBrowserHeight();

	    this.refresh(element, userProvidedConfig);

	    var config = this._config;

	    // Create internal render loop.
	    var render = function render() {
	      var scrollTop = _this._getScrollPosition();
	      var lastRepaint = _this._lastRepaint;

	      _this._renderAnimationFrame = window.requestAnimationFrame(render);

	      if (scrollTop === lastRepaint) {
	        return;
	      }

	      var diff = lastRepaint ? scrollTop - lastRepaint : 0;
	      if (!lastRepaint || diff < 0 || diff > _this._averageHeight) {
	        var rendered = _this._renderChunk();

	        _this._lastRepaint = scrollTop;

	        if (rendered !== false && typeof config.afterRender === 'function') {
	          config.afterRender();
	        }
	      }
	    };

	    render();
	  }

	  _createClass(HyperList, [{
	    key: 'destroy',
	    value: function destroy() {
	      window.cancelAnimationFrame(this._renderAnimationFrame);
	    }
	  }, {
	    key: 'refresh',
	    value: function refresh(element, userProvidedConfig) {
	      var _scrollerStyle;

	      Object.assign(this._config, defaultConfig, userProvidedConfig);

	      if (!element || element.nodeType !== 1) {
	        throw new Error('HyperList requires a valid DOM Node container');
	      }

	      this._element = element;

	      var config = this._config;

	      var scroller = this._scroller || config.scroller || document.createElement(config.scrollerTagName || 'tr');

	      // Default configuration option `useFragment` to `true`.
	      if (typeof config.useFragment !== 'boolean') {
	        this._config.useFragment = true;
	      }

	      if (!config.generate) {
	        throw new Error('Missing required `generate` function');
	      }

	      if (!isNumber(config.total)) {
	        throw new Error('Invalid required `total` value, expected number');
	      }

	      if (!Array.isArray(config.itemHeight) && !isNumber(config.itemHeight)) {
	        throw new Error('\n        Invalid required `itemHeight` value, expected number or array\n      '.trim());
	      } else if (isNumber(config.itemHeight)) {
	        this._itemHeights = Array(config.total).fill(config.itemHeight);
	      } else {
	        this._itemHeights = config.itemHeight;
	      }

	      // Width and height should be coerced to string representations. Either in
	      // `%` or `px`.
	      Object.keys(defaultConfig).filter(function (prop) {
	        return prop in config;
	      }).forEach(function (prop) {
	        var value = config[prop];
	        var isValueNumber = isNumber(value);

	        if (value && typeof value !== 'string' && typeof value !== 'number') {
	          var msg = 'Invalid optional `' + prop + '`, expected string or number';
	          throw new Error(msg);
	        } else if (isValueNumber) {
	          config[prop] = value + 'px';
	        }
	      });

	      var isHoriz = Boolean(config.horizontal);
	      var value = config[isHoriz ? 'width' : 'height'];

	      if (value) {
	        var isValueNumber = isNumber(value);
	        var isValuePercent = isValueNumber ? false : value.slice(-1) === '%';
	        // Compute the containerHeight as number
	        var numberValue = isValueNumber ? value : parseInt(value.replace(/px|%/, ''), 10);
	        var innerSize = window[isHoriz ? 'innerWidth' : 'innerHeight'];

	        if (isValuePercent) {
	          this._containerSize = innerSize * numberValue / 100;
	        } else {
	          this._containerSize = isNumber(value) ? value : numberValue;
	        }
	      }

	      var scrollContainer = config.scrollContainer;
	      var scrollerHeight = config.itemHeight * config.total;
	      var maxElementHeight = this._maxElementHeight;

	      if (scrollerHeight > maxElementHeight) {
	        console.warn(['HyperList: The maximum element height', maxElementHeight + 'px has', 'been exceeded; please reduce your item height.'].join(' '));
	      }

	      // Decorate the container element with styles that will match
	      // the user supplied configuration.
	      var elementStyle = {
	        width: '' + config.width,
	        height: scrollContainer ? scrollerHeight + 'px' : '' + config.height,
	        overflow: scrollContainer ? 'none' : 'auto',
	        position: 'relative'
	      };

	      HyperList.mergeStyle(element, elementStyle);

	      if (scrollContainer) {
	        HyperList.mergeStyle(config.scrollContainer, { overflow: 'auto' });
	      }

	      var scrollerStyle = (_scrollerStyle = {
	        opacity: '0',
	        position: 'absolute'
	      }, _defineProperty(_scrollerStyle, isHoriz ? 'height' : 'width', '1px'), _defineProperty(_scrollerStyle, isHoriz ? 'width' : 'height', scrollerHeight + 'px'), _scrollerStyle);

	      HyperList.mergeStyle(scroller, scrollerStyle);

	      // Only append the scroller element once.
	      if (!this._scroller) {
	        element.appendChild(scroller);
	      }

	      var padding = this._computeScrollPadding();
	      this._scrollPaddingBottom = padding.bottom;
	      this._scrollPaddingTop = padding.top;

	      // Set the scroller instance.
	      this._scroller = scroller;
	      this._scrollHeight = this._computeScrollHeight();

	      // Reuse the item positions if refreshed, otherwise set to empty array.
	      this._itemPositions = this._itemPositions || Array(config.total).fill(0);

	      // Each index in the array should represent the position in the DOM.
	      this._computePositions(0);

	      // Render after refreshing. Force render if we're calling refresh manually.
	      this._renderChunk(this._lastRepaint !== null);

	      if (typeof config.afterRender === 'function') {
	        config.afterRender();
	      }
	    }
	  }, {
	    key: '_getRow',
	    value: function _getRow(i) {
	      var config = this._config;
	      var item = config.generate(i);
	      var height = item.height;

	      if (height !== undefined && isNumber(height)) {
	        item = item.element;

	        // The height isn't the same as predicted, compute positions again
	        if (height !== this._itemHeights[i]) {
	          this._itemHeights[i] = height;
	          this._computePositions(i);
	          this._scrollHeight = this._computeScrollHeight(i);
	        }
	      } else {
	        height = this._itemHeights[i];
	      }

	      if (!item || item.nodeType !== 1) {
	        throw new Error('Generator did not return a DOM Node for index: ' + i);
	      }

	      addClass(item, config.rowClassName || 'vrow');

	      var top = this._itemPositions[i] + this._scrollPaddingTop;

	      HyperList.mergeStyle(item, _defineProperty({
	        position: 'absolute'
	      }, config.horizontal ? 'left' : 'top', top + 'px'));

	      return item;
	    }
	  }, {
	    key: '_getScrollPosition',
	    value: function _getScrollPosition() {
	      var config = this._config;

	      if (typeof config.overrideScrollPosition === 'function') {
	        return config.overrideScrollPosition();
	      }

	      return this._element[config.horizontal ? 'scrollLeft' : 'scrollTop'];
	    }
	  }, {
	    key: '_renderChunk',
	    value: function _renderChunk(force) {
	      var config = this._config;
	      var element = this._element;
	      var scrollTop = this._getScrollPosition();
	      var total = config.total;

	      var from = config.reverse ? this._getReverseFrom(scrollTop) : this._getFrom(scrollTop) - 1;

	      if (from < 0 || from - this._screenItemsLen < 0) {
	        from = 0;
	      }

	      if (!force && this._lastFrom === from) {
	        return false;
	      }

	      this._lastFrom = from;

	      var to = from + this._cachedItemsLen;

	      if (to > total || to + this._cachedItemsLen > total) {
	        to = total;
	      }

	      // Append all the new rows in a document fragment that we will later append
	      // to the parent node
	      var fragment = config.useFragment ? document.createDocumentFragment() : []
	      // Sometimes you'll pass fake elements to this tool and Fragments require
	      // real elements.


	      // The element that forces the container to scroll.
	      ;var scroller = this._scroller;

	      // Keep the scroller in the list of children.
	      fragment[config.useFragment ? 'appendChild' : 'push'](scroller);

	      for (var i = from; i < to; i++) {
	        var row = this._getRow(i);

	        fragment[config.useFragment ? 'appendChild' : 'push'](row);
	      }

	      if (config.applyPatch) {
	        return config.applyPatch(element, fragment);
	      }

	      element.innerHTML = '';
	      element.appendChild(fragment);
	    }
	  }, {
	    key: '_computePositions',
	    value: function _computePositions() {
	      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

	      var config = this._config;
	      var total = config.total;
	      var reverse = config.reverse;

	      if (from < 1 && !reverse) {
	        from = 1;
	      }

	      for (var i = from; i < total; i++) {
	        if (reverse) {
	          if (i === 0) {
	            this._itemPositions[0] = this._scrollHeight - this._itemHeights[0];
	          } else {
	            this._itemPositions[i] = this._itemPositions[i - 1] - this._itemHeights[i];
	          }
	        } else {
	          this._itemPositions[i] = this._itemHeights[i - 1] + this._itemPositions[i - 1];
	        }
	      }
	    }
	  }, {
	    key: '_computeScrollHeight',
	    value: function _computeScrollHeight() {
	      var _HyperList$mergeStyle2,
	          _this2 = this;

	      var config = this._config;
	      var isHoriz = Boolean(config.horizontal);
	      var total = config.total;
	      var scrollHeight = this._itemHeights.reduce(function (a, b) {
	        return a + b;
	      }, 0) + this._scrollPaddingBottom + this._scrollPaddingTop;

	      HyperList.mergeStyle(this._scroller, (_HyperList$mergeStyle2 = {
	        opacity: 0,
	        position: 'absolute',
	        top: '0px'
	      }, _defineProperty(_HyperList$mergeStyle2, isHoriz ? 'height' : 'width', '1px'), _defineProperty(_HyperList$mergeStyle2, isHoriz ? 'width' : 'height', scrollHeight + 'px'), _HyperList$mergeStyle2));

	      // Calculate the height median
	      var sortedItemHeights = this._itemHeights.slice(0).sort(function (a, b) {
	        return a - b;
	      });
	      var middle = Math.floor(total / 2);
	      var averageHeight = total % 2 === 0 ? (sortedItemHeights[middle] + sortedItemHeights[middle - 1]) / 2 : sortedItemHeights[middle];

	      var clientProp = isHoriz ? 'clientWidth' : 'clientHeight';
	      var element = config.scrollContainer ? config.scrollContainer : this._element;
	      var containerHeight = element[clientProp] ? element[clientProp] : this._containerSize;
	      this._screenItemsLen = Math.ceil(containerHeight / averageHeight);
	      this._containerSize = containerHeight;

	      // Cache 3 times the number of items that fit in the container viewport.
	      this._cachedItemsLen = Math.max(this._cachedItemsLen || 0, this._screenItemsLen * 3);
	      this._averageHeight = averageHeight;

	      if (config.reverse) {
	        window.requestAnimationFrame(function () {
	          if (isHoriz) {
	            _this2._element.scrollLeft = scrollHeight;
	          } else {
	            _this2._element.scrollTop = scrollHeight;
	          }
	        });
	      }

	      return scrollHeight;
	    }
	  }, {
	    key: '_computeScrollPadding',
	    value: function _computeScrollPadding() {
	      var config = this._config;
	      var isHoriz = Boolean(config.horizontal);
	      var isReverse = config.reverse;
	      var styles = window.getComputedStyle(this._element);

	      var padding = function padding(location) {
	        var cssValue = styles.getPropertyValue('padding-' + location);
	        return parseInt(cssValue, 10) || 0;
	      };

	      if (isHoriz && isReverse) {
	        return {
	          bottom: padding('left'),
	          top: padding('right')
	        };
	      } else if (isHoriz) {
	        return {
	          bottom: padding('right'),
	          top: padding('left')
	        };
	      } else if (isReverse) {
	        return {
	          bottom: padding('top'),
	          top: padding('bottom')
	        };
	      } else {
	        return {
	          bottom: padding('bottom'),
	          top: padding('top')
	        };
	      }
	    }
	  }, {
	    key: '_getFrom',
	    value: function _getFrom(scrollTop) {
	      var i = 0;

	      while (this._itemPositions[i] < scrollTop) {
	        i++;
	      }

	      return i;
	    }
	  }, {
	    key: '_getReverseFrom',
	    value: function _getReverseFrom(scrollTop) {
	      var i = this._config.total - 1;

	      while (i > 0 && this._itemPositions[i] < scrollTop + this._containerSize) {
	        i--;
	      }

	      return i;
	    }
	  }]);

	  return HyperList;
	}();

	exports.default = HyperList;
	module.exports = exports['default'];

	},{}]},{},[1])(1)
	});
	});

	var HyperList = unwrapExports(hyperlist);

	class BodyRenderer {
	    constructor(instance) {
	        this.instance = instance;
	        this.options = instance.options;
	        this.datamanager = instance.datamanager;
	        this.rowmanager = instance.rowmanager;
	        this.cellmanager = instance.cellmanager;
	        this.bodyScrollable = instance.bodyScrollable;
	        this.footer = this.instance.footer;
	        this.log = instance.log;
	    }

	    renderRows(rows) {
	        var this$1 = this;

	        this.visibleRows = rows;
	        this.visibleRowIndices = rows.map(function (row) { return row.meta.rowIndex; });

	        if (rows.length === 0) {
	            this.bodyScrollable.innerHTML = this.getNoDataHTML();
	            return;
	        }

	        var rowViewOrder = this.datamanager.rowViewOrder.map(function (index) {
	            if (this$1.visibleRowIndices.includes(index)) {
	                return index;
	            }
	            return null;
	        }).filter(function (index) { return index !== null; });

	        var computedStyle = getComputedStyle(this.bodyScrollable);

	        var config = {
	            width: computedStyle.width,
	            height: computedStyle.height,
	            itemHeight: this.options.cellHeight,
	            total: rows.length,
	            generate: function (index) {
	                var el = document.createElement('div');
	                var rowIndex = rowViewOrder[index];
	                var row = this$1.datamanager.getRow(rowIndex);
	                var rowHTML = this$1.rowmanager.getRowHTML(row, row.meta);
	                el.innerHTML = rowHTML;
	                return el.children[0];
	            },
	            afterRender: function () {
	                this$1.restoreState();
	            }
	        };

	        if (!this.hyperlist) {
	            this.hyperlist = new HyperList(this.bodyScrollable, config);
	        } else {
	            this.hyperlist.refresh(this.bodyScrollable, config);
	        }

	        this.renderFooter();
	    }

	    render() {
	        var rows = this.datamanager.getRowsForView();
	        this.renderRows(rows);
	        // setDimensions requires atleast 1 row to exist in dom
	        this.instance.setDimensions();
	    }

	    renderFooter() {
	        if (!this.options.showTotalRow) { return; }

	        var totalRow = this.getTotalRow();
	        var html = this.rowmanager.getRowHTML(totalRow, { isTotalRow: 1, rowIndex: 'totalRow' });

	        this.footer.innerHTML = html;
	    }

	    getTotalRow() {
	        var this$1 = this;

	        var columns = this.datamanager.getColumns();
	        var totalRowTemplate = columns.map(function (col) {
	            var content = null;
	            if (['_rowIndex', '_checkbox'].includes(col.id)) {
	                content = '';
	            }
	            return {
	                content: content,
	                isTotalRow: 1,
	                colIndex: col.colIndex,
	                column: col
	            };
	        });

	        var totalRow = totalRowTemplate.map(function (cell, i) {
	            if (cell.content === '') { return cell; }

	            if (this$1.options.hooks.columnTotal) {
	                var columnValues = this$1.visibleRows.map(function (row) { return row[i].content; });
	                var result = this$1.options.hooks.columnTotal.call(this$1.instance, columnValues, cell);
	                if (result != null) {
	                    cell.content = result;
	                    return cell;
	                }
	            }

	            cell.content = this$1.visibleRows.reduce(function (acc, prevRow) {
	                var prevCell = prevRow[i];
	                if (typeof prevCell.content === 'number') {
	                    if (acc == null) { acc = 0; }
	                    return acc + prevCell.content;
	                }
	                return acc;
	            }, cell.content);

	            return cell;
	        });

	        return totalRow;
	    }

	    restoreState() {
	        this.rowmanager.highlightCheckedRows();
	        this.cellmanager.selectAreaOnClusterChanged();
	        this.cellmanager.focusCellOnClusterChanged();
	    }

	    showToastMessage(message, hideAfter) {
	        var this$1 = this;

	        this.instance.toastMessage.innerHTML = this.getToastMessageHTML(message);

	        if (hideAfter) {
	            setTimeout(function () {
	                this$1.clearToastMessage();
	            }, hideAfter * 1000);
	        }
	    }

	    clearToastMessage() {
	        this.instance.toastMessage.innerHTML = '';
	    }

	    getNoDataHTML() {
	        return ("<div class=\"dt-scrollable__no-data\">" + (this.options.noDataMessage) + "</div>");
	    }

	    getToastMessageHTML(message) {
	        return ("<span class=\"dt-toast__message\">" + message + "</span>");
	    }
	}

	class Style {
	    constructor(instance) {
	        this.instance = instance;

	        linkProperties(this, this.instance, [
	            'options', 'datamanager', 'columnmanager',
	            'header', 'footer', 'bodyScrollable', 'datatableWrapper',
	            'getColumn', 'bodyRenderer'
	        ]);

	        this.scopeClass = 'dt-instance-' + instance.constructor.instances;
	        instance.datatableWrapper.classList.add(this.scopeClass);

	        var styleEl = document.createElement('style');
	        instance.wrapper.insertBefore(styleEl, instance.datatableWrapper);
	        this.styleEl = styleEl;

	        this.bindResizeWindow();
	        this.bindScrollHeader();
	    }

	    get stylesheet() {
	        return this.styleEl.sheet;
	    }

	    bindResizeWindow() {
	        this.onWindowResize = this.onWindowResize.bind(this);
	        this.onWindowResize = throttle$1(this.onWindowResize, 300);

	        if (this.options.layout === 'fluid') {
	            $.on(window, 'resize', this.onWindowResize);
	        }
	    }

	    bindScrollHeader() {
	        var this$1 = this;

	        this._settingHeaderPosition = false;

	        $.on(this.bodyScrollable, 'scroll', function (e) {
	            if (this$1._settingHeaderPosition) { return; }

	            this$1._settingHeaderPosition = true;

	            requestAnimationFrame(function () {
	                var left = -e.target.scrollLeft;

	                $.style(this$1.header, {
	                    transform: ("translateX(" + left + "px)")
	                });
	                $.style(this$1.footer, {
	                    transform: ("translateX(" + left + "px)")
	                });
	                this$1._settingHeaderPosition = false;
	            });
	        });
	    }

	    onWindowResize() {
	        this.distributeRemainingWidth();
	        this.refreshColumnWidth();
	        this.setBodyStyle();
	    }

	    destroy() {
	        this.styleEl.remove();
	        $.off(window, 'resize', this.onWindowResize);
	    }

	    setStyle(selector, styleObject) {
	        var this$1 = this;

	        if (selector.includes(',')) {
	            selector.split(',')
	                .map(function (s) { return s.trim(); })
	                .forEach(function (selector) {
	                    this$1.setStyle(selector, styleObject);
	                });
	            return;
	        }

	        selector = selector.trim();
	        if (!selector) { return; }

	        this._styleRulesMap = this._styleRulesMap || {};
	        var prefixedSelector = this._getPrefixedSelector(selector);

	        if (this._styleRulesMap[prefixedSelector]) {
	            this.removeStyle(selector);

	            // merge with old styleobject
	            styleObject = Object.assign({}, this._styleRulesMap[prefixedSelector], styleObject);
	        }

	        var styleString = this._getRuleString(styleObject);
	        var ruleString = prefixedSelector + " { " + styleString + " }";

	        this._styleRulesMap[prefixedSelector] = styleObject;
	        this.stylesheet.insertRule(ruleString);
	    }

	    removeStyle(selector) {
	        var this$1 = this;

	        if (selector.includes(',')) {
	            selector.split(',')
	                .map(function (s) { return s.trim(); })
	                .forEach(function (selector) {
	                    this$1.removeStyle(selector);
	                });
	            return;
	        }

	        selector = selector.trim();
	        if (!selector) { return; }

	        // find and remove
	        var prefixedSelector = this._getPrefixedSelector(selector);
	        var index = Array.from(this.stylesheet.cssRules)
	            .findIndex(function (rule) { return rule.selectorText === prefixedSelector; });

	        if (index === -1) { return; }
	        this.stylesheet.deleteRule(index);
	    }

	    _getPrefixedSelector(selector) {
	        return ("." + (this.scopeClass) + " " + selector);
	    }

	    _getRuleString(styleObject) {
	        return Object.keys(styleObject)
	            .map(function (prop) {
	                var dashed = prop;
	                if (!prop.includes('-')) {
	                    dashed = camelCaseToDash(prop);
	                }
	                return (dashed + ":" + (styleObject[prop]) + ";");
	            })
	            .join('');
	    }

	    setDimensions() {
	        this.setCellHeight();
	        this.setupMinWidth();
	        this.setupNaturalColumnWidth();
	        this.setupColumnWidth();
	        this.distributeRemainingWidth();
	        this.setColumnStyle();
	        this.setBodyStyle();
	    }

	    setCellHeight() {
	        this.setStyle('.dt-cell', {
	            height: this.options.cellHeight + 'px'
	        });
	    }

	    setupMinWidth() {
	        var this$1 = this;

	        $.each('.dt-cell--header', this.header).map(function (col) {
	            var ref = $.data(col);
	            var colIndex = ref.colIndex;
	            var column = this$1.getColumn(colIndex);

	            if (!column.minWidth) {
	                var width = $.style($('.dt-cell__content', col), 'width');
	                // only set this once
	                column.minWidth = width;
	            }
	        });
	    }

	    setupNaturalColumnWidth() {
	        var this$1 = this;

	        if (!$('.dt-row')) { return; }

	        $.each('.dt-row-header .dt-cell', this.header).map(function ($headerCell) {
	            var ref = $.data($headerCell);
	            var colIndex = ref.colIndex;
	            var column = this$1.datamanager.getColumn(colIndex);
	            var width = $.style($('.dt-cell__content', $headerCell), 'width');
	            if (typeof width === 'number' && width >= this$1.options.minimumColumnWidth) {
	                column.naturalWidth = width;
	            } else {
	                column.naturalWidth = this$1.options.minimumColumnWidth;
	            }
	        });

	        // set initial width as naturally calculated by table's first row
	        $.each('.dt-row-0 .dt-cell', this.bodyScrollable).map(function ($cell) {
	            var ref = $.data($cell);
	            var colIndex = ref.colIndex;
	            var column = this$1.datamanager.getColumn(colIndex);

	            var naturalWidth = $.style($('.dt-cell__content', $cell), 'width');

	            if (column.id === '_rowIndex') {
	                naturalWidth = this$1.getRowIndexColumnWidth();
	                column.width = naturalWidth;
	            }

	            if (typeof naturalWidth === 'number' && naturalWidth >= column.naturalWidth) {
	                column.naturalWidth = naturalWidth;
	            } else {
	                column.naturalWidth = column.naturalWidth;
	            }
	        });
	    }

	    setupColumnWidth() {
	        var this$1 = this;

	        if (this.options.layout === 'ratio') {
	            var totalWidth = $.style(this.datatableWrapper, 'width');

	            if (this.options.serialNoColumn) {
	                var rowIndexColumn = this.datamanager.getColumnById('_rowIndex');
	                totalWidth = totalWidth - rowIndexColumn.width - 1;
	            }

	            if (this.options.checkboxColumn) {
	                var rowIndexColumn$1 = this.datamanager.getColumnById('_checkbox');
	                totalWidth = totalWidth - rowIndexColumn$1.width - 1;
	            }

	            var totalParts = this.datamanager.getColumns()
	                .map(function (column) {
	                    if (column.id === '_rowIndex' || column.id === '_checkbox') {
	                        return 0;
	                    }
	                    if (!column.width) {
	                        column.width = 1;
	                    }
	                    column.ratioWidth = parseInt(column.width, 10);
	                    return column.ratioWidth;
	                })
	                .reduce(function (a, c) { return a + c; });

	            var onePart = totalWidth / totalParts;

	            this.datamanager.getColumns()
	                .map(function (column) {
	                    if (column.id === '_rowIndex' || column.id === '_checkbox') { return; }
	                    column.width = Math.floor(onePart * column.ratioWidth) - 1;
	                });
	        } else {
	            this.datamanager.getColumns()
	                .map(function (column) {
	                    if (!column.width) {
	                        column.width = column.naturalWidth;
	                    }
	                    if (column.width < this$1.options.minimumColumnWidth) {
	                        column.width = this$1.options.minimumColumnWidth;
	                    }
	                });
	        }
	    }

	    distributeRemainingWidth() {
	        var this$1 = this;

	        if (this.options.layout !== 'fluid') { return; }

	        var wrapperWidth = $.style(this.instance.datatableWrapper, 'width');
	        var firstRow = $('.dt-row', this.bodyScrollable);
	        var firstRowWidth = wrapperWidth;
	        if (!firstRow) {
	            var headerRow = $('.dt-row', this.instance.header);
	            var cellWidths = Array.from(headerRow.children)
	                .map(function (cell) { return cell.offsetWidth; });
	            firstRowWidth = cellWidths.reduce(function (sum, a) { return sum + a; }, 0);
	        } else {
	            firstRowWidth = $.style(firstRow, 'width');
	        }
	        var resizableColumns = this.datamanager.getColumns().filter(function (col) { return col.resizable; });
	        var deltaWidth = (wrapperWidth - firstRowWidth) / resizableColumns.length;

	        resizableColumns.map(function (col) {
	            var width = $.style(this$1.getColumnHeaderElement(col.colIndex), 'width');
	            var finalWidth = Math.floor(width + deltaWidth) - 2;

	            this$1.datamanager.updateColumn(col.colIndex, {
	                width: finalWidth
	            });
	        });
	    }

	    setColumnStyle() {
	        var this$1 = this;

	        // align columns
	        this.datamanager.getColumns()
	            .map(function (column) {
	                // alignment
	                if (!column.align) {
	                    column.align = 'left';
	                }
	                if (!['left', 'center', 'right'].includes(column.align)) {
	                    column.align = 'left';
	                }
	                this$1.setStyle((".dt-cell--col-" + (column.colIndex)), {
	                    'text-align': column.align
	                });

	                // width
	                this$1.columnmanager.setColumnHeaderWidth(column.colIndex);
	                this$1.columnmanager.setColumnWidth(column.colIndex);
	            });
	    }

	    refreshColumnWidth() {
	        var this$1 = this;

	        this.datamanager.getColumns()
	            .map(function (column) {
	                this$1.columnmanager.setColumnHeaderWidth(column.colIndex);
	                this$1.columnmanager.setColumnWidth(column.colIndex);
	            });
	    }

	    setBodyStyle() {
	        var bodyWidth = $.style(this.datatableWrapper, 'width');
	        var firstRow = $('.dt-row', this.bodyScrollable);
	        if (!firstRow) { return; }
	        var rowWidth = $.style(firstRow, 'width');

	        var width = bodyWidth > rowWidth ? rowWidth : bodyWidth;
	        $.style(this.bodyScrollable, {
	            width: width + 'px'
	        });

	        // remove the body height, so that it resets to it's original
	        $.removeStyle(this.bodyScrollable, 'height');

	        // when there are less rows than the container
	        // adapt the container height
	        var bodyHeight = $.getStyle(this.bodyScrollable, 'height');
	        var scrollHeight = (this.bodyRenderer.hyperlist || {})._scrollHeight || Infinity;
	        var hasHorizontalOverflow = $.hasHorizontalOverflow(this.bodyScrollable);

	        var height;

	        if (scrollHeight < bodyHeight) {
	            height = scrollHeight;

	            // account for scrollbar size when
	            // there is horizontal overflow
	            if (hasHorizontalOverflow) {
	                height += $.scrollbarSize();
	            }

	            $.style(this.bodyScrollable, {
	                height: height + 'px'
	            });
	        }

	        var verticalOverflow = this.bodyScrollable.scrollHeight - this.bodyScrollable.offsetHeight;
	        if (verticalOverflow < $.scrollbarSize()) {
	            // if verticalOverflow is less than scrollbar size
	            // then most likely scrollbar is causing the scroll
	            // which is not needed
	            $.style(this.bodyScrollable, {
	                overflowY: 'hidden'
	            });
	        }

	        if (this.options.layout === 'fluid') {
	            $.style(this.bodyScrollable, {
	                overflowX: 'hidden'
	            });
	        }
	    }

	    getColumnHeaderElement(colIndex) {
	        colIndex = +colIndex;
	        if (colIndex < 0) { return null; }
	        return $((".dt-cell--col-" + colIndex), this.header);
	    }

	    getRowIndexColumnWidth() {
	        var rowCount = this.datamanager.getRowCount();
	        var padding = 22;
	        return $.measureTextWidth(rowCount + '') + padding;
	    }
	}

	var KEYCODES = {
	    13: 'enter',
	    91: 'meta',
	    16: 'shift',
	    17: 'ctrl',
	    18: 'alt',
	    37: 'left',
	    38: 'up',
	    39: 'right',
	    40: 'down',
	    9: 'tab',
	    27: 'esc',
	    67: 'c',
	    70: 'f',
	    86: 'v'
	};

	class Keyboard {
	    constructor(element) {
	        this.listeners = {};
	        $.on(element, 'keydown', this.handler.bind(this));
	    }

	    handler(e) {
	        var key = KEYCODES[e.keyCode];

	        if (e.shiftKey && key !== 'shift') {
	            key = 'shift+' + key;
	        }

	        if ((e.ctrlKey && key !== 'ctrl') || (e.metaKey && key !== 'meta')) {
	            key = 'ctrl+' + key;
	        }

	        var listeners = this.listeners[key];

	        if (listeners && listeners.length > 0) {
	            for (var i = 0, list = listeners; i < list.length; i += 1) {
	                var listener = list[i];

	              var preventBubbling = listener(e);
	                if (preventBubbling === undefined || preventBubbling === true) {
	                    e.preventDefault();
	                }
	            }
	        }
	    }

	    on(key, listener) {
	        var this$1 = this;

	        var keys = key.split(',').map(function (k) { return k.trim(); });

	        keys.map(function (key) {
	            this$1.listeners[key] = this$1.listeners[key] || [];
	            this$1.listeners[key].push(listener);
	        });
	    }
	}

	function filterRows(rows, filters) {
	    var filteredRowIndices = [];

	    if (Object.keys(filters).length === 0) {
	        return rows.map(function (row) { return row.meta.rowIndex; });
	    }

	    var loop = function ( colIndex ) {
	        var keyword = filters[colIndex];

	        var filteredRows = filteredRowIndices.length ?
	            filteredRowIndices.map(function (i) { return rows[i]; }) :
	            rows;

	        var cells = filteredRows.map(function (row) { return row[colIndex]; });

	        var filter = guessFilter(keyword);
	        var filterMethod = getFilterMethod(filter);

	        if (filterMethod) {
	            filteredRowIndices = filterMethod(filter.text, cells);
	        } else {
	            filteredRowIndices = cells.map(function (cell) { return cell.rowIndex; });
	        }
	    };

	    for (var colIndex in filters) loop( colIndex );

	    return filteredRowIndices;
	}
	function getFilterMethod(filter) {
	    var stringCompareValue = function (cell) { return String(stripHTML(cell.html || '') || cell.content || '').toLowerCase(); };

	    var numberCompareValue = function (cell) { return parseFloat(cell.content); };

	    var getCompareValues = function (cell, keyword) {
	        if (cell.column.compareValue) {
	            var compareValues = cell.column.compareValue(cell, keyword);
	            if (compareValues && Array.isArray(compareValues)) { return compareValues; }
	        }

	        // check if it can be converted to number
	        var float = numberCompareValue(cell);
	        if (!isNaN(float)) {
	            return [float, keyword];
	        }

	        return [stringCompareValue(cell), keyword];
	    };

	    var filterMethodMap = {
	        contains: function contains(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var hay = stringCompareValue(cell);
	                    var needle = (keyword || '').toLowerCase();
	                    return !needle || hay.includes(needle);
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        greaterThan: function greaterThan(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var ref = getCompareValues(cell, keyword);
	                    var compareValue = ref[0];
	                    var keywordValue = ref[1];
	                    return compareValue > keywordValue;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        lessThan: function lessThan(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var ref = getCompareValues(cell, keyword);
	                    var compareValue = ref[0];
	                    var keywordValue = ref[1];
	                    return compareValue < keywordValue;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        equals: function equals(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var value = parseFloat(cell.content);
	                    return value === keyword;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        notEquals: function notEquals(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var value = parseFloat(cell.content);
	                    return value !== keyword;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        range: function range(rangeValues, cells) {
	            return cells
	                .filter(function (cell) {
	                    var values1 = getCompareValues(cell, rangeValues[0]);
	                    var values2 = getCompareValues(cell, rangeValues[1]);
	                    var value = values1[0];
	                    return value >= values1[1] && value <= values2[1];
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        containsNumber: function containsNumber(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var number = parseFloat(keyword, 10);
	                    var string = keyword;
	                    var hayNumber = numberCompareValue(cell);
	                    var hayString = stringCompareValue(cell);

	                    return number === hayNumber || hayString.includes(string);
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        }
	    };

	    return filterMethodMap[filter.type];
	}

	function guessFilter(keyword) {
	    if ( keyword === void 0 ) keyword = '';

	    if (keyword.length === 0) { return {}; }

	    var compareString = keyword;

	    if (['>', '<', '='].includes(compareString[0])) {
	        compareString = keyword.slice(1);
	    } else if (compareString.startsWith('!=')) {
	        compareString = keyword.slice(2);
	    }

	    if (keyword.startsWith('>')) {
	        if (compareString) {
	            return {
	                type: 'greaterThan',
	                text: compareString.trim()
	            };
	        }
	    }

	    if (keyword.startsWith('<')) {
	        if (compareString) {
	            return {
	                type: 'lessThan',
	                text: compareString.trim()
	            };
	        }
	    }

	    if (keyword.startsWith('=')) {
	        if (isNumber(compareString)) {
	            return {
	                type: 'equals',
	                text: Number(keyword.slice(1).trim())
	            };
	        }
	    }

	    if (isNumber(compareString)) {
	        return {
	            type: 'containsNumber',
	            text: compareString
	        };
	    }

	    if (keyword.startsWith('!=')) {
	        if (isNumber(compareString)) {
	            return {
	                type: 'notEquals',
	                text: Number(keyword.slice(2).trim())
	            };
	        }
	    }

	    if (keyword.split(':').length === 2) {
	        compareString = keyword.split(':');
	        return {
	            type: 'range',
	            text: compareString.map(function (v) { return v.trim(); })
	        };
	    }

	    return {
	        type: 'contains',
	        text: compareString.toLowerCase()
	    };
	}

	var DEFAULT_OPTIONS = {
	    columns: [],
	    data: [],
	    dropdownButton: icons.chevronDown,
	    headerDropdown: [
	        {
	            label: 'Sort Ascending',
	            action: function (column) {
	                this.sortColumn(column.colIndex, 'asc');
	            }
	        },
	        {
	            label: 'Sort Descending',
	            action: function (column) {
	                this.sortColumn(column.colIndex, 'desc');
	            }
	        },
	        {
	            label: 'Reset sorting',
	            action: function (column) {
	                this.sortColumn(column.colIndex, 'none');
	            }
	        },
	        {
	            label: 'Remove column',
	            action: function (column) {
	                this.removeColumn(column.colIndex);
	            }
	        }
	    ],
	    events: {
	        onRemoveColumn: function onRemoveColumn(column) {},
	        onSwitchColumn: function onSwitchColumn(column1, column2) {},
	        onSortColumn: function onSortColumn(column) {},
	        onCheckRow: function onCheckRow(row) {},
	        onDestroy: function onDestroy() {}
	    },
	    hooks: {
	        columnTotal: null
	    },
	    sortIndicator: {
	        asc: '↑',
	        desc: '↓',
	        none: ''
	    },
	    overrideComponents: {
	        // ColumnManager: CustomColumnManager
	    },
	    filterRows: filterRows,
	    freezeMessage: '',
	    getEditor: null,
	    serialNoColumn: true,
	    checkboxColumn: false,
	    clusterize: true,
	    logs: false,
	    layout: 'fixed', // fixed, fluid, ratio
	    noDataMessage: 'No Data',
	    cellHeight: 40,
	    minimumColumnWidth: 30,
	    inlineFilters: false,
	    treeView: false,
	    checkedRowStatus: true,
	    dynamicRowHeight: false,
	    pasteFromClipboard: false,
	    showTotalRow: false,
	    direction: 'ltr',
	    disableReorderColumn: false
	};

	var defaultComponents = {
	    DataManager: DataManager,
	    CellManager: CellManager,
	    ColumnManager: ColumnManager,
	    RowManager: RowManager,
	    BodyRenderer: BodyRenderer,
	    Style: Style,
	    Keyboard: Keyboard
	};

	class DataTable {
	    constructor(wrapper, options) {
	        DataTable.instances++;

	        if (typeof wrapper === 'string') {
	            // css selector
	            wrapper = document.querySelector(wrapper);
	        }
	        this.wrapper = wrapper;
	        if (!(this.wrapper instanceof HTMLElement)) {
	            throw new Error('Invalid argument given for `wrapper`');
	        }

	        this.buildOptions(options);
	        this.prepare();
	        this.initializeComponents();

	        if (this.options.data) {
	            this.refresh();
	            this.columnmanager.applyDefaultSortOrder();
	        }
	    }

	    buildOptions(options) {
	        this.options = this.options || {};

	        this.options = Object.assign(
	            {}, DEFAULT_OPTIONS,
	            this.options || {}, options
	        );

	        options.headerDropdown = options.headerDropdown || [];
	        this.options.headerDropdown = DEFAULT_OPTIONS.headerDropdown.concat( options.headerDropdown
	        );

	        // custom user events
	        this.events = Object.assign(
	            {}, DEFAULT_OPTIONS.events,
	            this.options.events || {},
	            options.events || {}
	        );
	        this.fireEvent = this.fireEvent.bind(this);
	    }

	    prepare() {
	        this.prepareDom();
	        this.unfreeze();
	    }

	    initializeComponents() {
	        var components = Object.assign({}, defaultComponents, this.options.overrideComponents);
	        var Style$$1 = components.Style;
	        var Keyboard$$1 = components.Keyboard;
	        var DataManager$$1 = components.DataManager;
	        var RowManager$$1 = components.RowManager;
	        var ColumnManager$$1 = components.ColumnManager;
	        var CellManager$$1 = components.CellManager;
	        var BodyRenderer$$1 = components.BodyRenderer;

	        this.style = new Style$$1(this);
	        this.keyboard = new Keyboard$$1(this.wrapper);
	        this.datamanager = new DataManager$$1(this.options);
	        this.rowmanager = new RowManager$$1(this);
	        this.columnmanager = new ColumnManager$$1(this);
	        this.cellmanager = new CellManager$$1(this);
	        this.bodyRenderer = new BodyRenderer$$1(this);
	    }

	    prepareDom() {
	        this.wrapper.innerHTML = "\n            <div class=\"datatable\" dir=\"" + (this.options.direction) + "\">\n                <div class=\"dt-header\"></div>\n                <div class=\"dt-scrollable\"></div>\n                <div class=\"dt-footer\"></div>\n                <div class=\"dt-freeze\">\n                    <span class=\"dt-freeze__message\">\n                        " + (this.options.freezeMessage) + "\n                    </span>\n                </div>\n                <div class=\"dt-toast\"></div>\n                <div class=\"dt-dropdown-container\"></div>\n                <textarea class=\"dt-paste-target\"></textarea>\n            </div>\n        ";

	        this.datatableWrapper = $('.datatable', this.wrapper);
	        this.header = $('.dt-header', this.wrapper);
	        this.footer = $('.dt-footer', this.wrapper);
	        this.bodyScrollable = $('.dt-scrollable', this.wrapper);
	        this.freezeContainer = $('.dt-freeze', this.wrapper);
	        this.toastMessage = $('.dt-toast', this.wrapper);
	        this.pasteTarget = $('.dt-paste-target', this.wrapper);
	        this.dropdownContainer = $('.dt-dropdown-container', this.wrapper);
	    }

	    refresh(data, columns) {
	        this.datamanager.init(data, columns);
	        this.render();
	        this.setDimensions();
	    }

	    destroy() {
	        this.wrapper.innerHTML = '';
	        this.style.destroy();
	        this.fireEvent('onDestroy');
	    }

	    appendRows(rows) {
	        this.datamanager.appendRows(rows);
	        this.rowmanager.refreshRows();
	    }

	    refreshRow(row, rowIndex) {
	        this.rowmanager.refreshRow(row, rowIndex);
	    }

	    render() {
	        this.renderHeader();
	        this.renderBody();
	    }

	    renderHeader() {
	        this.columnmanager.renderHeader();
	    }

	    renderBody() {
	        this.bodyRenderer.render();
	    }

	    setDimensions() {
	        this.style.setDimensions();
	    }

	    showToastMessage(message, hideAfter) {
	        this.bodyRenderer.showToastMessage(message, hideAfter);
	    }

	    clearToastMessage() {
	        this.bodyRenderer.clearToastMessage();
	    }

	    getColumn(colIndex) {
	        return this.datamanager.getColumn(colIndex);
	    }

	    getColumns() {
	        return this.datamanager.getColumns();
	    }

	    getRows() {
	        return this.datamanager.getRows();
	    }

	    getCell(colIndex, rowIndex) {
	        return this.datamanager.getCell(colIndex, rowIndex);
	    }

	    getColumnHeaderElement(colIndex) {
	        return this.columnmanager.getColumnHeaderElement(colIndex);
	    }

	    getViewportHeight() {
	        if (!this.viewportHeight) {
	            this.viewportHeight = $.style(this.bodyScrollable, 'height');
	        }

	        return this.viewportHeight;
	    }

	    sortColumn(colIndex, sortOrder) {
	        this.columnmanager.sortColumn(colIndex, sortOrder);
	    }

	    removeColumn(colIndex) {
	        this.columnmanager.removeColumn(colIndex);
	    }

	    scrollToLastColumn() {
	        this.datatableWrapper.scrollLeft = 9999;
	    }

	    freeze() {
	        $.style(this.freezeContainer, {
	            display: ''
	        });
	    }

	    unfreeze() {
	        $.style(this.freezeContainer, {
	            display: 'none'
	        });
	    }

	    updateOptions(options) {
	        this.buildOptions(options);
	    }

	    fireEvent(eventName) {
	        var args = [], len = arguments.length - 1;
	        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	        // fire internalEventHandlers if any
	        // and then user events
	        var handlers = (this._internalEventHandlers[eventName] || []).concat( [this.events[eventName]]
	        ).filter(Boolean);

	        for (var i = 0, list = handlers; i < list.length; i += 1) {
	            var handler = list[i];

	          handler.apply(this, args);
	        }
	    }

	    on(event, handler) {
	        this._internalEventHandlers = this._internalEventHandlers || {};
	        this._internalEventHandlers[event] = this._internalEventHandlers[event] || [];
	        this._internalEventHandlers[event].push(handler);
	    }

	    log() {
	        if (this.options.logs) {
	            console.log.apply(console, arguments);
	        }
	    }
	}

	DataTable.instances = 0;

	var name = "frappe-datatable";
	var version = "0.0.0-development";
	var description = "A modern datatable library for the web";
	var main = "dist/frappe-datatable.cjs.js";
	var unpkg = "dist/frappe-datatable.min.js";
	var jsdelivr = "dist/frappe-datatable.min.js";
	var scripts = {"start":"yarn run dev","build":"rollup -c && NODE_ENV=production rollup -c","dev":"rollup -c -w","cy:server":"http-server -p 8989","cy:open":"cypress open","cy:run":"cypress run","test":"start-server-and-test cy:server http://localhost:8989 cy:run","test-local":"start-server-and-test cy:server http://localhost:8989 cy:open","travis-deploy-once":"travis-deploy-once","semantic-release":"semantic-release","lint":"eslint src","commit":"npx git-cz"};
	var files = ["dist","src"];
	var devDependencies = {"autoprefixer":"^9.0.0","chai":"3.5.0","cypress":"3.0.1","cz-conventional-changelog":"^2.1.0","deepmerge":"^2.0.1","eslint":"^5.0.1","eslint-config-airbnb":"^16.1.0","eslint-config-airbnb-base":"^12.1.0","eslint-plugin-import":"^2.11.0","http-server":"^0.11.1","mocha":"3.3.0","postcss-custom-properties":"^7.0.0","postcss-nested":"^3.0.0","rollup":"^0.59.4","rollup-plugin-commonjs":"^8.3.0","rollup-plugin-eslint":"^4.0.0","rollup-plugin-json":"^2.3.0","rollup-plugin-node-resolve":"^3.0.3","rollup-plugin-postcss":"^1.2.8","rollup-plugin-uglify-es":"^0.0.1","semantic-release":"^15.6.3","start-server-and-test":"^1.4.1","travis-deploy-once":"^5.0.1"};
	var repository = {"type":"git","url":"https://github.com/frappe/datatable.git"};
	var keywords = ["datatable","data","grid","table"];
	var author = "Faris Ansari";
	var license = "MIT";
	var bugs = {"url":"https://github.com/frappe/datatable/issues"};
	var homepage = "https://frappe.github.io/datatable";
	var dependencies = {"hyperlist":"^1.0.0-beta","lodash":"^4.17.5","sortablejs":"^1.7.0"};
	var config = {"commitizen":{"path":"cz-conventional-changelog"}};
	var packageJson = {
		name: name,
		version: version,
		description: description,
		main: main,
		unpkg: unpkg,
		jsdelivr: jsdelivr,
		scripts: scripts,
		files: files,
		devDependencies: devDependencies,
		repository: repository,
		keywords: keywords,
		author: author,
		license: license,
		bugs: bugs,
		homepage: homepage,
		dependencies: dependencies,
		config: config
	};

	DataTable.__version__ = packageJson.version;

	module.exports = DataTable;
	});

	var DataTable = unwrapExports(frappeDatatable_cjs);

	frappe.DataTable = DataTable;

	var driver_min = createCommonjsModule(function (module, exports) {
	!function(t,e){module.exports=e();}(window,function(){return function(t){var e={};function n(o){if(e[o]){ return e[o].exports; }var i=e[o]={i:o,l:!1,exports:{}};return t[o].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,o){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o});},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0});},n.t=function(t,e){if(1&e&&(t=n(t)),8&e){ return t; }if(4&e&&"object"==typeof t&&t&&t.__esModule){ return t; }var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t){ for(var i in t){ n.d(o,i,function(e){return t[e]}.bind(null,i)); } }return o},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="/dist/",n(n.s=57)}([function(t,e,n){var o=n(2),i=n(11),r=n(4),s=n(13),a=n(22),c=function(t,e,n){var u,l,h,f,p=t&c.F,d=t&c.G,v=t&c.S,y=t&c.P,g=t&c.B,m=d?o:v?o[e]||(o[e]={}):(o[e]||{}).prototype,b=d?i:i[e]||(i[e]={}),w=b.prototype||(b.prototype={});for(u in d&&(n=e),n){ h=((l=!p&&m&&void 0!==m[u])?m:n)[u],f=g&&l?a(h,o):y&&"function"==typeof h?a(Function.call,h):h,m&&s(m,u,h,t&c.U),b[u]!=h&&r(b,u,f),y&&w[u]!=h&&(w[u]=h); }};o.core=i,c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,t.exports=c;},function(t,e,n){var o=n(17)("wks"),i=n(14),r=n(2).Symbol,s="function"==typeof r;(t.exports=function(t){return o[t]||(o[t]=s&&r[t]||(s?r:i)("Symbol."+t))}).store=o;},function(t,e){var n=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=n);},function(t,e){t.exports=function(t){return "object"==typeof t?null!==t:"function"==typeof t};},function(t,e,n){var o=n(5),i=n(16);t.exports=n(6)?function(t,e,n){return o.f(t,e,i(1,n))}:function(t,e,n){return t[e]=n,t};},function(t,e,n){var o=n(12),i=n(35),r=n(21),s=Object.defineProperty;e.f=n(6)?Object.defineProperty:function(t,e,n){if(o(t),e=r(e,!0),o(n),i){ try{return s(t,e,n)}catch(t){} }if("get"in n||"set"in n){ throw TypeError("Accessors not supported!"); }return "value"in n&&(t[e]=n.value),t};},function(t,e,n){t.exports=!n(7)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a});},function(t,e){t.exports=function(t){try{return !!t()}catch(t){return !0}};},function(t,e){var n={}.hasOwnProperty;t.exports=function(t,e){return n.call(t,e)};},function(t,e,n){var o=n(39),i=n(24);t.exports=function(t){return o(i(t))};},function(t,e,n){var o=n(0);o(o.S+o.F*!n(6),"Object",{defineProperty:n(5).f});},function(t,e){var n=t.exports={version:"2.6.9"};"number"==typeof __e&&(__e=n);},function(t,e,n){var o=n(3);t.exports=function(t){if(!o(t)){ throw TypeError(t+" is not an object!"); }return t};},function(t,e,n){var o=n(2),i=n(4),r=n(8),s=n(14)("src"),a=n(59),c=(""+a).split("toString");n(11).inspectSource=function(t){return a.call(t)},(t.exports=function(t,e,n,a){var u="function"==typeof n;u&&(r(n,"name")||i(n,"name",e)),t[e]!==n&&(u&&(r(n,s)||i(n,s,t[e]?""+t[e]:c.join(String(e)))),t===o?t[e]=n:a?t[e]?t[e]=n:i(t,e,n):(delete t[e],i(t,e,n)));})(Function.prototype,"toString",function(){return "function"==typeof this&&this[s]||a.call(this)});},function(t,e){var n=0,o=Math.random();t.exports=function(t){return "Symbol(".concat(void 0===t?"":t,")_",(++n+o).toString(36))};},function(t,e,n){var o=n(45),i=n(28);t.exports=Object.keys||function(t){return o(t,i)};},function(t,e){t.exports=function(t,e){return {enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}};},function(t,e,n){var o=n(11),i=n(2),r=i["__core-js_shared__"]||(i["__core-js_shared__"]={});(t.exports=function(t,e){return r[t]||(r[t]=void 0!==e?e:{})})("versions",[]).push({version:o.version,mode:n(18)?"pure":"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"});},function(t,e){t.exports=!1;},function(t,e,n){var o=n(24);t.exports=function(t){return Object(o(t))};},function(t,e,n){var o=n(2),i=n(8),r=n(6),s=n(0),a=n(13),c=n(62).KEY,u=n(7),l=n(17),h=n(26),f=n(14),p=n(1),d=n(43),v=n(44),y=n(63),g=n(42),m=n(12),b=n(3),w=n(19),x=n(9),S=n(21),O=n(16),k=n(30),P=n(67),E=n(49),N=n(47),j=n(5),L=n(15),T=E.f,C=j.f,_=P.f,M=o.Symbol,H=o.JSON,B=H&&H.stringify,F=p("_hidden"),I=p("toPrimitive"),R={}.propertyIsEnumerable,A=l("symbol-registry"),z=l("symbols"),D=l("op-symbols"),V=Object.prototype,W="function"==typeof M&&!!N.f,q=o.QObject,G=!q||!q.prototype||!q.prototype.findChild,K=r&&u(function(){return 7!=k(C({},"a",{get:function(){return C(this,"a",{value:7}).a}})).a})?function(t,e,n){var o=T(V,e);o&&delete V[e],C(t,e,n),o&&t!==V&&C(V,e,o);}:C,U=function(t){var e=z[t]=k(M.prototype);return e._k=t,e},Y=W&&"symbol"==typeof M.iterator?function(t){return "symbol"==typeof t}:function(t){return t instanceof M},J=function(t,e,n){return t===V&&J(D,e,n),m(t),e=S(e,!0),m(n),i(z,e)?(n.enumerable?(i(t,F)&&t[F][e]&&(t[F][e]=!1),n=k(n,{enumerable:O(0,!1)})):(i(t,F)||C(t,F,O(1,{})),t[F][e]=!0),K(t,e,n)):C(t,e,n)},X=function(t,e){m(t);for(var n,o=y(e=x(e)),i=0,r=o.length;r>i;){ J(t,n=o[i++],e[n]); }return t},Q=function(t){var e=R.call(this,t=S(t,!0));return !(this===V&&i(z,t)&&!i(D,t))&&(!(e||!i(this,t)||!i(z,t)||i(this,F)&&this[F][t])||e)},$=function(t,e){if(t=x(t),e=S(e,!0),t!==V||!i(z,e)||i(D,e)){var n=T(t,e);return !n||!i(z,e)||i(t,F)&&t[F][e]||(n.enumerable=!0),n}},Z=function(t){for(var e,n=_(x(t)),o=[],r=0;n.length>r;){ i(z,e=n[r++])||e==F||e==c||o.push(e); }return o},tt=function(t){for(var e,n=t===V,o=_(n?D:x(t)),r=[],s=0;o.length>s;){ !i(z,e=o[s++])||n&&!i(V,e)||r.push(z[e]); }return r};W||(a((M=function(){if(this instanceof M){ throw TypeError("Symbol is not a constructor!"); }var t=f(arguments.length>0?arguments[0]:void 0),e=function(n){this===V&&e.call(D,n),i(this,F)&&i(this[F],t)&&(this[F][t]=!1),K(this,t,O(1,n));};return r&&G&&K(V,t,{configurable:!0,set:e}),U(t)}).prototype,"toString",function(){return this._k}),E.f=$,j.f=J,n(48).f=P.f=Z,n(29).f=Q,N.f=tt,r&&!n(18)&&a(V,"propertyIsEnumerable",Q,!0),d.f=function(t){return U(p(t))}),s(s.G+s.W+s.F*!W,{Symbol:M});for(var et="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),nt=0;et.length>nt;){ p(et[nt++]); }for(var ot=L(p.store),it=0;ot.length>it;){ v(ot[it++]); }s(s.S+s.F*!W,"Symbol",{for:function(t){return i(A,t+="")?A[t]:A[t]=M(t)},keyFor:function(t){if(!Y(t)){ throw TypeError(t+" is not a symbol!"); }for(var e in A){ if(A[e]===t){ return e } }},useSetter:function(){G=!0;},useSimple:function(){G=!1;}}),s(s.S+s.F*!W,"Object",{create:function(t,e){return void 0===e?k(t):X(k(t),e)},defineProperty:J,defineProperties:X,getOwnPropertyDescriptor:$,getOwnPropertyNames:Z,getOwnPropertySymbols:tt});var rt=u(function(){N.f(1);});s(s.S+s.F*rt,"Object",{getOwnPropertySymbols:function(t){return N.f(w(t))}}),H&&s(s.S+s.F*(!W||u(function(){var t=M();return "[null]"!=B([t])||"{}"!=B({a:t})||"{}"!=B(Object(t))})),"JSON",{stringify:function(t){
	var arguments$1 = arguments;
	for(var e,n,o=[t],i=1;arguments.length>i;){ o.push(arguments$1[i++]); }if(n=e=o[1],(b(e)||void 0!==t)&&!Y(t)){ return g(e)||(e=function(t,e){if("function"==typeof n&&(e=n.call(this,t,e)),!Y(e)){ return e }}),o[1]=e,B.apply(H,o) }}}),M.prototype[I]||n(4)(M.prototype,I,M.prototype.valueOf),h(M,"Symbol"),h(Math,"Math",!0),h(o.JSON,"JSON",!0);},function(t,e,n){var o=n(3);t.exports=function(t,e){if(!o(t)){ return t; }var n,i;if(e&&"function"==typeof(n=t.toString)&&!o(i=n.call(t))){ return i; }if("function"==typeof(n=t.valueOf)&&!o(i=n.call(t))){ return i; }if(!e&&"function"==typeof(n=t.toString)&&!o(i=n.call(t))){ return i; }throw TypeError("Can't convert object to primitive value")};},function(t,e,n){var o=n(37);t.exports=function(t,e,n){if(o(t),void 0===e){ return t; }switch(n){case 1:return function(n){return t.call(e,n)};case 2:return function(n,o){return t.call(e,n,o)};case 3:return function(n,o,i){return t.call(e,n,o,i)}}return function(){return t.apply(e,arguments)}};},function(t,e){var n={}.toString;t.exports=function(t){return n.call(t).slice(8,-1)};},function(t,e){t.exports=function(t){if(null==t){ throw TypeError("Can't call method on  "+t); }return t};},function(t,e,n){var o=n(7);t.exports=function(t,e){return !!t&&o(function(){e?t.call(null,function(){},1):t.call(null);})};},function(t,e,n){var o=n(5).f,i=n(8),r=n(1)("toStringTag");t.exports=function(t,e,n){t&&!i(t=n?t:t.prototype,r)&&o(t,r,{configurable:!0,value:e});};},function(t,e,n){var o=n(17)("keys"),i=n(14);t.exports=function(t){return o[t]||(o[t]=i(t))};},function(t,e){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");},function(t,e){e.f={}.propertyIsEnumerable;},function(t,e,n){var o=n(12),i=n(65),r=n(28),s=n(27)("IE_PROTO"),a=function(){},c=function(){var t,e=n(36)("iframe"),o=r.length;for(e.style.display="none",n(66).appendChild(e),e.src="javascript:",(t=e.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),c=t.F;o--;){ delete c.prototype[r[o]]; }return c()};t.exports=Object.create||function(t,e){var n;return null!==t?(a.prototype=o(t),n=new a,a.prototype=null,n[s]=t):n=c(),void 0===e?n:i(n,e)};},function(t,e,n){var o=n(68),i=n(69),r=n(32),s=n(9);t.exports=n(70)(Array,"Array",function(t,e){this._t=s(t),this._i=0,this._k=e;},function(){var t=this._t,e=this._k,n=this._i++;return !t||n>=t.length?(this._t=void 0,i(1)):i(0,"keys"==e?n:"values"==e?t[n]:[n,t[n]])},"values"),r.Arguments=r.Array,o("keys"),o("values"),o("entries");},function(t,e){t.exports={};},function(t,e,n){n(44)("asyncIterator");},function(t,e,n){var o=n(0),i=n(38)(0),r=n(25)([].forEach,!0);o(o.P+o.F*!r,"Array",{forEach:function(t){return i(this,t,arguments[1])}});},function(t,e,n){t.exports=!n(6)&&!n(7)(function(){return 7!=Object.defineProperty(n(36)("div"),"a",{get:function(){return 7}}).a});},function(t,e,n){var o=n(3),i=n(2).document,r=o(i)&&o(i.createElement);t.exports=function(t){return r?i.createElement(t):{}};},function(t,e){t.exports=function(t){if("function"!=typeof t){ throw TypeError(t+" is not a function!"); }return t};},function(t,e,n){var o=n(22),i=n(39),r=n(19),s=n(40),a=n(60);t.exports=function(t,e){var n=1==t,c=2==t,u=3==t,l=4==t,h=6==t,f=5==t||h,p=e||a;return function(e,a,d){for(var v,y,g=r(e),m=i(g),b=o(a,d,3),w=s(m.length),x=0,S=n?p(e,w):c?p(e,0):void 0;w>x;x++){ if((f||x in m)&&(y=b(v=m[x],x,g),t)){ if(n){ S[x]=y; }else if(y){ switch(t){case 3:return !0;case 5:return v;case 6:return x;case 2:S.push(v);} }else if(l){ return !1; } } }return h?-1:u||l?l:S}};},function(t,e,n){var o=n(23);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return "String"==o(t)?t.split(""):Object(t)};},function(t,e,n){var o=n(41),i=Math.min;t.exports=function(t){return t>0?i(o(t),9007199254740991):0};},function(t,e){var n=Math.ceil,o=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?o:n)(t)};},function(t,e,n){var o=n(23);t.exports=Array.isArray||function(t){return "Array"==o(t)};},function(t,e,n){e.f=n(1);},function(t,e,n){var o=n(2),i=n(11),r=n(18),s=n(43),a=n(5).f;t.exports=function(t){var e=i.Symbol||(i.Symbol=r?{}:o.Symbol||{});"_"==t.charAt(0)||t in e||a(e,t,{value:s.f(t)});};},function(t,e,n){var o=n(8),i=n(9),r=n(46)(!1),s=n(27)("IE_PROTO");t.exports=function(t,e){var n,a=i(t),c=0,u=[];for(n in a){ n!=s&&o(a,n)&&u.push(n); }for(;e.length>c;){ o(a,n=e[c++])&&(~r(u,n)||u.push(n)); }return u};},function(t,e,n){var o=n(9),i=n(40),r=n(64);t.exports=function(t){return function(e,n,s){var a,c=o(e),u=i(c.length),l=r(s,u);if(t&&n!=n){for(;u>l;){ if((a=c[l++])!=a){ return !0 } }}else { for(;u>l;l++){ if((t||l in c)&&c[l]===n){ return t||l||0; } } }return !t&&-1}};},function(t,e){e.f=Object.getOwnPropertySymbols;},function(t,e,n){var o=n(45),i=n(28).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(t){return o(t,i)};},function(t,e,n){var o=n(29),i=n(16),r=n(9),s=n(21),a=n(8),c=n(35),u=Object.getOwnPropertyDescriptor;e.f=n(6)?u:function(t,e){if(t=r(t),e=s(e,!0),c){ try{return u(t,e)}catch(t){} }if(a(t,e)){ return i(!o.f.call(t,e),t[e]) }};},function(t,e,n){for(var o=n(31),i=n(15),r=n(13),s=n(2),a=n(4),c=n(32),u=n(1),l=u("iterator"),h=u("toStringTag"),f=c.Array,p={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},d=i(p),v=0;v<d.length;v++){var y,g=d[v],m=p[g],b=s[g],w=b&&b.prototype;if(w&&(w[l]||a(w,l,f),w[h]||a(w,h,g),c[g]=f,m)){ for(y in o){ w[y]||r(w,y,o[y],!0); } }}},function(t,e,n){var o=n(73),i={};i[n(1)("toStringTag")]="z",i+""!="[object z]"&&n(13)(Object.prototype,"toString",function(){return "[object "+o(this)+"]"},!0);},function(t,e,n){var o=n(19),i=n(15);n(74)("keys",function(){return function(t){return i(o(t))}});},function(t,e,n){var o=n(0),i=n(38)(2);o(o.P+o.F*!n(25)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}});},function(t,e,n){var o=n(0);o(o.P,"Function",{bind:n(75)});},function(t,e,n){var o=n(0);o(o.S,"Object",{create:n(30)});},function(t,e,n){var o=n(0);o(o.S,"Object",{setPrototypeOf:n(81).set});},function(t,e,n){n(58),t.exports=n(82);},function(t,e){},function(t,e,n){t.exports=n(17)("native-function-to-string",Function.toString);},function(t,e,n){var o=n(61);t.exports=function(t,e){return new(o(t))(e)};},function(t,e,n){var o=n(3),i=n(42),r=n(1)("species");t.exports=function(t){var e;return i(t)&&("function"!=typeof(e=t.constructor)||e!==Array&&!i(e.prototype)||(e=void 0),o(e)&&null===(e=e[r])&&(e=void 0)),void 0===e?Array:e};},function(t,e,n){var o=n(14)("meta"),i=n(3),r=n(8),s=n(5).f,a=0,c=Object.isExtensible||function(){return !0},u=!n(7)(function(){return c(Object.preventExtensions({}))}),l=function(t){s(t,o,{value:{i:"O"+ ++a,w:{}}});},h=t.exports={KEY:o,NEED:!1,fastKey:function(t,e){if(!i(t)){ return "symbol"==typeof t?t:("string"==typeof t?"S":"P")+t; }if(!r(t,o)){if(!c(t)){ return "F"; }if(!e){ return "E"; }l(t);}return t[o].i},getWeak:function(t,e){if(!r(t,o)){if(!c(t)){ return !0; }if(!e){ return !1; }l(t);}return t[o].w},onFreeze:function(t){return u&&h.NEED&&c(t)&&!r(t,o)&&l(t),t}};},function(t,e,n){var o=n(15),i=n(47),r=n(29);t.exports=function(t){var e=o(t),n=i.f;if(n){ for(var s,a=n(t),c=r.f,u=0;a.length>u;){ c.call(t,s=a[u++])&&e.push(s); } }return e};},function(t,e,n){var o=n(41),i=Math.max,r=Math.min;t.exports=function(t,e){return (t=o(t))<0?i(t+e,0):r(t,e)};},function(t,e,n){var o=n(5),i=n(12),r=n(15);t.exports=n(6)?Object.defineProperties:function(t,e){i(t);for(var n,s=r(e),a=s.length,c=0;a>c;){ o.f(t,n=s[c++],e[n]); }return t};},function(t,e,n){var o=n(2).document;t.exports=o&&o.documentElement;},function(t,e,n){var o=n(9),i=n(48).f,r={}.toString,s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return s&&"[object Window]"==r.call(t)?function(t){try{return i(t)}catch(t){return s.slice()}}(t):i(o(t))};},function(t,e,n){var o=n(1)("unscopables"),i=Array.prototype;null==i[o]&&n(4)(i,o,{}),t.exports=function(t){i[o][t]=!0;};},function(t,e){t.exports=function(t,e){return {value:e,done:!!t}};},function(t,e,n){var o=n(18),i=n(0),r=n(13),s=n(4),a=n(32),c=n(71),u=n(26),l=n(72),h=n(1)("iterator"),f=!([].keys&&"next"in[].keys()),p=function(){return this};t.exports=function(t,e,n,d,v,y,g){c(n,e,d);var m,b,w,x=function(t){if(!f&&t in P){ return P[t]; }switch(t){case"keys":case"values":return function(){return new n(this,t)}}return function(){return new n(this,t)}},S=e+" Iterator",O="values"==v,k=!1,P=t.prototype,E=P[h]||P["@@iterator"]||v&&P[v],N=E||x(v),j=v?O?x("entries"):N:void 0,L="Array"==e&&P.entries||E;if(L&&(w=l(L.call(new t)))!==Object.prototype&&w.next&&(u(w,S,!0),o||"function"==typeof w[h]||s(w,h,p)),O&&E&&"values"!==E.name&&(k=!0,N=function(){return E.call(this)}),o&&!g||!f&&!k&&P[h]||s(P,h,N),a[e]=N,a[S]=p,v){ if(m={values:O?N:x("values"),keys:y?N:x("keys"),entries:j},g){ for(b in m){ b in P||r(P,b,m[b]); } }else { i(i.P+i.F*(f||k),e,m); } }return m};},function(t,e,n){var o=n(30),i=n(16),r=n(26),s={};n(4)(s,n(1)("iterator"),function(){return this}),t.exports=function(t,e,n){t.prototype=o(s,{next:i(1,n)}),r(t,e+" Iterator");};},function(t,e,n){var o=n(8),i=n(19),r=n(27)("IE_PROTO"),s=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),o(t,r)?t[r]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?s:null};},function(t,e,n){var o=n(23),i=n(1)("toStringTag"),r="Arguments"==o(function(){return arguments}());t.exports=function(t){var e,n,s;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(n=function(t,e){try{return t[e]}catch(t){}}(e=Object(t),i))?n:r?o(e):"Object"==(s=o(e))&&"function"==typeof e.callee?"Arguments":s};},function(t,e,n){var o=n(0),i=n(11),r=n(7);t.exports=function(t,e){var n=(i.Object||{})[t]||Object[t],s={};s[t]=e(n),o(o.S+o.F*r(function(){n(1);}),"Object",s);};},function(t,e,n){var o=n(37),i=n(3),r=n(76),s=[].slice,a={};t.exports=Function.bind||function(t){var e=o(this),n=s.call(arguments,1),c=function(){var o=n.concat(s.call(arguments));return this instanceof c?function(t,e,n){if(!(e in a)){for(var o=[],i=0;i<e;i++){ o[i]="a["+i+"]"; }a[e]=Function("F,a","return new F("+o.join(",")+")");}return a[e](t,n)}(e,o.length,o):r(e,o,t)};return i(e.prototype)&&(c.prototype=e.prototype),c};},function(t,e){t.exports=function(t,e,n){var o=void 0===n;switch(e.length){case 0:return o?t():t.call(n);case 1:return o?t(e[0]):t.call(n,e[0]);case 2:return o?t(e[0],e[1]):t.call(n,e[0],e[1]);case 3:return o?t(e[0],e[1],e[2]):t.call(n,e[0],e[1],e[2]);case 4:return o?t(e[0],e[1],e[2],e[3]):t.call(n,e[0],e[1],e[2],e[3])}return t.apply(n,e)};},function(t,e,n){n(78)("trim",function(t){return function(){return t(this,3)}});},function(t,e,n){var o=n(0),i=n(24),r=n(7),s=n(79),a="["+s+"]",c=RegExp("^"+a+a+"*"),u=RegExp(a+a+"*$"),l=function(t,e,n){var i={},a=r(function(){return !!s[t]()||"​"!="​"[t]()}),c=i[t]=a?e(h):s[t];n&&(i[n]=c),o(o.P+o.F*a,"String",i);},h=l.trim=function(t,e){return t=String(i(t)),1&e&&(t=t.replace(c,"")),2&e&&(t=t.replace(u,"")),t};t.exports=l;},function(t,e){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff";},function(t,e,n){var o=n(0),i=n(46)(!1),r=[].indexOf,s=!!r&&1/[1].indexOf(1,-0)<0;o(o.P+o.F*(s||!n(25)(r)),"Array",{indexOf:function(t){return s?r.apply(this,arguments)||0:i(this,t,arguments[1])}});},function(t,e,n){var o=n(3),i=n(12),r=function(t,e){if(i(t),!o(e)&&null!==e){ throw TypeError(e+": can't set as prototype!") }};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,e,o){try{(o=n(22)(Function.call,n(49).f(Object.prototype,"__proto__").set,2))(t,[]),e=!(t instanceof Array);}catch(t){e=!0;}return function(t,n){return r(t,n),e?t.__proto__=n:o(t,n),t}}({},!1):void 0),check:r};},function(t,e,n){n.r(e);n(34),n(20),n(50),n(31),n(51),n(52),n(10),n(53),n(54);var o=.75,i=10,r=!0,s=!0,a=!0,c=!1,u="driver-highlighted-element-stage",l='<div id="'.concat("driver-page-overlay",'"></div>'),h='<div id="'.concat(u,'"></div>');n(33),n(77);function f(t){return (f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}var p=function(t){var e=document.createElement("div");return e.innerHTML=t.trim(),e.firstChild},d=function t(e,n){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2]){for(var o=["","-webkit-","-ms-","moz-","-o-"],i=0;i<o.length;i++){var r=t(e,o[i]+n);if(r){ return r }}return ""}var s="";return e.currentStyle?s=e.currentStyle[n]:document.defaultView&&document.defaultView.getComputedStyle&&(s=document.defaultView.getComputedStyle(e,null).getPropertyValue(n)),s&&s.toLowerCase?s.toLowerCase():s},v=function(t){return t&&"object"===f(t)&&"nodeType"in t};function y(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o);}}var g=function(){function t(e,n,o){!function(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}(this,t),this.options=e,this.highlightedElement=null,this.lastHighlightedElement=null,this.hideTimer=null,this.window=n,this.document=o,this.removeNode=this.removeNode.bind(this);}var e,n;return e=t,(n=[{key:"attachNode",value:function(){var t=this.document.getElementById("driver-page-overlay");t||(t=p(l),document.body.appendChild(t)),this.node=t,this.node.style.opacity="0",this.options.animate||this.node.parentElement&&this.node.parentElement.removeChild(this.node);}},{key:"highlight",value:function(t){t&&t.node?t.isSame(this.highlightedElement)||(this.window.clearTimeout(this.hideTimer),t.onHighlightStarted(),this.highlightedElement&&!this.highlightedElement.isSame(this.lastHighlightedElement)&&this.highlightedElement.onDeselected(),t.getCalculatedPosition().canHighlight()&&(this.lastHighlightedElement=this.highlightedElement,this.highlightedElement=t,this.show(),this.highlightedElement.onHighlighted())):console.warn("Invalid element to highlight. Must be an instance of `Element`");}},{key:"show",value:function(){var t=this;this.node&&this.node.parentElement||(this.attachNode(),window.setTimeout(function(){t.node.style.opacity="".concat(t.options.opacity),t.node.style.position="fixed",t.node.style.left="0",t.node.style.top="0",t.node.style.bottom="0",t.node.style.right="0";}));}},{key:"getHighlightedElement",value:function(){return this.highlightedElement}},{key:"getLastHighlightedElement",value:function(){return this.lastHighlightedElement}},{key:"clear",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.options.onReset&&this.options.onReset(this.highlightedElement),this.highlightedElement){this.highlightedElement.onDeselected(!0);}this.highlightedElement=null,this.lastHighlightedElement=null,this.node&&(this.window.clearTimeout(this.hideTimer),this.options.animate&&!t?(this.node.style.opacity="0",this.hideTimer=this.window.setTimeout(this.removeNode,300)):this.removeNode());}},{key:"removeNode",value:function(){this.node&&this.node.parentElement&&this.node.parentElement.removeChild(this.node);}},{key:"refresh",value:function(){this.highlightedElement&&(this.highlightedElement.showPopover(),this.highlightedElement.showStage());}}])&&y(e.prototype,n),t}();n(80);function m(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o);}}var b=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.left,o=void 0===n?0:n,i=e.top,r=void 0===i?0:i,s=e.right,a=void 0===s?0:s,c=e.bottom,u=void 0===c?0:c;!function(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}(this,t),this.left=o,this.right=a,this.top=r,this.bottom=u;}var e,n;return e=t,(n=[{key:"canHighlight",value:function(){return this.left<this.right&&this.top<this.bottom}}])&&m(e.prototype,n),t}();function w(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o);}}var x=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.node,o=e.options,i=e.popover,r=e.stage,s=e.overlay,a=e.window,c=e.document;!function(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}(this,t),this.node=n,this.document=c,this.window=a,this.options=o,this.overlay=s,this.popover=i,this.stage=r,this.animationTimeout=null;}var e,n;return e=t,(n=[{key:"isInView",value:function(){for(var t=this.node.offsetTop,e=this.node.offsetLeft,n=this.node.offsetWidth,o=this.node.offsetHeight,i=this.node;i.offsetParent;){ t+=(i=i.offsetParent).offsetTop,e+=i.offsetLeft; }return t>=this.window.pageYOffset&&e>=this.window.pageXOffset&&t+o<=this.window.pageYOffset+this.window.innerHeight&&e+n<=this.window.pageXOffset+this.window.innerWidth}},{key:"scrollManually",value:function(){var t=this.node.getBoundingClientRect().top+this.window.pageYOffset-this.window.innerHeight/2;this.window.scrollTo(0,t);}},{key:"bringInView",value:function(){if(this.node&&!this.isInView()){ if(this.node.scrollIntoView){ try{this.node.scrollIntoView(this.options.scrollIntoViewOptions||{behavior:"instant",block:"center"});}catch(t){this.scrollManually();} }else { this.scrollManually(); } }}},{key:"getCalculatedPosition",value:function(){var t=this.document.body,e=this.document.documentElement,n=this.window,o=this.window.pageYOffset||e.scrollTop||t.scrollTop,i=n.pageXOffset||e.scrollLeft||t.scrollLeft,r=this.node.getBoundingClientRect();return new b({top:r.top+o,left:r.left+i,right:r.left+i+r.width,bottom:r.top+o+r.height})}},{key:"getPopover",value:function(){return this.popover}},{key:"onDeselected",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.hidePopover(),t&&this.hideStage(),this.removeHighlightClasses(),this.window.clearTimeout(this.animationTimeout),this.options.onDeselected&&this.options.onDeselected(this);}},{key:"isSame",value:function(t){return !(!t||!t.node)&&t.node===this.node}},{key:"onHighlightStarted",value:function(){this.options.onHighlightStarted&&this.options.onHighlightStarted(this);}},{key:"onHighlighted",value:function(){this.isInView()||this.bringInView(),this.showPopover(),this.showStage(),this.addHighlightClasses(),this.options.onHighlighted&&this.options.onHighlighted(this);}},{key:"removeHighlightClasses",value:function(){this.node.classList.remove("driver-highlighted-element"),this.node.classList.remove("driver-position-relative");for(var t=this.document.querySelectorAll(".".concat("driver-fix-stacking")),e=0;e<t.length;e++){ t[e].classList.remove("driver-fix-stacking"); }}},{key:"addHighlightClasses",value:function(){this.node.classList.add("driver-highlighted-element"),this.canMakeRelative()&&this.node.classList.add("driver-position-relative"),this.fixStackingContext();}},{key:"fixStackingContext",value:function(){for(var t=this.node.parentNode;t&&t.tagName&&"body"!==t.tagName.toLowerCase();){var e=d(t,"z-index"),n=parseFloat(d(t,"opacity")),o=d(t,"transform",!0),i=d(t,"transform-style",!0),r=d(t,"transform-box",!0),s=d(t,"filter",!0),a=d(t,"perspective",!0);(/[0-9]+/.test(e)||n<1||o&&"none"!==o||i&&"flat"!==i||r&&"border-box"!==r||s&&"none"!==s||a&&"none"!==a)&&t.classList.add("driver-fix-stacking"),t=t.parentNode;}}},{key:"canMakeRelative",value:function(){var t=this.getStyleProperty("position");return -1===["absolute","fixed","relative"].indexOf(t)}},{key:"getStyleProperty",value:function(t){return d(this.node,t)}},{key:"showStage",value:function(){this.stage.show(this.getCalculatedPosition());}},{key:"getNode",value:function(){return this.node}},{key:"hideStage",value:function(){this.stage.hide();}},{key:"hidePopover",value:function(){this.popover&&this.popover.hide();}},{key:"showPopover",value:function(){var t=this;if(this.popover){var e=this.getCalculatedPosition(),n=300;this.options.animate&&this.overlay.lastHighlightedElement||(n=0),this.animationTimeout=this.window.setTimeout(function(){t.popover.show(e);},n);}}},{key:"getFullPageSize",value:function(){var t=this.document.body,e=this.document.documentElement;return {height:Math.max(t.scrollHeight,t.offsetHeight,e.scrollHeight,e.offsetHeight),width:Math.max(t.scrollWidth,t.offsetWidth,e.scrollWidth,e.offsetWidth)}}},{key:"getSize",value:function(){return {height:Math.max(this.node.scrollHeight,this.node.offsetHeight),width:Math.max(this.node.scrollWidth,this.node.offsetWidth)}}}])&&w(e.prototype,n),t}();n(55),n(56);function S(t){return (S="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function O(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function k(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o);}}function P(t,e){return !e||"object"!==S(e)&&"function"!=typeof e?function(t){if(void 0===t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return t}(t):e}function E(t){return (E=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function N(t,e){return (N=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var j=function(t){function e(t,n,o){var i;return function(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}(this,e),(i=P(this,E(e).call(this))).options=function(t){
	var arguments$1 = arguments;
	for(var e=1;e<arguments.length;e++){var n=null!=arguments$1[e]?arguments$1[e]:{},o=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),o.forEach(function(e){O(t,e,n[e]);});}return t}({isFirst:!0,isLast:!0,totalCount:1,currentIndex:0,offset:0,showButtons:!0,closeBtnText:"Close",doneBtnText:"Done",startBtnText:"Next &rarr;",nextBtnText:"Next &rarr;",prevBtnText:"&larr; Previous"},t),i.window=n,i.document=o,i}var n,o;return function(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function"); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&N(t,e);}(e,x),n=e,(o=[{key:"attachNode",value:function(){var t=this.document.getElementById("driver-popover-item");t&&t.parentElement.removeChild(t),t=p(function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return '\n  <div id="'.concat("driver-popover-item",'" class="').concat(t,'">\n    <div class="').concat("driver-popover-tip",'"></div>\n    <div class="').concat("driver-popover-title",'">Popover Title</div>\n    <div class="').concat("driver-popover-description",'">Popover Description</div>\n    <div class="driver-clearfix ').concat("driver-popover-footer",'">\n      <button class="').concat("driver-close-btn",'">Close</button>\n      <span class="driver-btn-group ').concat("driver-navigation-btns",'">\n        <button class="').concat("driver-prev-btn",'">&larr; Previous</button>\n        <button class="').concat("driver-next-btn",'">Next &rarr;</button>\n      </span>\n    </div>\n  </div>')}(this.options.className)),document.body.appendChild(t),this.node=t,this.tipNode=t.querySelector(".".concat("driver-popover-tip")),this.titleNode=t.querySelector(".".concat("driver-popover-title")),this.descriptionNode=t.querySelector(".".concat("driver-popover-description")),this.footerNode=t.querySelector(".".concat("driver-popover-footer")),this.nextBtnNode=t.querySelector(".".concat("driver-next-btn")),this.prevBtnNode=t.querySelector(".".concat("driver-prev-btn")),this.closeBtnNode=t.querySelector(".".concat("driver-close-btn"));}},{key:"getTitleNode",value:function(){return this.titleNode}},{key:"getDescriptionNode",value:function(){return this.descriptionNode}},{key:"hide",value:function(){this.node&&(this.node.style.display="none");}},{key:"setInitialState",value:function(){this.node.style.display="block",this.node.style.left="0",this.node.style.top="0",this.node.style.bottom="",this.node.style.right="",this.node.querySelector(".".concat("driver-popover-tip")).className="driver-popover-tip";}},{key:"show",value:function(t){switch(this.attachNode(),this.setInitialState(),this.titleNode.innerHTML=this.options.title,this.descriptionNode.innerHTML=this.options.description||"",this.renderFooter(),this.options.position){case"left":case"left-top":this.positionOnLeft(t);break;case"left-center":this.positionOnLeftCenter(t);break;case"left-bottom":this.positionOnLeftBottom(t);break;case"right":case"right-top":this.positionOnRight(t);break;case"right-center":this.positionOnRightCenter(t);break;case"right-bottom":this.positionOnRightBottom(t);break;case"top":case"top-left":this.positionOnTop(t);break;case"top-center":this.positionOnTopCenter(t);break;case"top-right":this.positionOnTopRight(t);break;case"bottom":case"bottom-left":this.positionOnBottom(t);break;case"bottom-center":this.positionOnBottomCenter(t);break;case"bottom-right":this.positionOnBottomRight(t);break;case"mid-center":this.positionOnMidCenter(t);break;case"auto":default:this.autoPosition(t);}this.bringInView();}},{key:"renderFooter",value:function(){this.nextBtnNode.innerHTML=this.options.nextBtnText,this.prevBtnNode.innerHTML=this.options.prevBtnText,this.closeBtnNode.innerHTML=this.options.closeBtnText;var t=this.options.totalCount&&1!==this.options.totalCount;this.options.showButtons?(t?(this.nextBtnNode.style.display="inline-block",this.prevBtnNode.style.display="inline-block",this.closeBtnNode.classList.remove("driver-close-only-btn")):(this.nextBtnNode.style.display="none",this.prevBtnNode.style.display="none",this.closeBtnNode.classList.add("driver-close-only-btn")),this.footerNode.style.display="block",this.options.isFirst?(this.prevBtnNode.classList.add("driver-disabled"),this.nextBtnNode.innerHTML=this.options.startBtnText):this.prevBtnNode.classList.remove("driver-disabled"),this.options.isLast?this.nextBtnNode.innerHTML=this.options.doneBtnText:this.nextBtnNode.innerHTML=this.options.nextBtnText):this.footerNode.style.display="none";}},{key:"positionOnLeft",value:function(t){var e=this.getSize().width,n=this.options.padding+10;this.node.style.left="".concat(t.left-e-n,"px"),this.node.style.top="".concat(t.top+this.options.offset-this.options.padding,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("right");}},{key:"positionOnLeftBottom",value:function(t){var e=this.getSize(),n=e.width,o=this.options.padding+10;this.node.style.left="".concat(t.left-n-o,"px"),this.node.style.top="".concat(t.bottom+this.options.padding+this.options.offset-e.height,"px"),this.node.style.bottom="",this.node.style.right="",this.tipNode.classList.add("right","position-bottom");}},{key:"positionOnLeftCenter",value:function(t){var e=this.getSize(),n=e.width,o=e.height/2,i=this.options.padding+10,r=(t.bottom-t.top)/2,s=t.top-o+r+this.options.offset;this.node.style.left="".concat(t.left-n-i,"px"),this.node.style.top="".concat(s,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("right","position-center");}},{key:"positionOnRight",value:function(t){var e=this.options.padding+10;this.node.style.left="".concat(t.right+e,"px"),this.node.style.top="".concat(t.top+this.options.offset-this.options.padding,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("left");}},{key:"positionOnRightCenter",value:function(t){var e=this.getSize(),n=this.options.padding+10,o=e.height/2,i=(t.bottom-t.top)/2,r=t.top-o+i+this.options.offset;this.node.style.left="".concat(t.right+n,"px"),this.node.style.top="".concat(r,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("left","position-center");}},{key:"positionOnRightBottom",value:function(t){var e=this.options.padding+10,n=this.getSize();this.node.style.left="".concat(t.right+e,"px"),this.node.style.top="".concat(t.bottom+this.options.padding+this.options.offset-n.height,"px"),this.node.style.bottom="",this.node.style.right="",this.tipNode.classList.add("left","position-bottom");}},{key:"positionOnTop",value:function(t){var e=this.getSize().height,n=this.options.padding+10;this.node.style.top="".concat(t.top-e-n,"px"),this.node.style.left="".concat(t.left-this.options.padding+this.options.offset,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("bottom");}},{key:"positionOnTopCenter",value:function(t){var e=this.getSize(),n=e.height,o=e.width/2,i=this.options.padding+10,r=this.options.offset+t.left+(t.right-t.left)/2;this.node.style.top="".concat(t.top-n-i,"px"),this.node.style.left="".concat(r-o-this.options.padding,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("bottom","position-center");}},{key:"positionOnTopRight",value:function(t){var e=this.getSize(),n=e.height,o=this.options.padding+10;this.node.style.top="".concat(t.top-n-o,"px"),this.node.style.left="".concat(t.right+this.options.padding+this.options.offset-e.width,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("bottom","position-right");}},{key:"positionOnBottom",value:function(t){var e=this.options.padding+10;this.node.style.top="".concat(t.bottom+e,"px"),this.node.style.left="".concat(t.left-this.options.padding+this.options.offset,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("top");}},{key:"positionOnBottomCenter",value:function(t){var e=this.getSize().width/2,n=this.options.padding+10,o=this.options.offset+t.left+(t.right-t.left)/2;this.node.style.top="".concat(t.bottom+n,"px"),this.node.style.left="".concat(o-e-this.options.padding,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("top","position-center");}},{key:"positionOnBottomRight",value:function(t){var e=this.getSize(),n=this.options.padding+10;this.node.style.top="".concat(t.bottom+n,"px"),this.node.style.left="".concat(t.right+this.options.padding+this.options.offset-e.width,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("top","position-right");}},{key:"positionOnMidCenter",value:function(t){var e=this.getSize(),n=e.height,o=e.width/2,i=n/2,r=(t.bottom-t.top)/2,s=t.top-i+r+this.options.offset,a=this.options.offset+t.left+(t.right-t.left)/2;this.node.style.top="".concat(s,"px"),this.node.style.left="".concat(a-o-this.options.padding,"px"),this.node.style.right="",this.node.style.bottom="",this.tipNode.classList.add("mid-center");}},{key:"autoPosition",value:function(t){var e=this.getFullPageSize(),n=this.getSize(),o=e.height,i=n.height,r=this.options.padding+10;t.bottom+i+r>=o?this.positionOnTop(t):this.positionOnBottom(t);}}])&&k(n.prototype,o),e}();function L(t){return (L="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function T(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o);}}function C(t,e){return !e||"object"!==L(e)&&"function"!=typeof e?function(t){if(void 0===t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return t}(t):e}function _(t){return (_=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function M(t,e){return (M=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var H=function(t){function e(t,n,o){var i;return function(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}(this,e),(i=C(this,_(e).call(this))).options=t,i.window=n,i.document=o,i}var n,o;return function(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function"); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&M(t,e);}(e,x),n=e,(o=[{key:"attachNode",value:function(){var t=this.document.getElementById(u);t||(t=p(h),document.body.appendChild(t)),this.node=t,this.options.animate?this.node.classList.remove("driver-stage-no-animation"):this.node.classList.add("driver-stage-no-animation");}},{key:"hide",value:function(){this.node&&this.node.parentElement&&this.node.parentElement.removeChild(this.node);}},{key:"setInitialStyle",value:function(){this.node.style.display="block",this.node.style.left="0",this.node.style.top="0",this.node.style.bottom="",this.node.style.right="";}},{key:"show",value:function(t){this.attachNode(),this.setInitialStyle();var e=2*this.options.padding,n=t.right-t.left+e,o=t.bottom-t.top+e;this.node.style.display="block",this.node.style.position="absolute",this.node.style.width="".concat(n,"px"),this.node.style.height="".concat(o,"px"),this.node.style.top="".concat(t.top-e/2,"px"),this.node.style.left="".concat(t.left-e/2,"px"),this.node.style.backgroundColor=this.options.stageBackground;}}])&&T(n.prototype,o),e}();function B(t){
	var arguments$1 = arguments;
	for(var e=1;e<arguments.length;e++){var n=null!=arguments$1[e]?arguments$1[e]:{},o=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),o.forEach(function(e){F(t,e,n[e]);});}return t}function F(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function I(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o);}}n.d(e,"default",function(){return R});var R=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};!function(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}(this,t),this.options=B({animate:r,opacity:o,padding:i,scrollIntoViewOptions:null,allowClose:s,keyboardControl:a,overlayClickNext:c,stageBackground:"#ffffff",onHighlightStarted:function(){return null},onHighlighted:function(){return null},onDeselected:function(){return null},onReset:function(){return null},onNext:function(){return null},onPrevious:function(){return null}},e),this.document=document,this.window=window,this.isActivated=!1,this.steps=[],this.currentStep=0,this.currentMovePrevented=!1,this.overlay=new g(this.options,window,document),this.onResize=this.onResize.bind(this),this.onKeyUp=this.onKeyUp.bind(this),this.onClick=this.onClick.bind(this),this.moveNext=this.moveNext.bind(this),this.movePrevious=this.movePrevious.bind(this),this.preventMove=this.preventMove.bind(this),this.bind();}var e,n;return e=t,(n=[{key:"getSteps",value:function(){return this.steps}},{key:"setSteps",value:function(t){this.steps=t;}},{key:"bind",value:function(){this.window.addEventListener("resize",this.onResize,!1),this.window.addEventListener("keyup",this.onKeyUp,!1),"ontouchstart"in document.documentElement?this.window.addEventListener("touchstart",this.onClick,!1):this.window.addEventListener("click",this.onClick,!1);}},{key:"onClick",value:function(t){if(this.isActivated&&this.hasHighlightedElement()){t.stopPropagation();var e=this.overlay.getHighlightedElement(),n=this.document.getElementById("driver-popover-item"),o=e.node.contains(t.target),i=n&&n.contains(t.target);if(o||i||!this.options.overlayClickNext){ if(o||i||!this.options.allowClose){var r=t.target.classList.contains("driver-next-btn"),s=t.target.classList.contains("driver-prev-btn");t.target.classList.contains("driver-close-btn")?this.reset():r?this.handleNext():s&&this.handlePrevious();}else { this.reset(); } }else { this.handleNext(); }}}},{key:"onResize",value:function(){this.isActivated&&this.refresh();}},{key:"refresh",value:function(){this.overlay.refresh();}},{key:"onKeyUp",value:function(t){if(this.isActivated&&this.options.keyboardControl){ if(27!==t.keyCode){var e=this.getHighlightedElement();e&&e.popover&&(39===t.keyCode?this.handleNext():37===t.keyCode&&this.handlePrevious());}else { this.reset(); } }}},{key:"movePrevious",value:function(){var t=this.steps[this.currentStep-1];t?(this.overlay.highlight(t),this.currentStep-=1):this.reset();}},{key:"preventMove",value:function(){this.currentMovePrevented=!0;}},{key:"handleNext",value:function(){this.currentMovePrevented=!1;var t=this.steps[this.currentStep];t&&t.options&&t.options.onNext&&t.options.onNext(this.overlay.highlightedElement),this.currentMovePrevented||this.moveNext();}},{key:"handlePrevious",value:function(){this.currentMovePrevented=!1;var t=this.steps[this.currentStep];t&&t.options&&t.options.onPrevious&&t.options.onPrevious(this.overlay.highlightedElement),this.currentMovePrevented||this.movePrevious();}},{key:"moveNext",value:function(){var t=this.steps[this.currentStep+1];t?(this.overlay.highlight(t),this.currentStep+=1):this.reset();}},{key:"hasNextStep",value:function(){return !!this.steps[this.currentStep+1]}},{key:"hasPreviousStep",value:function(){return !!this.steps[this.currentStep-1]}},{key:"reset",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.currentStep=0,this.isActivated=!1,this.overlay.clear(t);}},{key:"hasHighlightedElement",value:function(){var t=this.overlay.getHighlightedElement();return t&&t.node}},{key:"getHighlightedElement",value:function(){return this.overlay.getHighlightedElement()}},{key:"getLastHighlightedElement",value:function(){return this.overlay.getLastHighlightedElement()}},{key:"defineSteps",value:function(t){this.steps=[];for(var e=0;e<t.length;e++){var n=this.prepareElementFromStep(t[e],t,e);n&&this.steps.push(n);}}},{key:"prepareElementFromStep",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=B({},this.options),i=t,r="string"!=typeof t&&!v(t);if(!t||r&&!t.element){ throw new Error("Element is required in step ".concat(n)); }r&&(i=t.element,o=B({},this.options,t));var s=v(i)?i:this.document.querySelector(i);if(!s){ return console.warn("Element to highlight ".concat(i," not found")),null; }var a=null;if(o.popover&&o.popover.title){var c=[this.options.className,o.popover.className].filter(function(t){return t}).join(" "),u=B({},o,o.popover,{className:c,totalCount:e.length,currentIndex:n,isFirst:0===n,isLast:0===e.length||n===e.length-1});a=new j(u,this.window,this.document);}var l=B({},o),h=new H(l,this.window,this.document);return new x({node:s,options:o,popover:a,stage:h,overlay:this.overlay,window:this.window,document:this.document})}},{key:"start",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(!this.steps||0===this.steps.length){ throw new Error("There are no steps defined to iterate"); }this.isActivated=!0,this.currentStep=t,this.overlay.highlight(this.steps[t]);}},{key:"highlight",value:function(t){this.isActivated=!0;var e=this.prepareElementFromStep(t);e&&this.overlay.highlight(e);}}])&&I(e.prototype,n),t}();}]).default});

	});

	var Driver = unwrapExports(driver_min);
	var driver_min_1 = driver_min.Driver;

	frappe.Driver = Driver;

	frappe.provide('frappe.barcode');

	frappe.barcode.scan_barcode = function() {
		return new Promise(function (resolve, reject) {
			if (
				window.cordova &&
				window.cordova.plugins &&
				window.cordova.plugins.barcodeScanner
			) {
				window.cordova.plugins.barcodeScanner.scan(function (result) {
					if (!result.cancelled) {
						resolve(result.text);
					}
				}, reject);
			} else {
				frappe.require('/assets/js/barcode_scanner.min.js', function () {
					frappe.barcode.get_barcode().then(function (barcode) {
						resolve(barcode);
					});
				});
			}
		});
	};

	exports.__moduleExports = _class;

	return exports;

}({}));
//# sourceMappingURL=desk.min.js.map
